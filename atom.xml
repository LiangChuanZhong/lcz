<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cz-liang</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-31T17:58:06.405Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cz-liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023前端面试题</title>
    <link href="http://example.com/2023/04/28/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/04/28/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-04-28T07:03:09.000Z</published>
    <updated>2023-08-31T17:58:06.405Z</updated>
    
    <content type="html"><![CDATA[<p>2023 前端面试题</p><span id="more"></span><p>目录结构</p><ul><li><a href="#html">HTML</a></li><li><a href="#css">CSS</a></li><li><a href="#javascript">JavaScript</a></li><li><a href="#typescript">TypeScript</a></li><li><a href="#node">Node</a></li><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></li><li><a href="#MVVM%E6%A1%86%E6%9E%B6">MVVM 框架</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96">前端工程化</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD">前端性能</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7">前端监控</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8">前端安全</a></li><li><a href="#%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91">跨端开发</a></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li><li><a href="#%E8%BF%90%E7%BB%B4">运维</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E9%A2%98">前端手写题</a></li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="DOCTYPE-有什么作用？"><a href="#DOCTYPE-有什么作用？" class="headerlink" title="DOCTYPE 有什么作用？"></a>DOCTYPE 有什么作用？</h3><p>DOCTYPE 是一种指示浏览器以何种 HTML 或 XHTML 规范来解析文档的声明。它能够告知浏览器网页文档使用的标记语言的类型以及版本，从而确保浏览器能够正确地展示网页内容。DOCTYPE 声明通常位于 HTML 文档的开头，是 HTML 文档的必须部分。</p><h3 id="img-标签的-title-和-alt-属性有什么区别"><a href="#img-标签的-title-和-alt-属性有什么区别" class="headerlink" title="img 标签的 title 和 alt 属性有什么区别"></a>img 标签的 title 和 alt 属性有什么区别</h3><p><code>alt</code>属性用于为图像提供替代文本，即使图像无法加载，也可以描述图像内容，提高网页的可访问性和可用性。<code>title</code>属性则提供有关图像的额外信息，可以通过鼠标悬停或使用辅助技术来查看。它通常用于提供更多的上下文或补充描述，但并不是必需的。</p><h3 id="简述一下-src-与-href-的区别"><a href="#简述一下-src-与-href-的区别" class="headerlink" title="简述一下 src 与 href 的区别"></a>简述一下 src 与 href 的区别</h3><p>在 HTML 中，<code>src</code> 属性是用来指定外部资源的 URL，如图像、脚本或嵌入式对象的位置。例如，<code>&lt;img&gt;</code> 标签中的 <code>src</code> 属性指定图像的 URL。</p><p>而 <code>href</code> 属性则用来指定超文本链接的目标资源的位置，如超链接或 <code>link</code> 标记中的外部样式表。例如，<code>&lt;a&gt;</code> 标签中的 <code>href</code> 属性指定了链接目标的 URL。</p><h3 id="iframe-有哪些优缺点？"><a href="#iframe-有哪些优缺点？" class="headerlink" title="iframe 有哪些优缺点？"></a>iframe 有哪些优缺点？</h3><p><code>iframe</code>（内联框架）是一种 HTML 元素，它允许在当前文档中嵌入另一个独立的 HTML 文档。<code>iframe</code> 有一些优点和缺点：</p><p>优点：</p><ol><li><strong>内容隔离</strong>：<code>iframe</code> 可以将不同来源的内容隔离开来，使得它们在不同的上下文中运行。这有助于保护当前文档免受潜在的安全风险，并确保不同来源的内容不会互相干扰。</li><li><strong>异步加载</strong>：<code>iframe</code> 中的内容可以异步加载，这意味着页面主体内容可以在 <code>iframe</code> 加载完成之前呈现。这有助于提高页面加载速度。</li><li><strong>独立滚动</strong>：<code>iframe</code> 内的内容可以独立滚动，而不会影响主页面的滚动。这有助于在需要展示大量内容的情况下，提高用户体验。</li><li><strong>跨域资源访问</strong>：在一定程度上，<code>iframe</code> 可以用于访问跨域资源，例如嵌入来自其他域的网页或应用。</li></ol><p>缺点：</p><ol><li><strong>性能影响</strong>：<code>iframe</code> 的使用可能会导致性能下降，因为它需要浏览器加载额外的文档资源。每个嵌入的 <code>iframe</code> 都需要额外的 HTTP 请求，这可能会延长页面加载时间。</li><li><strong>复杂性增加</strong>：<code>iframe</code> 的使用可能会使页面结构更加复杂，导致维护困难。而且，在 <code>iframe</code> 和主页面之间进行通信可能会涉及到跨域问题，这会增加开发难度。</li><li><strong>SEO 不友好</strong>：搜索引擎可能无法完全索引 <code>iframe</code> 中的内容，这会影响到网页的搜索引擎优化（SEO）。</li><li><strong>可访问性问题</strong>：<code>iframe</code> 在某些情况下可能导致可访问性问题。例如，屏幕阅读器可能无法正确解析 <code>iframe</code> 中的内容，导致部分用户无法访问这些内容。</li></ol><p>综上所述，<code>iframe</code> 有一些优点，如内容隔离、异步加载和独立滚动等。然而，它也有一些缺点，如性能影响、复杂性增加、SEO 不友好和可访问性问题等。在使用 <code>iframe</code> 时，需要权衡这些优缺点，确保它适用于你的需求。</p><h3 id="常用的-meta-标签有哪些？"><a href="#常用的-meta-标签有哪些？" class="headerlink" title="常用的 meta 标签有哪些？"></a>常用的 meta 标签有哪些？</h3><p><code>meta</code> 标签提供了有关 HTML 文档的元数据，如描述、关键词、作者等。以下是一些常用的 <code>meta</code> 标签：</p><ol><li><p><strong>字符集声明</strong>：声明文档使用的字符编码，通常为 UTF-8。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>视口设置</strong>：控制页面在移动设备上的显示方式，如缩放级别和页面宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>页面描述</strong>：提供页面的简短描述，有助于搜索引擎了解页面内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;A brief description of the page.&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关键词</strong>：设置页面关键词，有助于搜索引擎优化（SEO）。但请注意，大多数现代搜索引擎不再使用此标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;keyword1, keyword2, keyword3&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>作者</strong>：指定页面作者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Author Name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>禁止缓存</strong>：告诉浏览器不要缓存页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;no-cache, no-store, must-revalidate&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自动刷新</strong>：设置页面在特定时间间隔后自动刷新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>跳转到其他页面</strong>：在指定的时间间隔后，自动将用户重定向到其他页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;5; URL=https://example.com/new-page.html&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>兼容模式</strong>：指定浏览器（如 Internet Explorer）使用特定的渲染模式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>搜索引擎索引控制</strong>：指示搜索引擎是否应索引页面和跟踪链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index, follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些常用的 <code>meta</code> 标签可以帮助你控制页面的显示、搜索引擎优化和其他功能。根据页面需求，可以根据需要添加更多的 <code>meta</code> 标签。</p><h3 id="H5-和-H4-有什么不同？"><a href="#H5-和-H4-有什么不同？" class="headerlink" title="H5 和 H4 有什么不同？"></a>H5 和 H4 有什么不同？</h3><ul><li>语义化标签: <code>header</code>、<code>footer</code>、<code>nav</code>、<code>section</code>、<code>article</code>、<code>aside</code> 等</li><li>增强型表单：<code>date</code>(从一个日期选择器选择一个日期) 、<code>email</code>(包含 e-mail 地址的输入域) 、<code>number</code>(数值的输入域) 、<code>range</code>(一定范围内数字值的输入域) 、<code>search</code>(用于搜索域) 、<code>tel</code>(定义输入电话号码字段) 等</li><li>视频和音频：<code>audio</code>、<code>video</code></li><li><code>Canvas</code>绘图、 <code>SVG</code>绘图</li><li>地理定位：<code>Geolocation</code></li><li>拖放 API：<code>drag</code></li><li><code>web worker</code>：是运行在后台的 <code>JavaScript</code>，独立于其他脚本，不会影响页面的性能</li><li><code>web storage</code>: <code>localStorage</code>、<code>sessionStorage</code></li><li><code>WebSocket</code>: <code>HTML5</code> 开始提供的一种在单个 <code>TCP</code> 连接上进行全双工通讯的协议</li></ul><h3 id="SVG-和-CANVAS-的区别？"><a href="#SVG-和-CANVAS-的区别？" class="headerlink" title="SVG 和 CANVAS 的区别？"></a>SVG 和 CANVAS 的区别？</h3><p>SVG 和 Canvas 都是用于在 web 上绘制图形的技术，但它们有几个主要区别:</p><ol><li>SVG 是基于矢量图的，而 Canvas 是基于像素图的。</li><li>在 SVG 中，每个绘制的元素都是一个独立的 DOM 对象，并且可以轻松地与 JavaScript 交互。 在 Canvas 中，所有绘制都被放置在一个画布中，并且只能与像素级别进行交互。</li><li>SVG 通常适用于静态图形，而 Canvas 适用于动态图形，例如游戏和数据可视化。</li></ol><p>简而言之，SVG 适用于需要与 DOM 交互并具有复杂动画和交互的情况，而 Canvas 则适用于创建大量图形对象和复杂动画。</p><h3 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别 ?"></a>defer 和 async 的区别 ?</h3><p>defer 和 async 都是用于脚本加载和执行的关键字，两者的主要区别如下：</p><ol><li>defer 脚本会在 HTML 文档解析完成后执行，而 async 脚本会在下载完毕后立即执行。</li><li>defer 脚本会按照它们在文档中的顺序执行，而 async 脚本是在下载完成后尽快执行，可能会打乱它们在文档中的顺序。</li><li>defer 脚本会在 DOMContentLoaded 事件之后运行，而 async 脚本则不一定。</li></ol><p>因此，如果需要按顺序执行脚本并且不想阻塞 DOM 的解析，可以使用 defer。如果脚本的执行不依赖于其他脚本或 DOM，可以使用 async 加快加载速度。</p><h3 id="style-标签-prefetch-和-preload-区别？"><a href="#style-标签-prefetch-和-preload-区别？" class="headerlink" title="style 标签 prefetch 和 preload 区别？"></a>style 标签 prefetch 和 preload 区别？</h3><p><code>&lt;style&gt;</code>标签的<code>prefetch</code>和<code>preload</code>属性都用于优化 CSS 资源的加载，但它们有不同的行为和目的：</p><ul><li><code>prefetch</code>属性告诉浏览器这个 CSS 资源可能在未来的某个时刻需要被加载，但并不需要立即加载。浏览器会在空闲时间异步加载这个资源，以便在需要时能够立即使用。<code>prefetch</code>适用于那些当前不需要但是可能在未来会需要使用的资源。</li><li><code>preload</code>属性则告诉浏览器这个 CSS 资源在当前页面中必须被使用，因此应该立即加载和执行。浏览器会在主 HTML 文档下载和解析完成之前加载这个资源。<code>preload</code>适用于那些当前需要使用的资源。</li></ul><hr /><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-属性是否区分大小写？"><a href="#CSS-属性是否区分大小写？" class="headerlink" title="CSS 属性是否区分大小写？"></a>CSS 属性是否区分大小写？</h3><p>CSS 属性名和属性值在大多数情况下是不区分大小写的，但也有少数例外情况，如 font-variant 和 text-decoration 等属性与其值中的某些字母是区分大小写的。建议在编写 CSS 代码时还是严格遵守大小写以避免不必要的错误。</p><h3 id="CSS-的盒模型"><a href="#CSS-的盒模型" class="headerlink" title="CSS 的盒模型?"></a>CSS 的盒模型?</h3><p>CSS 盒模型包括标准盒模型和 IE 盒模型。其中标准盒模型（box-sizing: content-box;）的宽度和高度只包括内容的宽度和高度；而 IE 盒模型（box-sizing: border-box;）的宽度和高度则包括了内容、内边距和边框的宽度和高度。这两种盒模型的主要区别在于计算元素宽度和高度时所涉及的内容不同。</p><h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与@import 的区别"></a>link 与@import 的区别</h3><p><code>&lt;link&gt;</code>和<code>@import</code>都可以用来引入外部资源，如 CSS 文件，但是它们之间有以下区别：</p><ol><li>引入方式：<code>&lt;link&gt;</code>是 HTML 标签，<code>@import</code>是 CSS 提供的一种方式。</li><li>加载顺序和性能：<code>&lt;link&gt;</code>在页面载入时同时加载，<code>@import</code>在页面载入完成后加载。</li><li>定义方式：<code>&lt;link&gt;</code>可以在文档头部定义，也可以在文档中任何地方定义，<code>@import</code>只能在样式表中定义。</li><li>加载方式：<code>&lt;link&gt;</code>可以同时加载多个外部样式表，而<code>@import</code>必须一条一条地执行。</li><li>附加功能：<code>link</code>标签支持添加一些额外属性，如<code>media</code>、<code>title</code>等，用于指定媒体类型或提供样式表的描述。<code>@import</code>不支持这些附加功能。</li><li>可控性：<code>&lt;link&gt;</code>支持动态插入，而<code>@import</code>不支持。</li></ol><h3 id="元素垂直居中的方式有哪些？"><a href="#元素垂直居中的方式有哪些？" class="headerlink" title="元素垂直居中的方式有哪些？"></a>元素垂直居中的方式有哪些？</h3><ol><li>使用 flexbox 布局，通过设置父元素的 align-items 属性为 center 实现元素垂直居中。</li><li>使用 grid 布局，可以通过设置网格项的 align-self 属性为 center 实现元素垂直居中。</li><li>使用 position 和 transform 属性，设置元素的 top 和 left 属性为 50%，并使用 transform 属性的 translate()函数将元素向上和左移动自身高度和宽度的一半，就可以实现元素垂直居中。</li><li>使用表格布局，将元素放入一个单元格中，并设置单元格的 vertical-align 属性为 middle 实现元素垂直居中。</li></ol><h3 id="文本垂直居中的方式有哪些？"><a href="#文本垂直居中的方式有哪些？" class="headerlink" title="文本垂直居中的方式有哪些？"></a>文本垂直居中的方式有哪些？</h3><ol><li>使用行高（line-height）属性，将行高设置为等于容器的高度减去文本行高，再将文本的行高设置为容器高度。</li><li>使用弹性盒子（flexbox）布局，在容器上设置 display:flex 和 align-items:center 属性。</li><li>使用网格布局（grid）将文本放置在居中单元格中。</li><li>使用绝对定位（absolute positioning）属性，并将文本的 top 和 bottom 都设置为 0，再设置 margin:auto 来水平居中</li></ol><h3 id="CSS-选择器的优先级是如何计算的？"><a href="#CSS-选择器的优先级是如何计算的？" class="headerlink" title="CSS 选择器的优先级是如何计算的？"></a>CSS 选择器的优先级是如何计算的？</h3><ol><li>!important 优先级最高</li><li>标签内样式：即在 HTML 标签内部使用 style 属性设置的样式，优先级第二高。</li><li>ID 选择器：以 # 符号开头，指定某个元素的唯一标识符，比如 #header，优先级第三高。</li><li>类选择器、属性选择器和伪类选择器：包括 .class、[attr]、:hover 等，优先级第四高。</li><li>元素选择器和伪元素选择器：包括 div、span、:before 等，优先级最低。</li></ol><p>在比较优先级时，遵循“从左到右，从高到低”的原则，也就是选择器中每增加一项就会降低一级别的优先级。如果两个选择器的优先级相同，则后面的选择器优先级更高。</p><h3 id="请阐述块格式化上下文（Block-Formatting-Context）、工作原理以及形成条件？"><a href="#请阐述块格式化上下文（Block-Formatting-Context）、工作原理以及形成条件？" class="headerlink" title="请阐述块格式化上下文（Block Formatting Context）、工作原理以及形成条件？"></a>请阐述块格式化上下文（Block Formatting Context）、工作原理以及形成条件？</h3><p>块格式化上下文（Block Formatting Context，BFC）是一个独立的渲染区域，在这个区域内，元素的布局和外部元素互不影响。BFC 是 Web 页面布局中的一种重要机制，主要用于控制块级元素的布局及其内部元素的排列方式。</p><p>BFC 的工作原理：</p><ol><li>内部的块级盒子会在垂直方向一个接一个放置。</li><li>块级盒子的垂直间距（margin）会发生折叠。相邻的块级盒子的上下外边距会取最大值，而非相加。</li><li>BFC 的区域不会与浮动盒子重叠。在计算布局时，BFC 会考虑浮动元素的占用空间，从而避免与浮动元素重叠。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li><li>BFC 是一个独立的容器，外部元素对其内部元素布局没有影响；同样，BFC 内部元素的布局也不会影响外部元素。</li></ol><p>形成 BFC 的条件：</p><p>要创建一个 BFC，需要满足以下条件之一：</p><ol><li>根元素（<code>&lt;html&gt;</code>）。</li><li>浮动元素（<code>float</code>属性为<code>left</code>或<code>right</code>）。</li><li>绝对定位元素（<code>position</code>属性为<code>absolute</code>或<code>fixed</code>）。</li><li>内联块（<code>display</code>属性为<code>inline-block</code>）。</li><li>表格单元格（<code>display</code>属性为<code>table-cell</code>）。</li><li>表格标题（<code>display</code>属性为<code>table-caption</code>）。</li><li>匿名表格单元格（<code>display</code>属性为<code>table</code>、<code>table-row</code>、<code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>、<code>table-column</code>、<code>table-column-group</code>）。</li><li>元素的<code>overflow</code>属性值不为<code>visible</code>（例如，<code>auto</code>、<code>scroll</code>、<code>hidden</code>）。</li><li>弹性盒子（<code>display</code>属性为<code>flex</code>或<code>inline-flex</code>）。</li><li>网格容器（<code>display</code>属性为<code>grid</code>或<code>inline-grid</code>）。</li><li>多列容器（<code>column-count</code>或<code>column-width</code>属性不为<code>auto</code>）。</li><li><code>contain</code>属性值为<code>layout</code>、<code>paint</code>或<code>strict</code>。</li></ol><p>通过满足以上条件之一，可以创建 BFC，实现独立渲染区域。在实际应用中，BFC 有助于解决外边距折叠、浮动元素引起的布局问题等。</p><h3 id="请阐述-z-index-属性，并说明如何形成层叠上下文（stacking-context）"><a href="#请阐述-z-index-属性，并说明如何形成层叠上下文（stacking-context）" class="headerlink" title="请阐述 z-index 属性，并说明如何形成层叠上下文（stacking context）"></a>请阐述 z-index 属性，并说明如何形成层叠上下文（stacking context）</h3><p><code>z-index</code>属性是 CSS 中用于控制元素在页面中的堆叠顺序（即在 z 轴上的顺序）的属性。具有较高<code>z-index</code>值的元素会覆盖较低<code>z-index</code>值的元素。需要注意的是，<code>z-index</code>属性只适用于具有定位属性（<code>position</code>属性值为<code>relative</code>、<code>absolute</code>或<code>fixed</code>）的元素。</p><p>层叠上下文（Stacking Context）是一个抽象概念，它定义了一个元素在 z 轴上的层次。在同一个层叠上下文中，元素的堆叠顺序由<code>z-index</code>属性控制。层叠上下文可以嵌套，形成一个层叠上下文树。层叠上下文解决了多个元素重叠时的优先级显示。</p><p>形成层叠上下文的条件：</p><ol><li>根元素（<code>&lt;html&gt;</code>）。</li><li><code>z-index</code>值不为<code>auto</code>的定位元素（<code>position</code>属性值为<code>relative</code>、<code>absolute</code>或<code>fixed</code>）。</li><li><code>z-index</code>值不为<code>auto</code>的弹性盒子（<code>display</code>属性值为<code>flex</code>或<code>inline-flex</code>）的直接子元素。</li><li><code>z-index</code>值不为<code>auto</code>的网格容器（<code>display</code>属性值为<code>grid</code>或<code>inline-grid</code>）的直接子元素。</li><li><code>opacity</code>属性值小于 1 的元素。</li><li><code>transform</code>属性值不为<code>none</code>的元素。</li><li><code>filter</code>属性值不为<code>none</code>的元素。</li><li><code>perspective</code>属性值不为<code>none</code>的元素。</li><li><code>will-change</code>属性值指定了任意形成层叠上下文的属性的元素。</li><li><code>contain</code>属性值为<code>paint</code>或<code>strict</code>的元素。</li><li><code>mix-blend-mode</code>属性值不为<code>normal</code>的元素。</li><li><code>isolation</code>属性值为<code>isolate</code>的元素。</li></ol><p>满足以上任意条件之一的元素都会创建一个新的层叠上下文。在层叠上下文中，元素会根据其<code>z-index</code>值和其他因素进行堆叠。层叠上下文有助于更好地控制元素的堆叠顺序，解决元素覆盖和遮挡的问题。</p><h3 id="CSS-有哪些继承属性？"><a href="#CSS-有哪些继承属性？" class="headerlink" title="CSS 有哪些继承属性？"></a>CSS 有哪些继承属性？</h3><ol><li>文本和字体相关属性：<ul><li><code>color</code></li><li><code>font-family</code></li><li><code>font-size</code></li><li><code>font-weight</code></li><li><code>font-style</code></li><li><code>font-variant</code></li><li><code>letter-spacing</code></li><li><code>line-height</code></li><li><code>text-align</code></li><li><code>text-indent</code></li><li><code>text-transform</code></li><li><code>white-space</code></li><li><code>word-spacing</code></li></ul></li><li>列表样式相关属性：<ul><li><code>list-style-type</code></li><li><code>list-style-position</code></li><li><code>list-style-image</code></li></ul></li><li>表格布局相关属性：<ul><li><code>border-collapse</code></li><li><code>border-spacing</code></li><li><code>caption-side</code></li><li><code>empty-cells</code></li><li><code>table-layout</code></li></ul></li><li>其他可继承属性：<ul><li><code>visibility</code></li><li><code>cursor</code></li><li><code>quotes</code></li><li><code>text-decoration</code></li><li><code>text-shadow</code></li><li><code>word-break</code></li><li><code>word-wrap</code></li><li><code>writing-mode</code></li><li><code>direction</code></li></ul></li></ol><h3 id="有哪些清除浮动的技术，都适用哪些情况？"><a href="#有哪些清除浮动的技术，都适用哪些情况？" class="headerlink" title="有哪些清除浮动的技术，都适用哪些情况？"></a>有哪些清除浮动的技术，都适用哪些情况？</h3><ol><li><p>使用<code>clear</code>属性： 在浮动元素后添加一个空元素，然后使用 CSS 的<code>clear</code>属性来清除浮动。适用于简单布局和较早的浏览器版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">float</span>: left;&quot;&gt;...&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">clear</span>: both;&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>父元素使用<code>overflow</code>属性： 为父元素添加<code>overflow: auto</code>或<code>overflow: hidden</code>属性。此方法可以使父元素自动计算其高度，包括浮动元素。适用于不需要显示滚动条的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用伪元素<code>::after</code>： 为父元素添加<code>::after</code>伪元素，并设置<code>clear: both</code>。这种方法不需要额外的 HTML 元素。适用于现代浏览器和简洁的 HTML 结构。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Flexbox 布局： 将父元素的<code>display</code>属性设置为<code>flex</code>。这会使所有子元素成为弹性项，并且不再需要清除浮动。适用于现代浏览器和需要使用弹性布局的场景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Grid 布局： 将父元素的<code>display</code>属性设置为<code>grid</code>。这会使所有子元素成为网格项，并且不再需要清除浮动。适用于现代浏览器和需要使用网格布局的场景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在实际项目中，选择哪种清除浮动的技术取决于项目的具体需求、浏览器兼容性和布局类型。现代项目通常更倾向于使用 Flexbox 或 Grid 布局来解决浮动问题。</p><h3 id="响应式布局有哪些"><a href="#响应式布局有哪些" class="headerlink" title="响应式布局有哪些"></a>响应式布局有哪些</h3><p>响应式布局是一种使网站能够自动适应不同屏幕尺寸和设备类型的设计方法。以下是一些常见的响应式布局技术：</p><ol><li>流式布局（Fluid Layout）： 使用百分比来定义元素的宽度，使元素随浏览器窗口大小变化而自动调整宽度。这种布局可以在一定程度上适应不同屏幕尺寸，但在极小或极大屏幕上可能无法提供最佳用户体验。</li><li>弹性布局（Flexible Layout）： 使用 CSS3 中的弹性盒子（Flexbox）布局模型，可以轻松创建自适应大小和顺序的布局。弹性布局可以根据屏幕尺寸自动调整元素的大小和排列，提供更好的响应式体验。</li><li>网格布局（Grid Layout）： 使用 CSS3 中的网格布局（Grid）模型，可以创建复杂的二维布局。网格布局允许在水平和垂直方向上自由排列和调整元素，从而实现高度自适应的响应式设计。</li><li>媒体查询（Media Queries）： 使用 CSS3 的媒体查询功能，可以针对不同屏幕尺寸、分辨率和设备类型应用特定的样式。结合流式布局、弹性布局和网格布局，媒体查询可以实现更精确和全面的响应式设计。</li><li>自适应图片（Responsive Images）： 使用<code>srcset</code>、<code>sizes</code>属性和<code>&lt;picture&gt;</code>元素，可以让浏览器根据设备像素比（DPR）和屏幕尺寸选择合适的图片资源。这样可以在不同设备上加载适当大小的图片，提高性能并保持视觉效果。</li><li>移动优先设计（Mobile-first Design）： 从移动设备的视角开始设计，然后逐步扩展到平板和桌面设备。这种设计方法强调简单、清晰和高效，可以提高跨设备的用户体验。</li></ol><p>在实际项目中，通常会综合运用以上技术来实现响应式布局。这些技术可以使网站在不同设备和屏幕尺寸下保持良好的用户体验和视觉效果。</p><h3 id="讲一下三栏布局实现？圣杯布局、双飞翼布局和-flex-布局"><a href="#讲一下三栏布局实现？圣杯布局、双飞翼布局和-flex-布局" class="headerlink" title="讲一下三栏布局实现？圣杯布局、双飞翼布局和 flex 布局"></a>讲一下三栏布局实现？圣杯布局、双飞翼布局和 flex 布局</h3><p>三栏布局是指一个网页由三个栏目组成的布局，分别是左栏、右栏和中间栏。下面是三种实现三栏布局的方法：</p><ol><li>圣杯布局</li></ol><p>圣杯布局是一种使用浮动和负边距实现的三栏布局。中间栏先放在 html 结构中，使用负边距将左右栏移动到中间栏的两侧，再使用相对定位将左右栏拉回原来的位置。这种布局可以使得中间栏优先渲染，兼顾 SEO 和用户体验。</p><ol start="2"><li>双飞翼布局</li></ol><p>双飞翼布局也是一种使用浮动和负边距实现的三栏布局。与圣杯布局不同的是，左右栏使用 margin 负值撑开中间栏的宽度。这种布局与圣杯布局相比，代码更简单易懂。</p><ol start="3"><li>Flex 布局</li></ol><p>Flex 布局是 CSS3 引入的一种新的布局方式，通过 flex 容器和 flex 项目的属性设置，可以轻松实现三栏布局。设置左右栏的宽度为固定值，中间栏的宽度使用 flex-grow 属性自动填充。这种布局适用于移动端和 PC 端，具有响应式的特点。</p><h3 id="使用过哪些-CSS-预处理器？它们有什么优劣？"><a href="#使用过哪些-CSS-预处理器？它们有什么优劣？" class="headerlink" title="使用过哪些 CSS 预处理器？它们有什么优劣？"></a>使用过哪些 CSS 预处理器？它们有什么优劣？</h3><p>Less 和 Sass 这两个常见的 CSS 预处理器。它们的优势是可以使用变量、嵌套规则和函数等功能，可以更简单更高效地编写 CSS 代码。缺点是需要进行额外的预处理工作，增加了开发成本。</p><h3 id="如何解决-CSS-样式在不同浏览器中的兼容性问题？"><a href="#如何解决-CSS-样式在不同浏览器中的兼容性问题？" class="headerlink" title="如何解决 CSS 样式在不同浏览器中的兼容性问题？"></a>如何解决 CSS 样式在不同浏览器中的兼容性问题？</h3><p>解决 CSS 样式在不同浏览器中的兼容性问题可以使用一些通用的方法，如使用 CSS Reset，避免使用 CSS Hack 和浏览器前缀，使用标准的组件库，尽量使用标准的 CSS 属性和属性值等。</p><h3 id="如何制作一个自适应的正方形？"><a href="#如何制作一个自适应的正方形？" class="headerlink" title="如何制作一个自适应的正方形？"></a>如何制作一个自适应的正方形？</h3><p>在外层容器内创建一个正方形元素，并设置<code>padding-bottom</code>为 100%。这里的关键是<code>padding-bottom</code>以父元素的宽度为基准计算，因此当设置为 100%时，它将等于父元素的宽度，从而保证正方形的宽高相等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;square-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;square&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">100%</span>; <span class="comment">/* 确保正方形的高度等于宽度 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>; <span class="comment">/* 设置背景颜色以便观察效果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲讲-margin-塌陷和-margin-合并以及解决方案？"><a href="#讲讲-margin-塌陷和-margin-合并以及解决方案？" class="headerlink" title="讲讲 margin 塌陷和 margin 合并以及解决方案？"></a>讲讲 margin 塌陷和 margin 合并以及解决方案？</h3><p><strong>margin 塌陷</strong> 和 <strong>margin 合并</strong> 都是 CSS 中描述 margin 行为的术语。它们分别指 margin 在不同场景下的特殊表现。</p><ol><li><strong>Margin 塌陷</strong>：Margin 塌陷是指当一个元素的上外边距（margin-top）和相邻的另一个元素的下外边距（margin-bottom）相遇时，它们之间的距离实际上等于两个外边距中的较大值，而不是它们的总和。这种现象主要发生在具有相邻兄弟元素的块级元素之间。</li><li><strong>Margin 合并</strong>：Margin 合并是指在父子元素之间发生的现象。当一个元素的外边距与其父元素的外边距相遇时，它们之间的距离实际上等于两个外边距中的较大值，而不是它们的总和。Margin 合并通常发生在没有边框、内边距或行内内容分隔的父元素与其第一个或最后一个子元素之间。</li></ol><p>解决方案：</p><p>针对 margin 塌陷和合并的现象，有以下几种解决方案：</p><ol><li><strong>使用内边距（padding）</strong>：如果适用，可以使用内边距代替外边距来调整元素之间的距离。内边距不会发生塌陷或合并。</li><li><strong>添加边框（border）或内边距（padding）</strong>：在父子元素间的 margin 合并问题上，可以通过给父元素添加一个边框或一个很小的内边距来阻止 margin 合并。</li><li><strong>使用 BFC（块格式化上下文）</strong>：创建一个新的 BFC（如通过设置 <code>overflow</code> 属性为 <code>auto</code> 或 <code>hidden</code>）可以防止父子元素间的 margin 合并。</li><li><strong>使用伪元素</strong>：可以通过在两个相邻的兄弟元素之间插入一个透明的伪元素（如 <code>::before</code> 或 <code>::after</code>），并为其添加 <code>display: inline-block;</code> 属性来防止兄弟元素间的 margin 塌陷。</li><li><strong>避免使用外边距</strong>：在某些情况下，可以使用其他布局技术（如 Flexbox 或 Grid）来调整元素之间的距离，从而避免 margin 塌陷和合并的问题。</li></ol><p>了解 margin 塌陷和合并现象以及如何解决这些问题可以帮助你更好地控制布局和元素间距。</p><h3 id="如何实现一个三角形？"><a href="#如何实现一个三角形？" class="headerlink" title="如何实现一个三角形？"></a>如何实现一个三角形？</h3><p>使用 CSS 创建一个三角形的常见方法是利用边框（border）属性。具体操作如下：</p><ol><li>首先，创建一个宽高为 0 的元素（如 <code>div</code>），这样它的内容区域将不占据任何空间。</li><li>为该元素设置透明边框，这样它的边框也不会显示出来。</li><li>根据你需要的三角形方向，设置一个边框颜色，使该边框变得可见。</li></ol><p>以下是一个创建向上的三角形的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.triangle</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;triangle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为 <code>.triangle</code> 的 <code>div</code> 元素。我们将其宽度和高度设置为 0，然后为其添加了左、右和底边框。左右边框设置为透明，底边框设置为红色。这将创建一个向上的红色三角形。</p><h3 id="如何画一条-0-5px-的线"><a href="#如何画一条-0-5px-的线" class="headerlink" title="如何画一条 0.5px 的线"></a>如何画一条 0.5px 的线</h3><p>要在屏幕上绘制一条 0.5px 的线，可以使用 CSS 的伪元素 <code>::before</code> 或 <code>::after</code>，并设置它们的尺寸和缩放（scale）。以下是一个绘制 0.5px 水平线的示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.half-pixel-line</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.half-pixel-line</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视差滚动效果的原理？"><a href="#视差滚动效果的原理？" class="headerlink" title="视差滚动效果的原理？"></a>视差滚动效果的原理？</h3><p>视差滚动效果（Parallax Scrolling）是一种视觉设计技巧，通过在页面滚动时以不同速度移动前景和背景元素，从而产生深度感和动态效果。这种效果可以使网页看起来更有趣、更具吸引力。</p><p>视差滚动效果的原理在于，当用户滚动页面时，页面上的不同元素（例如前景、背景、文字等）以不同的速度移动。这些速度差使得靠近观察者的元素（前景）看起来移动得更快，而远离观察者的元素（背景）看起来移动得更慢。这种相对运动产生了一种错觉，使用户感觉到页面的不同部分之间有深度关系，从而增强了视觉体验。</p><p>要实现视差滚动效果，可以使用以下方法之一：</p><ol><li><strong>纯 CSS 方法</strong>：利用 CSS3 的 <code>background-attachment</code> 属性设置为 <code>fixed</code>。这种方法简单易实现，但仅适用于背景图像，并且在某些浏览器或设备上可能存在兼容性问题。</li><li><strong>JavaScript 方法</strong>：通过监听页面滚动事件，根据滚动位置动态调整元素的位置。这种方法更灵活，可以应用于任何元素，并且可以实现更复杂的视差效果。通常使用 JavaScript 库（如 Rellax.js、Parallax.js 等）来简化开发过程。</li></ol><p>需要注意的是，过多或不合适的视差滚动效果可能会导致页面性能下降、用户体验受损，因此在实现视差滚动效果时要保持适度。</p><hr /><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="js-有哪些内置对象？"><a href="#js-有哪些内置对象？" class="headerlink" title="js 有哪些内置对象？"></a>js 有哪些内置对象？</h3><p>JavaScript 有许多内置对象，包括但不限于：</p><ul><li>基本对象： Object、Boolean、Symbol、Number、String</li><li>符合数据结构：Array、Set、Map、WeakSet、WeakMap</li><li>日期和时间对象：Date</li><li>数学计算对象：Math</li><li>正则表达式对象：RegExp</li><li>函数对象：Function</li><li>错误对象：Error、TypeError、RangeError 等</li><li>其他对象：Global、JSON 等</li></ul><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包是指一个函数可以访问另一个函数作用域内的变量。当一个函数嵌套在另一个函数中时，内部函数可以访问外部函数的变量，即使外部函数已经返回了。这种情况下，内部函数形成了一个闭包，它保留了外部函数的作用域链并可以继续访问这些变量。闭包常常用于实现函数的封装和私有化，以及在回调和事件处理等场景下的数据共享与传递。</p><h3 id="如何理解作用域、作用域链和执行上下文？"><a href="#如何理解作用域、作用域链和执行上下文？" class="headerlink" title="如何理解作用域、作用域链和执行上下文？"></a>如何理解作用域、作用域链和执行上下文？</h3><p>在 JavaScript 中，作用域、作用域链和执行上下文是密切相关的概念，它们与变量和函数的查找、访问以及生命周期有关。</p><ol><li><p>作用域（Scope）：</p><p><strong>作用域是一个变量或函数的可访问范围</strong>。JavaScript 中有三种作用域：<strong>全局作用域</strong>、<strong>局部（函数）作用域</strong>和<strong>块级作用域</strong>。全局作用域中声明的变量和函数可以在整个代码中访问，局部作用域中声明的变量和函数只能在特定的函数内部访问，块级作用域在一对花括号内定义，对<code>let</code>和<code>const</code>关键字声明的变量有效。</p><p>变量的生命周期受其作用域的限制。全局作用域中的变量在整个程序执行过程中持续存在，局部作用域中的变量在函数执行结束时销毁，块级作用域在代码块执行结束时，块级作用域中的变量将被销毁。</p></li><li><p>作用域链（Scope Chain）：</p><p><strong>当代码执行过程中访问一个变量或函数时，JavaScript 引擎会沿着作用域链查找该标识符</strong>。作用域链是由当前执行上下文的作用域和其所有父级作用域组成的链表。</p><p>查找过程从当前作用域开始，然后逐级向上查找，直到找到目标标识符或到达全局作用域。如果在全局作用域中仍未找到目标标识符，则返回<code>undefined</code>。</p></li><li><p>执行上下文（Execution Context）：</p><p><strong>执行上下文是 JavaScript 代码执行过程中的环境</strong>。每当进入一个新的函数执行或全局代码执行时，都会创建一个新的执行上下文。执行上下文包含了当前执行的代码所需的所有信息，如变量、函数、作用域链等。</p><p>JavaScript 引擎使用执行上下文栈（Execution Context Stack）来管理执行上下文。栈顶的执行上下文为当前执行的代码环境。当一个函数被调用时，一个新的执行上下文被压入栈顶；当函数执行结束时，执行上下文从栈顶弹出，返回到调用者的上下文环境。</p></li></ol><p>总结起来，作用域是变量和函数的可访问范围；作用域链是由当前执行上下文的作用域和其父级作用域组成的链表，用于在代码执行过程中查找变量和函数；执行上下文是代码执行过程中的环境，包含了当前执行的代码所需的所有信息。这三者共同决定了代码执行过程中变量和函数的查找、访问以及生命周期。</p><h3 id="如何创建一个没有原型的对象？"><a href="#如何创建一个没有原型的对象？" class="headerlink" title="如何创建一个没有原型的对象？"></a>如何创建一个没有原型的对象？</h3><p>可以使用 Object.create(null) 方法创建一个没有原型的对象。这个方法创建一个全新的对象并将其原型设置为 null，因此它没有继承任何属性或方法。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">toString</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="如何理解原型链？"><a href="#如何理解原型链？" class="headerlink" title="如何理解原型链？"></a>如何理解原型链？</h3><p>原型链是 JavaScript 中实现继承的一种机制，它通过让一个对象的原型指向另一个对象，从而使得一个对象可以访问另一个对象中定义的属性和方法。当我们试图访问一个对象中不存在的属性或方法时，JavaScript 引擎会沿着原型链一直向上查找，直到找到该属性或方法为止，或者最终抵达 Object.prototype（所有对象的祖先）上停止查找。</p><h3 id="let-const-var-比较"><a href="#let-const-var-比较" class="headerlink" title="let const var 比较"></a>let const var 比较</h3><ol><li>作用域：<ul><li><code>var</code>：声明的变量具有函数作用域。这意味着在函数内部声明的变量只能在该函数内部访问，而在函数外部声明的变量具有全局作用域。</li><li><code>let</code>和<code>const</code>：声明的变量具有块级作用域。这意味着变量仅在声明它们的代码块（例如：<code>if</code>语句、<code>for</code>循环、<code>while</code>循环等）内部可访问。</li></ul></li><li>变量提升（Hoisting）：<ul><li><code>var</code>：声明的变量会被提升到所在作用域的顶部。这意味着在声明之前访问变量不会导致引用错误，但变量的值将是<code>undefined</code>。</li><li><code>let</code>和<code>const</code>：声明的变量不会被提升。在声明之前访问变量会导致引用错误。</li></ul></li><li>重复声明：<ul><li><code>var</code>：允许在同一作用域内多次声明同名变量，后续声明将被忽略。</li><li><code>let</code>和<code>const</code>：在同一作用域内不允许重复声明同名变量。尝试这样做会导致语法错误。</li></ul></li><li>变量的可变性：<ul><li><code>var</code>和<code>let</code>：声明的变量可被重新赋值。</li><li><code>const</code>：声明的变量是不可变的，即一旦赋值，无法更改。这对于声明常量或确保某个变量在整个程序执行过程中保持不变的情况非常有用。</li></ul></li></ol><h3 id="谈谈你对变量提升的理解"><a href="#谈谈你对变量提升的理解" class="headerlink" title="谈谈你对变量提升的理解"></a>谈谈你对变量提升的理解</h3><p>变量提升（Hoisting）是 JavaScript 的一个核心概念，理解它对于编写和理解代码非常重要。以下是我对变量提升的理解：</p><ol><li>什么是变量提升：在 JavaScript 中，变量和函数声明（使用 var 和 function）在内部会被“提升”到它们所在作用域（全局或函数）的顶部。这意味着在代码执行之前，JavaScript 引擎已经知道这些变量和函数的存在，即使它们在源代码中的位置可能在后面。</li><li>声明与赋值：需要注意的是，提升只作用于声明，不作用于赋值或初始化。如果一个变量在后面被赋值，那么它在提升时仍被认为是<code>undefined</code>。只有当执行到赋值语句时，它才会被赋予特定的值。</li><li>var, let, const：只有用<code>var</code>声明的变量会被提升。用<code>let</code>和<code>const</code>声明的变量也有类似的提升行为，但由于它们存在“暂时性死区”（Temporal Dead Zone，TDZ），在声明前对它们的访问会导致错误。</li><li>函数提升：函数声明也会被提升，并且优先级高于变量。如果一个函数和一个变量同名，且变量未被赋值，那么该名称指向函数。</li></ol><h3 id="JSON-stringify-有什么缺点？"><a href="#JSON-stringify-有什么缺点？" class="headerlink" title="JSON.stringify 有什么缺点？"></a>JSON.stringify 有什么缺点？</h3><p><code>JSON.stringify()</code>是一个将 JavaScript 对象转换为 JSON 字符串的方法。尽管它在许多情况下非常有用，但它确实存在一些限制和缺点：</p><ol><li>循环引用：<code>JSON.stringify()</code>无法处理具有循环引用的对象。如果一个对象的属性直接或间接引用了自身，<code>JSON.stringify()</code>将抛出一个错误，表示存在循环引用。</li><li><code>undefined</code>、函数和 Symbol 忽略：<code>JSON.stringify()</code>不会序列化对象中的<code>undefined</code>、函数和 Symbol 类型的属性。这些属性将被忽略，不会出现在生成的 JSON 字符串中，单独转换则会返回<code>undefined</code>。</li><li>丢失原型链：在对象序列化后，原型链上的属性和方法将丢失。只有对象自身的可枚举属性会被序列化。因此，在反序列化（使用<code>JSON.parse()</code>）后，原始对象的原型链信息将不复存在。</li><li>日期对象处理：当使用<code>JSON.stringify()</code>序列化日期对象时，日期对象会被转换为它们的 ISO 字符串表示形式。在反序列化时，这些日期将被视为普通字符串，而不是日期对象。</li><li>非数组和非对象的值：对于不是数组或对象的顶层值（例如：字符串、数字、布尔值等），<code>JSON.stringify()</code>会直接返回其对应的 JSON 表示，而不会将其包装在对象或数组中。</li></ol><h3 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别?"></a>for…in 和 for…of 的区别?</h3><p>for…in 循环用于遍历对象的可枚举属性，返回的是属性名称；for…of 循环用于遍历可迭代对象（如数组、字符串、Map、Set 等），返回的是元素值。</p><h3 id="new-操作符都做了什么"><a href="#new-操作符都做了什么" class="headerlink" title="new 操作符都做了什么"></a>new 操作符都做了什么</h3><ol><li>创建一个新对象</li><li>对象的<code>__proto__</code>指向构造函数的<code>prototype</code></li><li>构造函数将对象绑定到<code>this</code>并调用</li><li>如果构造函数返回对象或函数则直接返回，否则返回这个新对象</li></ol><h3 id="类数组和数组的区别，dom-的类数组如何转换成数组"><a href="#类数组和数组的区别，dom-的类数组如何转换成数组" class="headerlink" title="类数组和数组的区别，dom 的类数组如何转换成数组"></a>类数组和数组的区别，dom 的类数组如何转换成数组</h3><p>类数组（Array-like）和数组（Array）都是用于存储多个值的数据结构，但它们之间存在一些关键区别：</p><ol><li>类型：数组是 JavaScript 的内置对象类型，继承自<code>Array.prototype</code>，具有一系列数组方法（如<code>push()</code>、<code>pop()</code>、<code>map()</code>等）。类数组是普通的对象，其属性名为索引（如<code>0</code>、<code>1</code>、<code>2</code>等），具有一个<code>length</code>属性，但不具备数组的方法。</li><li>原型：数组的原型为<code>Array.prototype</code>，因此具有数组的所有方法。类数组的原型通常为<code>Object.prototype</code>，并不包含数组的方法。</li></ol><p>要将 DOM 的类数组（例如，通过<code>document.getElementsByClassName()</code>或<code>document.querySelectorAll()</code>获取的元素集合）转换为数组，可以使用以下方法之一：</p><ol><li><p>使用<code>Array.from()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(nodeList);</span><br></pre></td></tr></table></figure><p><code>Array.from()</code>方法会创建一个新数组，并将类数组的元素逐个复制到新数组中。</p></li><li><p>使用扩展运算符（Spread Operator）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>扩展运算符<code>...</code>可以将类数组直接转换为数组。</p></li><li><p>使用<code>Array.prototype.slice.call()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> array = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(nodeList);</span><br></pre></td></tr></table></figure></li></ol><p><code>Array.prototype.slice.call()</code>方法会将类数组作为上下文，并创建一个新数组，将类数组的元素逐个复制到新数组中。</p><p>这些方法可以将类数组转换为数组，这样就可以在转换后的数组上使用数组的方法了。注意，这些方法不仅适用于 DOM 类数组，还适用于其他类数组对象。</p><h3 id="offsetWidth-x2F-offsetHeight，clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别"><a href="#offsetWidth-x2F-offsetHeight，clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别" class="headerlink" title="offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别"></a>offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别</h3><p>offsetWidth&#x2F;offsetHeight 是元素的可见宽度&#x2F;高度加上 padding、border 和滚动条（如果存在）的宽度&#x2F;高度。</p><p>clientWidth&#x2F;clientHeight 是元素的可见宽度&#x2F;高度，不包括 padding 和滚动条。</p><p>scrollWidth&#x2F;scrollHeight 是元素内容的完整宽度&#x2F;高度，包括溢出部分。如果元素没有溢出，则 scrollWidth&#x2F;scrollHeight 等于 clientWidth&#x2F;clientHeight。如果有溢出，则 scrollWidth&#x2F;scrollHeight 大于 clientWidth&#x2F;clientHeight。</p><h3 id="mouseover-x2F-mouseout-与-mouseenter-x2F-mouseleave-的区别与联系"><a href="#mouseover-x2F-mouseout-与-mouseenter-x2F-mouseleave-的区别与联系" class="headerlink" title="mouseover&#x2F;mouseout 与 mouseenter&#x2F;mouseleave 的区别与联系"></a>mouseover&#x2F;mouseout 与 mouseenter&#x2F;mouseleave 的区别与联系</h3><p>mouseover 和 mouseout 是 HTML DOM 事件，它们会在鼠标移入或移出元素时触发。它们也会在鼠标指针进入或离开<strong>子元素</strong>时触发。这也就是说，如果在父元素上有 mouseover 事件，并且鼠标指针进入子元素，则该元素上仍然会触发 mouseover 事件。mouseout 同理。</p><p>mouseenter 和 mouseleave 事件也是在鼠标进入或离开元素时触发。与 mouseover 和 mouseout 不同的是，mouseenter 和 mouseleave 事件<strong>不会传播到子元素</strong>。因此，如果鼠标指针进入或离开元素的子元素，则不会触发 mouseenter 和 mouseleave 事件。</p><h3 id="event-stopPropagation-与-event-stopImmediatePropagation-的区别"><a href="#event-stopPropagation-与-event-stopImmediatePropagation-的区别" class="headerlink" title="event.stopPropagation()与 event.stopImmediatePropagation 的区别"></a>event.stopPropagation()与 event.stopImmediatePropagation 的区别</h3><p>event.stopPropagation()可以阻止事件冒泡到父元素，但不阻止其他事件处理程序的执行。而 event.stopImmediatePropagation()可以立即阻止事件冒泡并取消同一元素上其他事件处理程序的执行。</p><h3 id="说一下事件循环机制-Event-Loop"><a href="#说一下事件循环机制-Event-Loop" class="headerlink" title="说一下事件循环机制 Event Loop"></a>说一下事件循环机制 Event Loop</h3><p>事件循环（Event Loop）是 JavaScript 运行时环境中的一个核心概念，它负责协调异步操作和同步代码的执行。JavaScript 是单线程的，这意味着它一次只能执行一个任务。事件循环使 JavaScript 能够在执行同步代码的同时，处理异步操作（如定时器、用户交互和网络请求）的回调。</p><p>事件循环的工作原理大致如下：</p><ol><li>首先，JavaScript 引擎执行全局同步代码（例如来自<code>&lt;script&gt;</code>标签或 Node.js 文件的代码）。</li><li>当遇到异步操作（如 <code>setTimeout</code>、<code>setInterval</code>、<code>Promise</code>、<code>fetch</code> 等），它们的回调函数会被放入相应的任务队列中（微任务队列或宏任务队列）。</li><li>同步代码执行完成后，事件循环开始检查微任务队列。如果队列中有任务，事件循环将依次执行它们，直到队列为空。</li><li>接下来，事件循环检查宏任务队列。如果队列中有任务，事件循环将执行第一个任务，然后返回到微任务队列，检查是否有新的微任务需要执行。</li><li>事件循环在微任务队列和宏任务队列之间循环，依次执行队列中的任务。当两个队列都为空时，事件循环将等待新的任务（如用户交互或网络请求回调）。</li><li>当新任务出现时，事件循环将其添加到相应的队列中，并继续循环执行任务。</li></ol><p>事件循环的目标是在处理同步代码和异步回调之间保持平衡，确保 JavaScript 代码的执行效率和响应能力。通过这种方式，事件循环允许 JavaScript 在单线程环境中有效地处理并发操作。</p><h3 id="esm-和-commonjs-的区别"><a href="#esm-和-commonjs-的区别" class="headerlink" title="esm 和 commonjs 的区别"></a>esm 和 commonjs 的区别</h3><p>ESM（ECMAScript Modules）和 CommonJS 是 JavaScript 中两种不同的模块系统。它们都允许将代码拆分成可重用的模块，并在需要时导入这些模块。尽管它们都实现了相似的功能，但它们之间存在一些关键差异：</p><ol><li><p>语法：ESM 和 CommonJS 使用不同的语法来导入和导出模块。</p><ul><li>ESM 使用 <code>import</code> 和 <code>export</code> 关键字</li><li>CommonJS 使用 <code>require</code> 和 <code>module.exports</code>关键字</li></ul></li><li><p>运行时加载与静态加载：</p><ul><li>CommonJS 是<strong>运行时加载</strong>，这意味着模块在运行时解析和加载。因此，在运行时可以动态修改模块和依赖关系。</li><li>ESM 是<strong>静态加载</strong>，这意味着模块在编译时解析和加载。这允许更好的优化，如代码消除和更快的加载速度，但不允许在运行时动态修改模块。</li></ul></li><li><p>作用域：ESM 和 CommonJS 在处理变量作用域方面有所不同。</p><ul><li>ESM 使用<strong>模块作用域</strong>，每个模块具有自己的顶级作用域。在模块内声明的变量不会污染全局作用域。</li><li>CommonJS 使用<strong>文件作用域</strong>，但与 ESM 不同，CommonJS 模块可以通过 <code>global</code> 对象访问全局作用域。</li></ul></li><li><p>循环依赖：ESM 和 CommonJS 处理循环依赖的方式不同。</p><ul><li>ESM 可以更好地处理循环依赖，因为模块是静态加载的。在循环依赖中，导入的值可能是不完整的，但不会导致错误。</li><li>CommonJS 在处理循环依赖时可能会遇到问题，因为模块是运行时加载的。这可能导致在循环依赖中的模块中获得一个不完整的对象。</li></ul></li><li><p>兼容性和使用场景：</p><ul><li>CommonJS 主要用于 Node.js 环境，因为它是 Node.js 的原生模块系统。虽然现代 Node.js 版本也支持 ESM，但很多旧的 Node.js 代码仍使用 CommonJS。然而，许多新的 Node.js 项目逐渐采用 ESM。</li><li>ESM 通常用于现代 Web 开发，因为大多数现代浏览器原生支持 ESM。在使用构建工具（如 Webpack、Rollup 或 Parcel）时，ESM 也提供了更好的优化和打包能力。</li></ul></li><li><p>实时绑定与值拷贝：</p><ul><li>ESM 使用<strong>实时绑定</strong>，当导入的值发生更改时，导入模块的值也会跟着更改。这意味着导入的值始终保持最新。</li><li>CommonJS 使用<strong>值拷贝</strong>，当模块被导入时，值被复制到导入模块。这意味着在导入模块中，值的更改不会反映到原始模块，导入的值在导入时是固定的。</li></ul></li><li><p>导出值：</p><ul><li>ESM 导出值是<strong>映射关系</strong>，<strong>可读，不可修改</strong>，但可通过导出的函数修改导出的值。</li><li>CoomonJS 导出<strong>值的拷贝</strong>，<strong>可以修改导出的值</strong>。</li></ul></li><li><p>export 使用：</p><ul><li>ESM export 和 export default 支持一起使用。</li><li>CoomonJS module.exports 和 exports 不支持一起使用，会被覆盖。</li></ul></li></ol><p>总结一下，ESM 和 CommonJS 的主要区别在于它们的语法、加载机制、作用域、循环依赖处理、兼容性和使用场景以及实时绑定与值拷贝。尽管它们在某些方面有所不同，它们都是为了解决 JavaScript 模块化编程的问题。</p><h3 id="解释下-JavaScript-栈内存和堆内存？"><a href="#解释下-JavaScript-栈内存和堆内存？" class="headerlink" title="解释下 JavaScript 栈内存和堆内存？"></a>解释下 JavaScript 栈内存和堆内存？</h3><p>在 JavaScript 中，栈内存（Stack Memory）和堆内存（Heap Memory）扮演着不同的角色，它们分别负责存储不同类型的数据。以下是它们在 JavaScript 中的简要说明：</p><ol><li>栈内存（Stack Memory）：<ul><li>栈内存主要用于存储基本类型（原始类型）的值，如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code> 和 <code>undefined</code>。这些类型的值通常较小且固定大小。</li><li>栈内存还负责存储函数调用的执行上下文、局部变量和临时数据。</li><li>栈内存遵循后进先出（LIFO）的原则进行分配和释放空间。当函数被调用时，函数的执行上下文、局部变量和相关信息会被压入栈中；当函数返回时，这些数据会从栈中弹出。</li><li>栈内存的分配和回收速度较快，因为内存管理由 JavaScript 引擎自动完成。</li><li>由于栈内存有限，如果递归调用过深或者分配大量的局部变量，可能导致栈溢出。</li></ul></li><li>堆内存（Heap Memory）：<ul><li>堆内存主要用于存储引用类型的值，如对象（<code>object</code>）、数组（<code>array</code>）和函数（<code>function</code>）。这些类型的值通常较大，大小不固定。</li><li>JavaScript 引擎使用垃圾回收机制自动管理堆内存中的对象。当对象不再被引用时，它们会被标记为垃圾，并在下一次垃圾回收时释放内存。</li><li>与栈内存相比，堆内存分配和回收速度较慢，因为需要管理更复杂的数据结构和垃圾回收机制。</li><li>堆内存可以动态分配，因此可以存储更多数据。</li><li>如果没有正确处理引用关系，可能导致内存泄漏。</li></ul></li></ol><p>总结一下，在 JavaScript 中，栈内存用于存储基本类型的值、函数调用的执行上下文和局部变量，堆内存用于存储引用类型的值。理解栈内存和堆内存的差异有助于编写高效且内存友好的 JavaScript 程序。</p><h3 id="箭头函数与普通函数区别？"><a href="#箭头函数与普通函数区别？" class="headerlink" title="箭头函数与普通函数区别？"></a>箭头函数与普通函数区别？</h3><p>箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、<code>this</code> 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：</p><ol><li><code>this</code> 关键字绑定：<ul><li>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</li><li>普通函数有自己的 <code>this</code>，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），<code>this</code> 的值可能会有所不同。</li></ul></li><li>arguments 对象：<ul><li>箭头函数没有自己的 <code>arguments</code> 对象。它们可以访问包围它们的普通函数的 <code>arguments</code> 对象。</li><li>普通函数有自己的 <code>arguments</code> 对象，这是一个类数组对象，包含了传递给函数的参数。</li></ul></li><li>构造函数行为：<ul><li>箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 关键字调用。它们也没有 <code>prototype</code> 属性。</li><li>普通函数可以作为构造函数使用，通过 <code>new</code> 关键字创建新的对象实例。</li></ul></li><li>原型链：<ul><li>由于箭头函数没有 <code>prototype</code> 属性，它们不能作为其他对象的原型。</li><li>普通函数有 <code>prototype</code> 属性，可以作为其他对象的原型。</li></ul></li><li>生成器：<ul><li>箭头函数不能使用<code>yield</code>关键字。</li><li>普通函数可以使用<code>yield</code>关键字变成生成器函数。</li></ul></li></ol><h3 id="箭头函数的-this-是声明时确定还是调用时确定？"><a href="#箭头函数的-this-是声明时确定还是调用时确定？" class="headerlink" title="箭头函数的 this 是声明时确定还是调用时确定？"></a>箭头函数的 this 是声明时确定还是调用时确定？</h3><p>箭头函数的 <code>this</code> 是根据其被声明的位置来确定的，而不是它被调用的位置。这个特性称为”词法作用域”或者”静态作用域”。箭头函数不会创建自己的 <code>this</code>，它会从自己的作用域链上一层继承 <code>this</code>。</p><h3 id="isNaN-与-Number-isNaN-的区别"><a href="#isNaN-与-Number-isNaN-的区别" class="headerlink" title="isNaN 与 Number.isNaN 的区别"></a>isNaN 与 Number.isNaN 的区别</h3><p>isNaN 函数用于检查一个值是否是 NaN，它会将传入的参数先转换为数字类型再进行判断。如果传入的参数无法转换为数字类型，则会返回 true。</p><p>而 Number.isNaN 用于检查一个值是否为 NaN，但它不会将参数转换为数字类型，只有在参数本身就是 NaN 时才返回 true。否则，返回 false。</p><h3 id="谈谈你对-this-的理解"><a href="#谈谈你对-this-的理解" class="headerlink" title="谈谈你对 this 的理解"></a>谈谈你对 this 的理解</h3><p>在 JavaScript 中，<code>this</code> 是一个特殊的关键字，它在函数调用时动态地引用了一个对象。<code>this</code> 的值取决于函数的调用方式，不同的调用方式会导致 <code>this</code> 指向不同的对象。以下是一些关于 <code>this</code> 的不同用法和场景：</p><ol><li><p>全局上下文：</p><p>当在全局作用域中使用 <code>this</code> 时，它指向全局对象。在浏览器环境中，全局对象是 <code>window</code>；在 Node.js 环境中，全局对象是 <code>global</code>。</p></li><li><p>函数调用：</p><p>当在函数内部使用 <code>this</code> 且函数作为普通函数调用时（非对象方法调用），<code>this</code> 通常指向全局对象。但在严格模式下（使用 <code>&quot;use strict&quot;</code>），<code>this</code> 会被设置为 <code>undefined</code>。</p></li><li><p>对象方法调用：</p><p>当在对象的方法内部使用 <code>this</code> 时，<code>this</code> 指向调用该方法的对象。这也适用于原型链中的方法。</p></li><li><p>构造函数调用：</p><p>当在构造函数内部使用 <code>this</code> 且使用 <code>new</code> 关键字调用构造函数时，<code>this</code> 指向新创建的对象实例。</p></li><li><p>显式绑定：</p><p>使用 <code>call</code>、<code>apply</code> 或 <code>bind</code> 方法调用函数时，可以显式地将 <code>this</code> 绑定到一个指定的对象。</p></li><li><p>箭头函数：</p><p>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</p></li></ol><p>总之，<code>this</code> 是 JavaScript 中一个动态上下文的关键字，它的值取决于函数调用的方式。</p><h3 id="谈谈你对严格模式的理解"><a href="#谈谈你对严格模式的理解" class="headerlink" title="谈谈你对严格模式的理解"></a>谈谈你对严格模式的理解</h3><p>在 JavaScript 中，严格模式（strict mode）和非严格模式（sloppy mode）主要有以下几个区别：</p><ol><li>变量声明： 在严格模式下，必须明确地声明变量（使用<code>let</code>、<code>const</code>或<code>var</code>关键字）。否则，将会抛出一个引用错误（ReferenceError）。在非严格模式下，如果没有声明变量，JavaScript 会自动将其声明为全局变量，这可能会导致意外的全局污染。</li><li>this 指针： 在严格模式下，全局作用域中的<code>this</code>值为<code>undefined</code>。在非严格模式下，全局作用域中的<code>this</code>值为全局对象（浏览器环境中为<code>window</code>对象，Node.js 环境中为<code>global</code>对象）。此外，在严格模式下，不允许使用<code>call</code>、<code>apply</code>或<code>bind</code>将<code>this</code>值设置为<code>null</code>或<code>undefined</code>。</li><li>禁止使用未来保留字： 严格模式中，不能将一些未来保留字（如<code>implements</code>、<code>interface</code>、<code>let</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>static</code>和<code>yield</code>）用作变量名或函数名。</li><li>禁止使用八进制字面量： 在严格模式下，不允许使用八进制字面量（如<code>0123</code>）。非严格模式下，八进制字面量是允许的。</li><li>禁止删除变量、函数和函数参数： 严格模式中，使用<code>delete</code>操作符删除变量、函数和函数参数会引发语法错误（SyntaxError）。在非严格模式下，这样的操作是允许的，但实际上不会删除这些对象。</li><li>限制函数参数的重复声明： 在严格模式下，如果一个函数具有多个相同名称的参数，将会抛出一个语法错误。非严格模式下允许这种重复声明，但只有最后一个参数值会生效。</li><li>错误处理： 严格模式相较于非严格模式，更严格地处理某些类型的错误。例如，当试图修改只读属性、给不可扩展的对象添加属性或删除不可配置的属性时，严格模式会抛出类型错误（TypeError），而非严格模式下则会静默失败。</li></ol><p>要启用严格模式，可以在脚本或函数开头添加<code>&quot;use strict&quot;;</code>指令。这将对整个脚本或函数体中的代码启用严格模式。推荐使用严格模式编写代码，因为它可以帮助发现潜在的错误并避免一些不良的编程实践。</p><h3 id="谈谈你对-Promise-的理解"><a href="#谈谈你对-Promise-的理解" class="headerlink" title="谈谈你对 Promise 的理解"></a>谈谈你对 Promise 的理解</h3><p>Promise 是一种在 JavaScript 中用于处理异步操作的编程模式。它表示一个尚未完成但预计在未来某个时刻完成的操作的结果。Promise 允许我们以更简洁、易读的方式处理异步操作，避免了传统的回调地狱（callback hell）问题。</p><p>Promise 有三种状态：</p><ol><li>pending（待定）：初始状态，既不是 fulfilled，也不是 rejected。</li><li>fulfilled（已实现）：表示异步操作已成功完成。</li><li>rejected（已拒绝）：表示异步操作失败。</li></ol><p>Promise 具有以下特点：</p><ol><li>Promise 对象是不可变的，一旦创建，其状态就不能再被改变。</li><li>Promise 状态只能从 pending 变为 fulfilled 或 rejected，不能逆向改变，且只能改变一次。</li><li>Promise 允许我们将成功和失败的处理函数分开，增加代码的可读性。</li></ol><p>缺点：</p><ol><li>无法取消：一旦创建了 Promise，就无法取消它。这可能导致在某些情况下，不再需要结果的异步操作仍然在执行。</li><li>总是异步：Promise 的回调总是异步执行，即使操作已经完成。这可能会导致一些意外的行为，特别是在执行顺序敏感的情况下。</li><li>调试困难：由于 Promise 的链式调用和异步特性，调试 Promise 可能比调试同步代码更具挑战性。错误堆栈可能不够清晰，难以确定问题出在哪里。</li></ol><p>Promise 基本用法包括：</p><ol><li>创建 Promise 对象：通过<code>new Promise(executor)</code>创建一个 Promise 对象，其中 executor 是一个执行器函数，接受两个参数：resolve 和 reject。成功时调用 resolve 函数并传递结果，失败时调用 reject 函数并传递原因。</li><li>链式调用：通过<code>.then()</code>方法处理 fulfilled 状态，接受一个回调函数作为参数，当 Promise 状态变为 fulfilled 时调用。<code>.catch()</code>方法处理 rejected 状态，接受一个回调函数作为参数，当 Promise 状态变为 rejected 时调用。</li><li>Promise.all：接受一个 Promise 数组作为参数，当所有 Promise 都变为 fulfilled 状态时返回一个新的 Promise，其值为所有 Promise 结果的数组。如果有任意一个 Promise 变为 rejected 状态，则返回的 Promise 也变为 rejected，且返回原因是第一个 rejected 的 Promise 的原因。</li><li>Promise.race：接受一个 Promise 数组作为参数，返回一个新的 Promise，其状态和结果与第一个完成（无论是 fulfilled 还是 rejected）的 Promise 相同。</li></ol><p>通过使用 Promise，我们可以更有效地处理异步操作，降低代码复杂性，提高可维护性。在现代 JavaScript 开发中，Promise 已成为处理异步操作的重要基石。</p><h3 id="为什么-0-1-0-2-不等于-0-3"><a href="#为什么-0-1-0-2-不等于-0-3" class="headerlink" title="为什么 0.1+0.2 不等于 0.3"></a>为什么 0.1+0.2 不等于 0.3</h3><p>在 JavaScript（以及许多其他编程语言）中，0.1 + 0.2 不等于 0.3 的原因是浮点数精度问题。JavaScript 使用 IEEE 754 标准中规定的双精度浮点数（double-precision floating point）来表示数字。这种表示方法在大多数情况下都很有效，但有时会导致精度损失。</p><p>双精度浮点数只有有限的位数（64 位）来表示数字，其中 1 位表示符号位，11 位表示指数，以及 52 位表示尾数。当尝试表示某些数字（特别是十进制小数）时，它们的二进制表示可能是无限循环的，因此需要截断以适应有限的位数。这可能导致浮点数的近似值与实际值之间存在微小差异。</p><p>在本例中，0.1 和 0.2 的二进制表示都是无限循环的，需要截断。当它们被截断并以双精度浮点数存储时，这两个数字的实际值与理论值略有不同。因此，当执行 0.1 + 0.2 时，结果也会有微小误差，与 0.3 的理论值不完全相等。</p><p>为了解决这个问题，可以将结果四舍五入到所需的精度。例如，如果要比较两个数字是否相等，可以将它们四舍五入到一个合理的精度，然后再进行比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">areNumbersAlmostEqual</span>(<span class="params">num1, num2, epsilon = <span class="number">1e-10</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(num1 - num2) &lt; epsilon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">areNumbersAlmostEqual</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用一个称为”epsilon”的小数值来表示可接受的误差范围。我们计算两个数字之差的绝对值，如果它小于 epsilon，我们认为这两个数字几乎相等。在实践中，需要根据具体问题选择合适的 epsilon 值。</p><h3 id="Map-与-WeakMap-的区别"><a href="#Map-与-WeakMap-的区别" class="headerlink" title="Map 与 WeakMap 的区别"></a>Map 与 WeakMap 的区别</h3><p>Map 和 WeakMap 在 JavaScript 中都提供了键值对的存储，但它们的工作方式和底层实现有一些重要的区别。</p><ol><li><p>键的引用：在 Map 中，键的引用是强引用，也就是说只要 Map 存在，那么它的键值对就会保留在内存中，不会被垃圾收集器回收。而在 WeakMap 中，键的引用是弱引用，也就是说如果没有其他地方引用该键，那么该键就会被垃圾收集器回收，不论该 WeakMap 是否还存在。</p></li><li><p>键的类型：在 Map 中，键可以是任何类型，包括原始类型（比如字符串、数字、布尔值）和对象类型。而在 WeakMap 中，键必须是对象。</p></li><li><p>迭代器和清除方法：Map 具有诸如 <code>size</code>、<code>clear</code>、<code>keys</code>、<code>values</code> 和 <code>entries</code> 等方法，允许开发者获取大小，清除所有键值对，或者迭代所有的键或值。然而，由于 WeakMap 的键是弱引用，为了防止在垃圾回收过程中可能引发的并发问题，WeakMap 没有这些方法。</p></li><li><p>底层实现：JavaScript 本身是高级语言，其具体实现取决于底层的 JavaScript 引擎，如 V8 或 SpiderMonkey。在一般情况下，Map 可以使用简单的哈希表来实现。对于 WeakMap，由于其键是弱引用，因此在内存管理方面需要更加复杂的处理。这些处理通常在引擎级别完成，而不是在 JavaScript 代码级别。</p></li></ol><p>以上这些区别使得 Map 和 WeakMap 有各自适用的情况。比如，当你需要存储的键值对在某个时间点之后不再需要时，使用 WeakMap 可以防止内存泄漏。而当你需要完全控制何时删除键值对时，使用 Map 更为合适。</p><hr /><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="headerlink" title="type 和 interface 的区别"></a>type 和 interface 的区别</h3><ol><li><p>声明方式：</p><ul><li><p><code>type</code> 是使用 <code>type</code> 关键字定义类型别名，可以为基本类型、联合类型、交叉类型等复杂类型提供一个名称。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>interface</code> 是使用 <code>interface</code> 关键字定义接口，主要用于描述对象的结构。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>扩展：</p><ul><li><p><code>type</code> 可以使用交叉类型 <code>&amp;</code> 进行扩展。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="title class_">Name</span> &amp; <span class="title class_">Age</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>interface</code> 可以使用 <code>extends</code> 关键字进行扩展。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Age</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Name</span>, <span class="title class_">Age</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>合并声明：</p><ul><li><code>type</code> 不能进行合并声明，同名的 <code>type</code> 会导致错误。</li><li><code>interface</code> 可以进行合并声明，同名的 <code>interface</code> 会自动合并，合并后的接口包含所有声明的属性。</li></ul></li><li><p>类型映射：</p><ul><li><p><code>type</code> 可以使用映射类型创建新类型，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPoint</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Point</span>&gt;;</span><br></pre></td></tr></table></figure></li><li><p><code>interface</code> 不能直接使用映射类型，但可以通过交叉类型和映射类型创建新接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPoint</span> <span class="keyword">extends</span> <span class="title class_">Readonly</span>&lt;<span class="title class_">Point</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他类型表示：</p><ul><li><p><code>type</code> 支持联合类型、元组类型、映射类型等更多类型表示。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coordinate</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span> | <span class="string">&quot;rectangle&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><code>interface</code> 主要用于描述对象的结构，不支持其他类型表示。</li></ul><p>总结一下，<code>type</code> 和 <code>interface</code> 在 TypeScript 中都可以用于定义复杂类型，但它们在声明方式、扩展、合并声明和类型表示等方面有所不同。<code>type</code> 更灵活，支持更多类型表示，而 <code>interface</code> 更适用于描述对象结构，可以进行合并声明。</p><h3 id="object-类型和-Object-类型的区别"><a href="#object-类型和-Object-类型的区别" class="headerlink" title="object 类型和 Object 类型的区别"></a>object 类型和 Object 类型的区别</h3><p>在 TypeScript 中，<code>object</code>类型是指非原始类型，即除了 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>symbol</code>、<code>null</code> 和 <code>undefined</code> 之外的类型。而 <code>Object</code> 类型是 JavaScript 中的全局对象类型，包含了一些内置方法和属性（如 <code>toString()</code> 和 <code>valueOf()</code>），可以进行类型转换。</p><p>一个实例化的 JavaScript 对象的类型是 <code>Object</code>，而一个非原始类型的值的类型是 <code>object</code>。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="built_in">object</span> = &#123;&#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">Object</span> = &#123;&#125;; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num1</span>: <span class="built_in">object</span> = <span class="number">42</span>; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num2</span>: <span class="title class_">Object</span> = <span class="number">42</span>; <span class="comment">// OK, 但不推荐，因为 42 为原始类型</span></span><br></pre></td></tr></table></figure><p>总之，<code>object</code>表示任何非原始类型的值，而 <code>Object</code>表示 JavaScript 的全局对象类型。</p><h3 id="谈谈你对-Enum-枚举类型的理解"><a href="#谈谈你对-Enum-枚举类型的理解" class="headerlink" title="谈谈你对 Enum 枚举类型的理解"></a>谈谈你对 Enum 枚举类型的理解</h3><p>在 TypeScript 中，枚举（Enum）是一种特殊的数据类型，它允许为一组相关的值赋予有意义的名字。枚举类型可以帮助提高代码的可读性和可维护性。以下是关于 TypeScript 中枚举类型的一些关键点：</p><ol><li><p>声明枚举：</p><p>使用 <code>enum</code> 关键字定义一个枚举类型。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用枚举：</p><p>可以通过枚举类型名字访问枚举值。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br></pre></td></tr></table></figure></li><li><p>数字枚举：</p><p>默认情况下，枚举值是从 0 开始自增的数字。你也可以为某个成员显式指定一个数字，后续成员将从该数字开始自增。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Down</span>, <span class="comment">// 2</span></span><br><span class="line">  <span class="title class_">Left</span>, <span class="comment">// 3</span></span><br><span class="line">  <span class="title class_">Right</span>, <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串枚举：</p><p>除了数字枚举，TypeScript 还支持字符串枚举。在字符串枚举中，每个成员都需要显式地赋予一个字符串值。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">HttpMethod</span> &#123;</span><br><span class="line">  <span class="variable constant_">GET</span> = <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="variable constant_">POST</span> = <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="variable constant_">PUT</span> = <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">  <span class="variable constant_">DELETE</span> = <span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反向映射：</p><p>数字枚举具有反向映射的特性，这意味着可以通过枚举值得到枚举名。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OK</span> = <span class="number">200</span>,</span><br><span class="line">  <span class="title class_">NotFound</span> = <span class="number">404</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>[<span class="number">200</span>]); <span class="comment">// 输出 &quot;OK&quot;</span></span><br></pre></td></tr></table></figure><p>字符串枚举没有反向映射特性。</p></li><li><p>常量枚举：</p><p>使用 <code>const</code> 关键字声明常量枚举。常量枚举在编译时会被计算，<strong>不会在编译后的代码中生成实际的枚举对象</strong>，可以减少生成的代码体积。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">  <span class="title class_">Sunday</span>,</span><br><span class="line">  <span class="title class_">Monday</span>,</span><br><span class="line">  <span class="title class_">Tuesday</span>,</span><br><span class="line">  <span class="title class_">Wednesday</span>,</span><br><span class="line">  <span class="title class_">Thursday</span>,</span><br><span class="line">  <span class="title class_">Friday</span>,</span><br><span class="line">  <span class="title class_">Saturday</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总之，TypeScript 中的枚举类型提供了一种为一组相关值赋予有意义名字的方法，增强了代码的可读性和可维护性。枚举类型包括数字枚举、字符串枚举和常量枚举，可以根据不同的需求选择使用。</p><h3 id="谈谈你对泛型的理解"><a href="#谈谈你对泛型的理解" class="headerlink" title="谈谈你对泛型的理解"></a>谈谈你对泛型的理解</h3><p>泛型是一种在定义函数、接口或类时不预先指定具体的类型，而是在使用时指定的一种特性。在 TypeScript 中，泛型被广泛应用以增加代码的重用性和可维护性。</p><p>以下是我对 TypeScript 中泛型的理解：</p><ol><li><strong>类型安全</strong>：泛型可以帮助我们在编译时检查类型信息。这种特性可以有效地减少运行时的错误，因为我们可以在代码编写阶段就捕获潜在的类型错误。</li><li><strong>代码重用</strong>：我们可以编写一个适用于多种类型的函数，而不是针对每一种类型都写一个函数。泛型可以提高代码的复用性，减少不必要的代码重复。</li><li><strong>灵活性</strong>：泛型提供了高度的灵活性，我们可以在编写函数或类时不必预先指定具体的类型，而是在使用这些函数或类时指定类型。这样就使得我们的函数或类可以适应更广泛的情况。</li><li><strong>类型推断</strong>：在许多情况下，TypeScript 编译器可以自动推断出泛型的类型，这大大减少了我们编写和阅读代码时的工作量。</li></ol><h3 id="any-和-unknown-的区别？"><a href="#any-和-unknown-的区别？" class="headerlink" title="any 和 unknown 的区别？"></a>any 和 unknown 的区别？</h3><p>在 TypeScript 中，<code>any</code> 和 <code>unknown</code> 都可以代表任何类型的值。但是它们在类型安全性和如何使用上有显著的差异。</p><ol><li><p><strong>类型检查</strong>：</p><ul><li><code>any</code>：当你将一个值标记为 <code>any</code> 类型时，TypeScript 将不会对这个值进行任何类型检查。这意味着，你可以在该值上进行任何操作，而不会得到编译时的错误。</li><li><code>unknown</code>：它表示一个未知的值的类型。你不能直接对 <code>unknown</code> 类型的值进行操作，也不能将它分配给除 <code>unknown</code> 和 <code>any</code> 类型之外的其他类型的变量，除非你先进行类型检查或类型断言。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><code>any</code>：使用 <code>any</code> 会绕过 TypeScript 的类型系统，可能导致运行时错误。它提供了最大的灵活性，但也损失了类型安全性。</li><li><code>unknown</code>：要操作 <code>unknown</code> 类型的值，你必须先确保这个值是你期望的类型。这迫使你更加谨慎地处理这些值，增加了类型安全性。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><code>any</code>：当你确实不关心类型或从老的 JavaScript 代码迁移到 TypeScript 时，可能会使用 <code>any</code> 作为临时解决方案。</li><li><code>unknown</code>：当你想表示一个可以是任何类型的值，但仍然想保持类型安全性时，可以使用 <code>unknown</code>。</li></ul></li></ol><p><strong>示例</strong>：</p><p>考虑以下代码片段：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = a; <span class="comment">// 这里不会有错误，因为 a 是 any 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: unknown = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span> = x; <span class="comment">// 错误！不能将类型 &quot;unknown&quot; 分配给类型 &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">z</span>: <span class="built_in">number</span> = x; <span class="comment">// 在这里没问题，因为我们已经检查了 x 的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<code>unknown</code> 提供了一种在不完全确定类型时保持类型安全性的方式，而 <code>any</code> 则完全关闭了 TypeScript 的类型检查。在可能的情况下，推荐使用 <code>unknown</code> 而不是 <code>any</code>，以保持代码的类型安全性。</p><h3 id="谈谈你对词法作用域的理解"><a href="#谈谈你对词法作用域的理解" class="headerlink" title="谈谈你对词法作用域的理解"></a>谈谈你对词法作用域的理解</h3><p>词法作用域（有时也称为静态作用域）是在编程中用于确定变量可见性和生命周期的一种作用域规则。以下是对词法作用域的深入理解：</p><ol><li><p><strong>定义时确定</strong>：词法作用域是在代码的编写阶段定义的，而不是在运行时。换句话说，作用域是由代码的物理结构决定的，而不是它是如何被调用的。</p></li><li><p><strong>嵌套结构</strong>：在词法作用域中，我们可以在一个函数内部定义另一个函数，从而形成一个嵌套的作用域链。内部函数可以访问其外部函数的变量和参数，但外部函数不能访问其内部函数的变量。</p></li><li><p><strong>全局与局部</strong>：</p><ul><li><strong>全局作用域</strong>：定义在所有函数外部的变量拥有全局作用域。全局变量可以在代码的任何地方访问。</li><li><strong>局部作用域</strong>：在函数内部定义的变量拥有局部作用域。它们只能在函数内部被访问。</li></ul></li><li><p><strong>作用域链</strong>：当在一个作用域内查找一个变量时，如果当前作用域没有定义该变量，查找会继续到包含（外部）作用域，直到找到该变量或达到全局作用域。这种查找链被称为作用域链。</p></li><li><p><strong>与动态作用域的区别</strong>：词法作用域与动态作用域是两种不同的作用域规则。在动态作用域中，作用域是由函数如何被调用决定的，而不是代码的结构。JavaScript 使用的是词法作用域，而不是动态作用域。</p></li><li><p><strong>闭包</strong>：闭包是词法作用域和函数的强大组合。当函数能够记住并访问其词法作用域，即使当该函数在其原始词法作用域之外执行时，我们就称之为闭包。</p></li><li><p><strong>阻止变量提升</strong>：在 JavaScript 中，<code>let</code> 和 <code>const</code> 关键字（ES6 及之后的版本引入）为变量定义提供了块级作用域，这与传统的 <code>var</code> 关键字有所不同。</p></li><li><p><strong>性能考虑</strong>：由于词法作用域是在编译时确定的，编译器可以对代码进行优化。知道哪些变量在哪里被访问，以及它们如何被访问，可以帮助编译器提高代码的执行效率。</p></li></ol><hr /><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h3 id="require-一个模块时的查找过程"><a href="#require-一个模块时的查找过程" class="headerlink" title="require 一个模块时的查找过程"></a>require 一个模块时的查找过程</h3><p>当使用 <code>require</code> 函数加载一个模块时，Node.js 遵循一定的查找和解析过程。以下是 <code>require</code> 函数的主要查找过程：</p><ol><li><p>内置模块：</p><p>首先，Node.js 检查请求的模块是否为内置模块（如 <code>http</code>, <code>fs</code>, <code>path</code> 等）。如果是内置模块，直接返回内置模块的导出对象，查找过程结束。</p></li><li><p>文件和文件夹模块：</p><p>如果请求的模块不是内置模块，Node.js 将尝试将其解析为文件或文件夹模块。按照以下顺序查找：</p><ul><li>检查是否存在带 <code>.js</code>、<code>.json</code>、<code>.node</code> 扩展名的文件。如果找到了匹配的文件，加载并执行该文件，然后返回其导出对象。</li><li>如果没有找到匹配的文件，检查是否存在同名文件夹。如果存在同名文件夹，Node.js 将查看该文件夹内的 <code>package.json</code> 文件。如果 <code>package.json</code> 文件中定义了 <code>main</code> 字段，Node.js 将尝试加载该字段指定的文件。如果没有 <code>main</code> 字段或无法加载指定的文件，Node.js 将尝试加载文件夹内的 <code>index.js</code>、<code>index.json</code> 或 <code>index.node</code> 文件。</li></ul></li><li><p>节点模块：</p><p>如果请求的模块既不是内置模块，也不是文件或文件夹模块，Node.js 将尝试将其解析为节点模块。Node.js 会按照一定的顺序在 <code>node_modules</code> 文件夹中查找模块：</p><ul><li>从当前文件所在的目录开始，查找 <code>node_modules</code> 文件夹。如果找到了匹配的模块，加载并执行该模块，然后返回其导出对象。</li><li>如果在当前目录的 <code>node_modules</code> 文件夹中未找到匹配的模块，Node.js 将继续向上级目录查找，直到找到匹配的模块或到达文件系统的根目录。</li></ul></li><li><p>查找失败：</p><p>如果在以上步骤中未找到匹配的模块，Node.js 将抛出一个 <code>MODULE_NOT_FOUND</code> 错误。</p></li></ol><p>总结一下，当使用 <code>require</code> 函数加载一个模块时，Node.js 遵循一定的查找和解析过程。首先检查内置模块，然后尝试解析为文件或文件夹模块，最后尝试解析为节点模块。如果在这些步骤中未找到匹配的模块，Node.js 将抛出一个错误。</p><h3 id="谈谈你对-Node-中间件的理解"><a href="#谈谈你对-Node-中间件的理解" class="headerlink" title="谈谈你对 Node 中间件的理解"></a>谈谈你对 Node 中间件的理解</h3><p>中间件（Middleware）是一种重要的设计模式。它们用于处理请求和响应的过程中的各种任务，以便将逻辑分离到不同的组件中，提高代码的可读性和可维护性。以下是关于 Node.js 中间件的一些关键点：</p><ol><li><p>功能：中间件的主要功能是在请求和响应的处理过程中执行特定任务。例如，验证用户身份、解析请求体、记录访问日志、处理跨域请求等。</p></li><li><p>顺序执行：中间件按照添加顺序依次执行。当一个中间件处理完毕后，它可以选择将控制权传递给下一个中间件，或者直接结束请求-响应周期。</p></li><li><p>基本结构：在 Express 中，中间件通常是一个函数，接收三个参数：<code>req</code>（请求对象）、<code>res</code>（响应对象）和 <code>next</code>（下一个中间件函数）。在 Koa 中，中间件是一个异步函数，接收一个参数：<code>ctx</code>（上下文对象），并返回一个 Promise。</p><ul><li><p>Express 中间件示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logger</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Koa 中间件示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logger</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加中间件：在 Express 和 Koa 中，都有一种方法来将中间件添加到请求处理管道中。</p><ul><li><p>Express 示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(logger);</span><br></pre></td></tr></table></figure></li><li><p>Koa 示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(logger);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误处理：中间件还可以用于处理错误。在 Express 中，错误处理中间件接收四个参数：<code>err</code>（错误对象）、<code>req</code>（请求对象）、<code>res</code>（响应对象）和 <code>next</code>（下一个中间件函数）。在 Koa 中，错误处理中间件通常在其他中间件的 <code>try</code>&#x2F;<code>catch</code> 块中捕获异常。</p><ul><li><p>Express 错误处理示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">errorHandler</span>(<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&quot;Internal Server Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">app.<span class="title function_">use</span>(errorHandler);</span><br></pre></td></tr></table></figure></li><li><p>Koa 错误处理示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">errorHandler</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">500</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&quot;Internal Server Error&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.<span class="title function_">use</span>(errorHandler);</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>总之，Node.js 中间件是一种设计模式，用于在请求和响应的处理过程中执行特定任务。中间件可以帮助我们将逻辑分离到不同的组件中，提高代码的可读性和可维护性。通过使用中间件，我们可以更方便地组织和管理代码，以实现各种功能，如身份验证、日志记录、错误处理等。</p><p>当创建一个中间件时，需要考虑以下几点：</p><ol><li>职责分离：每个中间件应该只负责一个特定任务。这有助于保持代码的简洁和易于维护。</li><li>代码复用：通过将通用功能封装在中间件中，我们可以在不同的项目和模块中重用这些功能。</li><li>顺序重要：中间件的执行顺序很重要，因为它们之间可能存在依赖关系。例如，一个解析请求体的中间件应该在处理具体业务逻辑的中间件之前执行。</li><li>可配置性：中间件应该具有一定的可配置性，以便根据项目的不同需求进行调整。</li><li>异常处理：确保在中间件中处理可能发生的异常，以便能够优雅地处理错误并向用户返回有用的错误信息。</li></ol><p>通过使用中间件，我们可以创建出更加模块化、可扩展和可维护的 Node.js 应用程序。无论是使用 Express、Koa 还是其他框架，中间件都是 Node.js 开发中一个非常重要的概念。</p><h3 id="npm-run-dev-时发生了什么？"><a href="#npm-run-dev-时发生了什么？" class="headerlink" title="npm run dev 时发生了什么？"></a>npm run dev 时发生了什么？</h3><p><code>npm run dev</code> 是一个在 Node.js 项目中常见的命令，通常用于启动开发环境。这个命令实际上会触发一系列的操作。下面是一个简化的概述：</p><ol><li>首先，当你执行 <code>npm run dev</code> 命令时，npm 会在项目的 <code>package.json</code> 文件中查找名为 <code>dev</code> 的脚本。这个脚本通常是一个包含了如何启动开发服务器或构建工具的命令。</li><li>接下来，npm 会执行 <code>dev</code> 脚本中的命令。这个命令通常会启动一个开发服务器，如 Webpack Dev Server、Express、Next.js 等，这些服务器会监听文件更改，自动重新编译和刷新浏览器。</li><li>在开发服务器启动的过程中，可能会执行一些构建任务，如编译 JavaScript、CSS、HTML 等资源，执行代码检查，以及优化代码等。</li><li>有些项目可能还会启动其他辅助工具，如热模块替换（HMR, Hot Module Replacement）来实现无需刷新页面即可更新局部变化，或者启动一个代理服务器来处理跨域请求等。</li><li>最后，当开发服务器启动完成后，你可以在浏览器中访问项目，并在修改代码后看到实时更新。</li></ol><p>综上，<code>npm run dev</code> 通常是一个用于启动开发环境的命令，它会执行一系列操作来方便开发人员进行实时的代码调试和更新。具体的操作可能因项目和开发工具的不同而有所差异。</p><h3 id="Node-中进程之间是如何通信的"><a href="#Node-中进程之间是如何通信的" class="headerlink" title="Node 中进程之间是如何通信的"></a>Node 中进程之间是如何通信的</h3><p>在 Node.js 中，进程之间可以使用多种方式进行通信。主要的通信方式是使用进程间通信（Inter-process communication, IPC）通道。以下是 Node.js 中实现进程间通信的几种方法：</p><ol><li><p><code>child_process.fork()</code></p><p>使用 <code>child_process.fork()</code> 方法创建的子进程会自动建立一个 IPC 通道，允许父子进程之间通过 <code>send()</code> 方法发送消息，同时监听 <code>message</code> 事件接收消息。例如：</p><p>父进程（parent.js）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> child = <span class="title function_">fork</span>(<span class="string">&quot;./child.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">send</span>(<span class="string">&quot;Hello from parent!&quot;</span>);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received message from child: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子进程（child.js）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received message from parent: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  process.<span class="title function_">send</span>(<span class="string">&quot;Hello from child!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>child_process.spawn()</code></p><p>使用 <code>child_process.spawn()</code> 创建子进程时，可以通过配置 <code>stdio</code> 选项来建立一个 IPC 通道。例如：</p><p>父进程（parent.js）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> child = <span class="title function_">spawn</span>(process.<span class="property">execPath</span>, [<span class="string">&quot;./child.js&quot;</span>], &#123;</span><br><span class="line">  <span class="attr">stdio</span>: [<span class="string">&quot;inherit&quot;</span>, <span class="string">&quot;inherit&quot;</span>, <span class="string">&quot;inherit&quot;</span>, <span class="string">&quot;ipc&quot;</span>],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">send</span>(<span class="string">&quot;Hello from parent!&quot;</span>);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received message from child: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子进程（child.js）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received message from parent: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  process.<span class="title function_">send</span>(<span class="string">&quot;Hello from child!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用第三方库</p><p>除了上述 Node.js 内置的方法外，还可以使用一些第三方库来实现进程间通信，如：<code>node-ipc</code>、<code>zeromq</code> 等。这些库通常提供了更高级的抽象和更强大的功能。</p></li></ol><p>总之，Node.js 中进程间通信主要通过 IPC 通道实现。可以使用 <code>child_process.fork()</code> 或 <code>child_process.spawn()</code> 方法创建具有 IPC 通道的子进程，也可以考虑使用第三方库来实现更高级的通信需求。</p><h3 id="谈谈你对-Stream-的理解"><a href="#谈谈你对-Stream-的理解" class="headerlink" title="谈谈你对 Stream 的理解"></a>谈谈你对 Stream 的理解</h3><p>在 Node.js 中，流（Stream）是一种处理数据的抽象接口，允许开发者按照一定的顺序处理数据。流可以用于读取、写入或转换数据。流的核心思想是将大量数据拆分成小的数据块，一次处理一个数据块，从而避免一次性加载整个数据集导致的内存不足问题。流在 Node.js 中被广泛应用，如文件操作、网络传输等场景。</p><p>流有以下四种类型：</p><ol><li><strong>Readable Stream</strong>：可读流是从某个来源读取数据的流。例如，从文件中读取数据、从 HTTP 响应中读取数据等。可读流会触发 <code>data</code> 事件来传输数据块，当数据读取完成时，会触发 <code>end</code> 事件。</li><li><strong>Writable Stream</strong>：可写流是将数据写入到某个目标的流。例如，向文件中写入数据、向 HTTP 请求中写入数据等。可写流提供了 <code>write()</code> 方法用于写入数据，<code>end()</code> 方法用于表示数据写入完成。</li><li><strong>Duplex Stream</strong>：双工流是可读可写的流，可以同时读取和写入数据。例如，TCP 套接字就是一个双工流，允许在同一时间进行数据的读取和写入。</li><li><strong>Transform Stream</strong>：转换流是一种特殊的双工流，它可以在读写过程中修改或转换数据。例如，压缩或解压数据、加密或解密数据等。</li></ol><p>在 Node.js 中，流是基于事件的，可读流和可写流都继承自 <code>EventEmitter</code> 类。这使得流可以通过事件机制来处理各种情况，如数据到达、数据写入完成、错误发生等。</p><p>流有许多优点，例如：</p><ul><li><strong>内存占用低</strong>：流允许按需处理数据，避免一次性加载整个数据集导致的内存不足问题。</li><li><strong>速度快</strong>：流可以在数据可用时立即开始处理，而无需等待整个数据集加载完成。</li><li><strong>可组合</strong>：流可以通过管道（pipe）组合在一起，实现数据的读取、转换和写入等一系列操作。</li></ul><p>总之，Node.js 中的流是一种处理大量数据的高效方式，具有低内存占用、快速处理和可组合等特点。在文件操作、网络传输等场景中，流被广泛应用。</p><h3 id="谈谈你对-Node-事件循环的理解"><a href="#谈谈你对-Node-事件循环的理解" class="headerlink" title="谈谈你对 Node 事件循环的理解"></a>谈谈你对 Node 事件循环的理解</h3><p>Node.js 事件循环（Event Loop）是其核心运行机制之一，它允许 Node.js 在处理大量并发操作时保持高性能。事件循环是一个程序结构，用于等待、接收并处理事件，例如 I&#x2F;O 操作、计时器和其他异步操作。它的工作原理是在事件队列中持续循环，直到程序终止。下面详细介绍 Node.js 事件循环的关键概念：</p><ol><li>单线程：Node.js 采用单线程模型，这意味着在给定时刻只能执行一个任务。但是，由于它采用非阻塞 I&#x2F;O，因此可以处理大量并发操作。</li><li>非阻塞 I&#x2F;O：Node.js 的 I&#x2F;O 操作是非阻塞的，这意味着执行 I&#x2F;O 时不会等待操作完成，而是继续执行其他任务。当 I&#x2F;O 操作完成时，回调函数将被添加到事件队列以供事件循环处理。</li><li>事件队列：事件队列是一个先进先出（FIFO）的队列，用于存储待处理的事件。事件循环会不断从队列中取出并处理事件。</li><li>事件循环阶段：Node.js 事件循环分为几个阶段，每个阶段负责处理不同类型的任务：<ul><li>定时器阶段：处理 setTimeout 和 setInterval 计时器的回调。</li><li>I&#x2F;O 回调阶段：处理大部分 I&#x2F;O 回调。</li><li>闲置、准备阶段：内部使用，为其他阶段做准备。</li><li>轮询阶段：检查新的 I&#x2F;O 事件并处理。</li><li>检查阶段：处理 setImmediate 的回调。</li><li>关闭事件回调阶段：处理关闭请求，如服务器关闭、socket 断开等。</li></ul></li><li>微任务（Microtasks）：在事件循环的每个阶段之间，Node.js 会处理微任务队列。微任务包括 Promise 的 resolve 和 reject 回调。这意味着微任务会在事件循环的下一个阶段之前执行。</li></ol><p>通过协调这些概念，Node.js 事件循环使得程序能够以高效、可扩展的方式处理大量并发操作。在编写 Node.js 程序时，了解事件循环如何工作以及如何在程序中使用异步模式是非常重要的。</p><h3 id="process-nextTick-callback-、setImmediate-callback-和-setTimeout-callback-0-的区别？"><a href="#process-nextTick-callback-、setImmediate-callback-和-setTimeout-callback-0-的区别？" class="headerlink" title="process.nextTick(callback)、setImmediate(callback)和 setTimeout(callback, 0)的区别？"></a>process.nextTick(callback)、setImmediate(callback)和 setTimeout(callback, 0)的区别？</h3><p><code>process.nextTick(callback)</code>、<code>setImmediate(callback)</code> 和 <code>setTimeout(callback, 0)</code> 都是在 Node.js 中用于异步执行代码的函数，但它们的行为和执行顺序有所不同。</p><ol><li>**<code>process.nextTick(callback)</code>**：此函数将 <code>callback</code> 添加到当前事件循环的”next tick queue”中。这意味着 <code>callback</code> 函数会在当前操作完成后、事件循环的下一轮循环之前立即执行。<code>process.nextTick</code> 具有最高优先级，因此在所有异步任务中最先执行。</li><li>**<code>setImmediate(callback)</code>**：此函数将 <code>callback</code> 添加到事件循环的”check”阶段（即在 I&#x2F;O 回调之后、关闭回调之前）。<code>setImmediate</code> 的执行顺序要低于 <code>process.nextTick</code>，但高于 <code>setTimeout(callback, 0)</code>。<code>setImmediate</code> 主要用于分离计算密集型任务，以允许其他任务在事件循环中执行。</li><li>**<code>setTimeout(callback, 0)</code>**：此函数将 <code>callback</code> 添加到定时器队列，使其在定时器阶段执行。尽管延迟时间设置为 0，但实际的延迟可能会更长，因为事件循环需要处理其他任务。<code>setTimeout(callback, 0)</code> 的执行顺序最低，通常在所有其他异步任务之后执行。</li></ol><p>总结一下，这些函数的执行顺序是：</p><ul><li><code>process.nextTick(callback)</code>：优先级最高，在当前事件循环的下一刻执行。</li><li><code>setImmediate(callback)</code>：在事件循环的 I&#x2F;O 回调之后执行。</li><li><code>setTimeout(callback, 0)</code>：在定时器队列中执行，具有最低的优先级。</li></ul><p>在实践中，你应该根据需要选择适当的函数。例如，如果你希望在事件循环的下一轮循环之前立即执行一个任务，可以使用 <code>process.nextTick</code>；如果你希望在其他任务完成后执行一个任务，可以使用 <code>setImmediate</code> 或 <code>setTimeout</code>。</p><h3 id="child-process-模块中，spawn-、fork-、exec-的区别？"><a href="#child-process-模块中，spawn-、fork-、exec-的区别？" class="headerlink" title="child_process 模块中，spawn()、fork()、exec()的区别？"></a>child_process 模块中，spawn()、fork()、exec()的区别？</h3><p><code>child_process</code> 是 Node.js 的一个内置模块，它允许你在子进程中执行系统命令和运行其他 Node.js 进程。模块中的 <code>spawn()</code>、<code>fork()</code> 和 <code>exec()</code> 函数都可以用于创建子进程，但它们之间存在一些差异：</p><ol><li>**<code>spawn(command[, args][, options])</code>**：<code>spawn</code> 是一个底层函数，用于异步地创建一个新的子进程。它接受一个命令（例如 <code>&#39;ls&#39;</code> 或 <code>&#39;node&#39;</code>）和一个可选的参数数组。<code>spawn</code> 返回一个 <code>ChildProcess</code> 对象，你可以通过该对象的 <code>stdout</code> 和 <code>stderr</code> 流来获取子进程的输出。<code>spawn</code> 适用于需要处理大量数据的长时间运行的进程，因为它不会缓冲输出，而是将数据以流的形式返回。</li><li>**<code>fork(modulePath[, args][, options])</code>**：<code>fork</code> 是一个特殊的 <code>spawn</code>，专门用于创建 Node.js 子进程。它接受一个 Node.js 模块的路径（而不是系统命令）和一个可选的参数数组。与 <code>spawn</code> 类似，<code>fork</code> 返回一个 <code>ChildProcess</code> 对象。<code>fork</code> 还为父子进程之间的通信提供了内置支持，可以使用 <code>send()</code> 方法发送消息，接收消息的事件为 <code>message</code>。由于 <code>fork</code> 专门用于 Node.js 进程，所以它更适合 Node.js 应用程序中的进程管理。</li><li>**<code>exec(command[, options][, callback])</code>**：<code>exec</code> 用于异步地执行系统命令，并将输出缓冲到一个回调函数中。它接受一个完整的命令字符串（包括参数），当进程完成时，回调函数将被调用，并接收可能的错误、标准输出和标准错误作为参数。<code>exec</code> 适用于预期输出较小的短时命令，因为它会将输出缓冲到内存中，可能导致内存不足的问题。</li></ol><p>总结一下：</p><ul><li><code>spawn()</code>：用于异步地创建子进程，适用于大量数据的长时间运行的进程。</li><li><code>fork()</code>：用于创建 Node.js 子进程，提供了父子进程间的内置通信支持。</li><li><code>exec()</code>：用于执行短时命令，将输出缓冲到内存中。适用于预期输出较小的情况。</li></ul><p>在选择适当的函数时，你应该根据需要执行的命令类型、预期的输出量和是否需要进程间通信来进行判断。</p><hr /><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="DOMContentLoaded-与-load-的区别"><a href="#DOMContentLoaded-与-load-的区别" class="headerlink" title="DOMContentLoaded 与 load 的区别 ?"></a>DOMContentLoaded 与 load 的区别 ?</h3><p><code>DOMContentLoaded</code> 和 <code>load</code> 都是浏览器中的事件，它们表示页面加载过程中的不同阶段。这两个事件的主要区别在于它们触发的时间和关注的内容。</p><ol><li><strong>DOMContentLoaded</strong>：当 HTML 文档被完全加载和解析完成后，<code>DOMContentLoaded</code> 事件就会触发，而此时无需等待样式表、图像和子框架的完成加载。换句话说，<code>DOMContentLoaded</code> 主要关注 HTML 文档结构的加载，以便 JavaScript 代码可以在 DOM 树准备就绪后立即运行。这使得你可以尽早地开始操作 DOM，而无需等待其他资源加载完成。</li><li><strong>load</strong>：当页面上的所有资源（包括样式表、图像、子框架等）都完成加载后，<code>load</code> 事件会触发。这意味着在 <code>load</code> 事件触发时，你可以确保页面上的所有资源都可用，这对于需要操作图像尺寸或其他依赖外部资源的功能来说非常有用。</li></ol><p>总之，<code>DOMContentLoaded</code> 和 <code>load</code> 事件的区别在于它们关注的内容和触发时间：</p><ul><li><code>DOMContentLoaded</code>：在 HTML 文档结构加载和解析完成后触发，不等待外部资源（如样式表和图像）加载完成。</li><li><code>load</code>：在页面上的所有资源（包括样式表、图像等）加载完成后触发。</li></ul><p>通常，如果你的 JavaScript 代码仅依赖于 DOM 结构，那么使用 <code>DOMContentLoaded</code> 事件会更快、更有效。如果你的代码依赖于外部资源，那么使用 <code>load</code> 事件可能更合适。</p><h3 id="谈谈你对-dom-事件机制的理解"><a href="#谈谈你对-dom-事件机制的理解" class="headerlink" title="谈谈你对 dom 事件机制的理解"></a>谈谈你对 dom 事件机制的理解</h3><p>DOM（文档对象模型，Document Object Model）事件机制是 Web 浏览器中实现交互的重要组成部分。在 JavaScript 中，DOM 事件机制使得开发者可以在特定情况下响应用户的操作，如点击、滚动、键盘输入等。以下是对 DOM 事件机制的一些理解：</p><ol><li>事件流：DOM 事件机制分为三个阶段，分别是捕获阶段（capturing phase）、目标阶段（target phase）和冒泡阶段（bubbling phase）。事件首先会经过捕获阶段，沿着 DOM 树从上至下传递，直到到达事件的目标元素。然后进入目标阶段，触发目标元素上的事件处理程序。最后是冒泡阶段，事件沿着 DOM 树从下往上回传。</li><li>事件处理程序：开发者可以为 DOM 元素添加事件处理程序，用以响应特定的事件。事件处理程序可以使用两种方式进行绑定：一种是通过 HTML 属性直接在元素上绑定，如<code>onclick</code>；另一种是通过 JavaScript 为元素添加事件处理程序，如<code>addEventListener()</code>方法。</li><li>事件对象：当事件触发时，浏览器会自动创建一个事件对象，该对象包含了有关事件的详细信息，例如事件类型、目标元素、触发时间等。事件对象通常作为事件处理程序的第一个参数传递。</li><li>事件委托：事件委托是一种事件处理机制，通过将事件处理程序绑定到父元素，可以实现对子元素的事件监听。这样可以减少事件处理程序的数量，提高性能。事件委托利用了事件冒泡机制，使得在父元素上可以捕捉到子元素触发的事件。</li><li>阻止默认行为和阻止事件传播：在某些情况下，我们希望阻止事件的默认行为或阻止事件的传播。可以通过调用事件对象的<code>preventDefault()</code>方法来阻止默认行为，调用<code>stopPropagation()</code>方法来阻止事件的传播。</li></ol><p>了解 DOM 事件机制对于前端开发者非常重要，因为它涉及到网页交互、用户体验等关键方面。掌握 DOM 事件机制有助于编写更高效、可维护的代码。</p><h3 id="什么是默认行为，哪些事件有默认行为"><a href="#什么是默认行为，哪些事件有默认行为" class="headerlink" title="什么是默认行为，哪些事件有默认行为"></a>什么是默认行为，哪些事件有默认行为</h3><p>默认行为是指浏览器在某些事件触发时自动执行的内置行为。在处理这些事件时，如果不希望触发默认行为，可以使用<code>preventDefault()</code>方法来阻止它。以下是一些具有默认行为的常见事件：</p><ol><li><code>click</code>：当点击某些元素（如链接）时，浏览器会执行默认行为，如导航到指定的 URL。</li><li><code>submit</code>：当表单元素触发提交事件时，浏览器的默认行为是向服务器发送表单数据。</li><li><code>keydown</code>：在输入框内按下某些特定键（如 Enter 键）时，可能会触发浏览器的默认行为，如提交表单。</li><li><code>contextmenu</code>：当用户右击网页时，浏览器会显示上下文菜单。这是<code>contextmenu</code>事件的默认行为。</li><li><code>dragstart</code>和<code>drop</code>：当对某些元素进行拖放操作时，浏览器会执行默认的拖放行为。</li><li><code>mousedown</code>：在文本区域内按下鼠标，浏览器默认会选中文本。</li><li><code>wheel</code>：当用户滚动鼠标滚轮时，浏览器的默认行为是滚动页面。</li><li><code>touchstart</code>、<code>touchmove</code>、<code>touchend</code>：在触摸设备上，这些触摸事件的默认行为可能包括滚动、缩放等。</li></ol><p>这些事件的默认行为取决于浏览器及其版本。在某些情况下，为了实现自定义行为或提高用户体验，开发者可能需要阻止这些默认行为。在事件处理程序中调用<code>event.preventDefault()</code>方法可以实现这一目的。但请注意，不是所有事件的默认行为都可以被阻止，部分事件可能由于浏览器安全策略等原因无法阻止默认行为。</p><h3 id="CSS-加载会造成阻塞吗？"><a href="#CSS-加载会造成阻塞吗？" class="headerlink" title="CSS 加载会造成阻塞吗？"></a>CSS 加载会造成阻塞吗？</h3><p>CSS 加载对于渲染流程来说是有阻塞性的。当浏览器遇到一个外部 CSS 文件时，它会发送一个请求去获取这个文件。在获取并解析完 CSS 文件之前，浏览器会阻塞渲染流程。这是因为 CSS 文件中可能包含对页面元素的样式信息，浏览器需要确保在渲染页面时使用正确的样式。</p><p>尽管 CSS 加载阻塞渲染，但它并不阻塞其他资源的下载（如 JavaScript、图片等）。这意味着浏览器可以并行下载其他资源，从而提高页面的加载性能。</p><p>为了避免 CSS 阻塞渲染，可以采取以下措施：</p><ol><li><strong>将 CSS 放在 <code>&lt;head&gt;</code> 标签中</strong>：将 <code>&lt;link&gt;</code> 标签放在 <code>&lt;head&gt;</code> 中，可以确保浏览器尽早发现并下载 CSS 文件，从而减少渲染阻塞的时间。</li><li><strong>使用媒体查询</strong>：通过为 CSS 文件添加媒体查询，可以告诉浏览器只在特定条件下使用这个文件。这样，在不满足条件的情况下，浏览器不会阻塞渲染。例如：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot;&gt;</code>。</li><li><strong>代码分割和按需加载</strong>：将 CSS 分为多个较小的文件，只在需要时加载。例如，可以将关键 CSS 内联到 HTML 文档中，以加速首屏渲染。其他非关键 CSS 可以在页面加载完成后异步加载。</li><li><strong>优化和压缩 CSS</strong>：优化和压缩 CSS 代码，可以减小文件大小，从而加快下载速度。可以使用 CSS 预处理器（如 Sass、Less）或压缩工具（如 CSSNano、UglifyCSS）进行优化。</li></ol><p>通过采用这些策略，可以降低 CSS 加载对页面渲染的阻塞性，从而提高用户体验。</p><h3 id="谈谈你对跨域资源共享-CORS-的理解"><a href="#谈谈你对跨域资源共享-CORS-的理解" class="headerlink" title="谈谈你对跨域资源共享 CORS 的理解"></a>谈谈你对跨域资源共享 CORS 的理解</h3><p>跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）是一种安全机制，允许一个网页的资源（例如 AJAX 请求、字体、图片等）从不同的源（域名、协议或端口）访问。由于同源策略（Same-origin policy）的限制，不同源的网页通常无法互相访问资源。CORS 通过在 HTTP 头中加入特定的字段，使得浏览器和服务器之间可以协商，从而允许跨域请求。</p><p>CORS 主要通过以下几种方式实现跨域访问：</p><ol><li><strong>简单请求</strong>：简单请求是指满足一定条件的跨域请求，包括使用以下 HTTP 方法之一：GET、HEAD、POST，并且 HTTP 头信息不超出以下字段：Accept、Accept-Language、Content-Language、Content-Type（限于 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）。对于简单请求，浏览器会在请求中添加 <code>Origin</code> 头，指示请求来自哪个源。服务器接收到请求后，如果允许跨域访问，会在响应头中添加 <code>Access-Control-Allow-Origin</code> 字段。</li><li><strong>预检请求</strong>：预检请求（Preflight request）是一种 CORS 机制，用于处理不满足简单请求条件的跨域请求。预检请求使用 OPTIONS 方法发送，浏览器会在请求头中包含 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段。服务器收到预检请求后，如果允许跨域访问，会在响应头中添加 <code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code> 等字段。预检请求成功后，浏览器才会发送实际的跨域请求。</li><li><strong>携带身份凭证</strong>：CORS 还支持在跨域请求中携带身份凭证（如 Cookie），通过设置 <code>withCredentials</code> 属性为 <code>true</code>。在这种情况下，服务器需要在响应头中添加 <code>Access-Control-Allow-Credentials: true</code> 字段，以允许携带身份凭证的请求。同时，<code>Access-Control-Allow-Origin</code> 字段不能为通配符（<code>*</code>），必须指定具体的源。</li></ol><p>总的来说，CORS 通过在 HTTP 头中添加特定的字段，使得浏览器和服务器之间可以协商允许跨域访问。这种机制确保了 Web 应用程序的安全性，同时允许跨域资源共享。在实际开发中，服务器端需要正确配置 CORS 相关的响应头，以支持跨域请求。</p><h3 id="浏览器的主要组成部分是什么？"><a href="#浏览器的主要组成部分是什么？" class="headerlink" title="浏览器的主要组成部分是什么？"></a>浏览器的主要组成部分是什么？</h3><p>浏览器主要由以下几个组成部分：</p><ol><li><strong>用户界面（User Interface）</strong>：用户界面包括地址栏、前进&#x2F;后退按钮、书签菜单等。它是用户与浏览器进行交互的部分。</li><li><strong>浏览器引擎（Browser Engine）</strong>：浏览器引擎是浏览器的核心部分，负责在用户界面和渲染引擎之间协调操作。它接收用户界面的命令，然后将其传递给渲染引擎或其他浏览器组件。</li><li><strong>渲染引擎（Rendering Engine）</strong>：渲染引擎负责显示请求的内容，如 HTML、CSS 和图像等。它将这些资源解析为屏幕上可见的图形。主流的渲染引擎有 WebKit（Chrome、Safari 等浏览器使用）和 Gecko（Firefox 使用）。</li><li><strong>网络（Networking）</strong>：网络组件用于处理网络请求和响应，如 HTTP 请求，以获取所需的资源（HTML、CSS、JavaScript、图像等）。它还负责处理网络协议、DNS 查询等。</li><li><strong>JavaScript 解释器（JavaScript Interpreter）</strong>：JavaScript 解释器负责解析和执行 JavaScript 代码。主流的 JavaScript 引擎有 V8（Chrome 和 Node.js 使用）、SpiderMonkey（Firefox 使用）和 JavaScriptCore（Safari 使用）。</li><li><strong>UI 后端（UI Backend）</strong>：UI 后端负责绘制用户界面的基本组件，如窗口、按钮等。它使用操作系统的用户界面方法，以实现跨平台的用户界面功能。</li><li><strong>数据存储（Data Storage）</strong>：浏览器需要在本地存储数据，如 Cookie、localStorage 和 IndexedDB 等。这些数据存储技术使得 Web 应用可以在浏览器中持久化数据。</li></ol><p>这些组件共同构成了现代浏览器，使得用户可以浏览网页并与之互动。各个浏览器可能在实现上有所不同，但它们的基本组成部分和功能是相似的。</p><h3 id="谈谈你对-SPA-单页应用的理解"><a href="#谈谈你对-SPA-单页应用的理解" class="headerlink" title="谈谈你对 SPA 单页应用的理解"></a>谈谈你对 SPA 单页应用的理解</h3><p>SPA（Single Page Application，单页应用）是一种 Web 应用开发模式，它在浏览器中加载一个 HTML 文件，然后通过 JavaScript 动态更新和操作 DOM 元素，以实现页面内容的改变。在这种模式下，所有的操作都在同一个页面中进行，不需要跳转到其他页面。这样可以避免多次向服务器请求不同的页面，从而提高用户体验。</p><p>以下是关于 SPA 的一些特点和优缺点：</p><p>优点：</p><ol><li><strong>快速响应</strong>：SPA 在第一次加载时，获取所有必要的资源（HTML、CSS、JavaScript），之后只需通过 AJAX 请求获取数据，无需重新加载整个页面。这使得 SPA 更快速响应，为用户提供了更流畅的体验。</li><li><strong>前后端分离</strong>：SPA 通常与 RESTful API 结合使用，使得前端和后端可以独立开发和部署。这种分离有助于提高开发效率，降低维护成本。</li><li><strong>易于开发和调试</strong>：由于 SPA 主要依赖于 JavaScript 进行页面更新和数据处理，开发者可以使用各种现代 JavaScript 开发工具和框架，如 React、Angular 和 Vue 等，以简化开发和调试过程。</li></ol><p>缺点：</p><ol><li><strong>SEO 问题</strong>：传统的搜索引擎爬虫可能无法正确解析和执行 JavaScript，导致 SPA 页面的内容无法被搜索引擎索引。虽然现代搜索引擎如 Google 在这方面有所改进，但仍需额外的优化以确保 SPA 的搜索引擎优化（SEO）效果。</li><li><strong>初始加载时间</strong>：由于 SPA 在第一次加载时需要获取所有必要的资源，这可能导致初始加载时间较长。为解决这个问题，可以采用代码分割、懒加载等技术来优化加载性能。</li><li><strong>安全问题</strong>：SPA 可能面临跨站脚本（XSS）攻击和其他安全威胁。开发者需要采取相应的安全措施，如对用户输入进行过滤和验证，确保 Web 应用的安全性。</li></ol><p>总的来说，SPA 是一种流行的 Web 应用开发模式，它具有快速响应、前后端分离等优点，但同时也需要注意解决 SEO、性能和安全等方面的问题。</p><h3 id="为什么-JS-执行时会阻塞页面加载"><a href="#为什么-JS-执行时会阻塞页面加载" class="headerlink" title="为什么 JS 执行时会阻塞页面加载"></a>为什么 JS 执行时会阻塞页面加载</h3><p>JavaScript 执行阻塞页面加载的原因是浏览器在解析和渲染 HTML 文档时遵循自上而下的顺序。当浏览器遇到一个 <code>&lt;script&gt;</code> 标签时（尤其是外部 JavaScript 文件），它会立即下载并执行这个脚本。由于 JavaScript 可能会修改 DOM 结构或操作 CSSOM（如添加、删除元素或更改样式），浏览器必须确保在执行 JavaScript 之前，先解析完 JavaScript 之前的 HTML 和 CSS。这样可以<strong>防止页面出现不一致的渲染效果</strong>。</p><p>因此，当浏览器遇到一个 JavaScript 脚本时，它会：</p><ol><li>阻塞 HTML 解析。</li><li>如果有外部 JavaScript 文件，发送请求并等待下载完成。</li><li>执行 JavaScript 代码。</li><li>继续解析剩余的 HTML 文档。</li></ol><p>JavaScript 执行阻塞页面加载可能会导致性能问题和较差的用户体验。为了解决这个问题，可以采用以下策略：</p><ol><li><strong>将脚本放在文档底部</strong>：将 <code>&lt;script&gt;</code> 标签放在文档的底部，紧邻 <code>&lt;/body&gt;</code> 标签。这样可以确保在执行 JavaScript 之前，先解析完 HTML 和 CSS，从而减少阻塞时间。</li><li><strong>使用 <code>defer</code> 属性</strong>：给 <code>&lt;script&gt;</code> 标签添加 <code>defer</code> 属性，可以告诉浏览器在下载脚本的同时继续解析 HTML。脚本将在文档解析完成后顺序执行。例如：<code>&lt;script src=&quot;example.js&quot; defer&gt;&lt;/script&gt;</code>。</li><li><strong>使用 <code>async</code> 属性</strong>：给 <code>&lt;script&gt;</code> 标签添加 <code>async</code> 属性，可以使脚本异步下载和执行。这意味着脚本会在下载完成后立即执行，而不用等待其他脚本。请注意，这可能会导致脚本执行顺序发生变化，因此只适用于那些不依赖其他脚本的独立脚本。例如：<code>&lt;script src=&quot;example.js&quot; async&gt;&lt;/script&gt;</code>。</li></ol><p>通过采用这些策略，可以减少 JavaScript 对页面加载的阻塞性，提高页面性能和用户体验。</p><h3 id="说一说你对-Cookie-localStorage-sessionStorage-的理解"><a href="#说一说你对-Cookie-localStorage-sessionStorage-的理解" class="headerlink" title="说一说你对 Cookie localStorage sessionStorage 的理解"></a>说一说你对 Cookie localStorage sessionStorage 的理解</h3><p>Cookie、localStorage 和 sessionStorage 都是在客户端存储数据的技术，但它们之间有一些关键的区别：</p><ol><li><strong>Cookie</strong>：<ul><li>Cookie 最初是为了在客户端保存用户会话信息而设计的，它们可以在客户端和服务器之间进行传递。</li><li>Cookie 的大小限制为 4KB 左右，因此不适合存储大量数据。</li><li>Cookie 有一个有效期，可以设置为特定的时间长度。过期后，Cookie 会被自动删除。</li><li>Cookie 可能面临安全风险，如跨站请求伪造（CSRF）攻击。因此，在使用 Cookie 时需要采取一定的安全措施。</li><li>因为每次 HTTP 请求都会携带 Cookie，所以频繁操作 Cookie 可能会影响性能。</li></ul></li><li><strong>localStorage</strong>：<ul><li>localStorage 是 HTML5 引入的一种客户端存储技术，允许在用户的浏览器中存储较大量的数据（通常为 5-10MB，根据浏览器实现有所不同）。</li><li>localStorage 中存储的数据没有有效期，会一直保留，除非用户手动清除或者使用代码进行删除。</li><li>localStorage 只在客户端进行操作，不会与服务器进行通信。</li><li>localStorage 的数据存储在同一个域名下，不同域名之间的 localStorage 数据是隔离的。</li></ul></li><li><strong>sessionStorage</strong>：<ul><li>sessionStorage 与 localStorage 非常相似，它们都是 HTML5 引入的客户端存储技术，具有相同的存储容量限制。</li><li>与 localStorage 不同的是，sessionStorage 的数据仅在当前浏览器标签或窗口的生命周期内有效。当用户关闭标签或窗口时，sessionStorage 中的数据会被自动清除。</li><li>sessionStorage 同样只在客户端进行操作，不会与服务器进行通信。</li><li>sessionStorage 的数据同样存储在同一个域名下，不同域名之间的 sessionStorage 数据是隔离的。</li></ul></li></ol><p>总之，Cookie、localStorage 和 sessionStorage 都是客户端存储技术，但它们之间在数据有效期、存储容量和与服务器通信等方面有所不同。根据具体需求和场景，开发者可以选择合适的技术进行数据存储。</p><h3 id="讲讲浏览器缓存"><a href="#讲讲浏览器缓存" class="headerlink" title="讲讲浏览器缓存"></a>讲讲浏览器缓存</h3><p>浏览器缓存是一种性能优化技术，通过将已请求的资源（如 HTML、CSS、JavaScript、图片等）存储在本地，以减少网络请求和数据传输。当用户再次访问相同的资源时，浏览器可以直接从缓存中获取，从而加快页面加载速度、降低服务器压力和减少网络流量消耗。</p><p>浏览器缓存主要分为以下几种类型：</p><ol><li><strong>强缓存</strong>： 强缓存是指浏览器在缓存期间内不会再向服务器发送任何请求，而是直接从本地缓存中获取资源。强缓存由以下两个 HTTP 响应头控制：<ul><li><code>Expires</code>：指定资源的过期时间。例如：<code>Expires: Wed, 21 Oct 2023 07:28:00 GMT</code>。但由于服务器时间和客户端时间可能存在差异，所以这个响应头不太准确。</li><li><code>Cache-Control</code>：使用更现代且准确的方式控制缓存。例如：<code>Cache-Control: max-age=3600</code>，表示资源的缓存有效期为 3600 秒。其他可用的指令还包括 <code>no-cache</code>、<code>no-store</code>、<code>must-revalidate</code> 等。</li></ul></li><li><strong>协商缓存</strong>： 当强缓存失效后，浏览器会向服务器发送请求，以验证资源是否有更新。协商缓存通过以下 HTTP 响应头和请求头控制：<ul><li><code>Last-Modified</code> 和 <code>If-Modified-Since</code>：服务器返回资源时，通过 <code>Last-Modified</code> 响应头指定资源最后修改时间。浏览器下次请求时会通过 <code>If-Modified-Since</code> 请求头发送这个时间。服务器会比较这个时间和资源的实际修改时间，如果没有变化，则返回 <code>304 Not Modified</code> 状态码，浏览器将使用本地缓存；否则返回更新后的资源和新的 <code>Last-Modified</code> 时间。</li><li><code>ETag</code> 和 <code>If-None-Match</code>：<code>ETag</code> 是服务器为资源生成的唯一标识（通常是哈希值）。浏览器下次请求时会通过 <code>If-None-Match</code> 请求头发送这个标识。服务器会比较这个标识和资源的当前 <code>ETag</code>，如果相同，则返回 <code>304 Not Modified</code> 状态码；否则返回更新后的资源和新的 <code>ETag</code>。</li></ul></li><li><strong>其他缓存技术</strong>： 除了上述浏览器缓存机制外，还有一些其他缓存技术，如 Service Workers、Memory Cache、IndexedDB 等。它们可以根据具体需求和场景进行灵活地缓存策略配置。</li></ol><h3 id="路由-history-和-hash-的区别？"><a href="#路由-history-和-hash-的区别？" class="headerlink" title="路由 history 和 hash 的区别？"></a>路由 history 和 hash 的区别？</h3><p>路由 history 和 hash 是前端路由（Single Page Application, SPA）中常用的两种模式。它们的主要区别在于实现方式和 URL 的展示形式。</p><ol><li><strong>Hash 模式</strong>：<ul><li>Hash 模式基于浏览器 URL 中的哈希（<code>#</code>）部分进行路由切换。当哈希值改变时，浏览器不会向服务器发送请求，而是触发 <code>hashchange</code> 事件。前端路由库会监听这个事件，并根据哈希值变化来更新视图。</li><li>URL 示例：<code>https://example.com/#/page1</code></li><li>Hash 模式兼容性较好，适用于旧版本浏览器。</li></ul></li><li><strong>History 模式</strong>：<ul><li>History 模式基于 HTML5 的 History API（如 <code>pushState</code>、<code>replaceState</code> 和 <code>popstate</code> 事件）实现。这些 API 允许在不重新加载页面的情况下，直接操作浏览器的历史记录和 URL。</li><li>URL 示例：<code>https://example.com/page1</code></li><li>History 模式需要服务器的配合，因为在用户直接访问某个路由（如 <code>https://example.com/page1</code>）时，如果服务器没有对应的配置，可能会返回 404 错误。为了解决这个问题，服务器需要设置一个通配符路由，将所有未匹配到的路由都重定向到单页应用的入口 HTML 文件。</li></ul></li></ol><p>总之，Hash 模式和 History 模式是前端路由中的两种实现方式，具有不同的 URL 展示形式和浏览器兼容性。在选择路由模式时，需要根据项目需求、用户体验和服务器配置等因素进行权衡。</p><h3 id="谈一谈你对重排和重绘理解"><a href="#谈一谈你对重排和重绘理解" class="headerlink" title="谈一谈你对重排和重绘理解"></a>谈一谈你对重排和重绘理解</h3><p>在浏览器渲染过程中，重排（reflow）和重绘（repaint）是两个重要概念。它们是指浏览器在处理 DOM 元素样式和位置变化时所发生的操作。</p><p><strong>重排（Reflow）</strong>： 重排，也称为回流，是指浏览器重新计算元素的布局、尺寸和位置等几何信息的过程。当 DOM 结构发生变化，或者元素的尺寸、位置、边距等样式发生改变时，浏览器需要重新计算这些元素的几何属性，并确定如何在页面上显示它们。重排可能会导致整个页面的重新布局，因此是一个性能敏感的过程。</p><p>触发重排的操作包括：</p><ul><li>添加或删除 DOM 元素</li><li>修改元素尺寸（如宽度、高度、边距等）</li><li>修改元素位置（如浮动、定位等）</li><li>改变窗口大小</li><li>修改默认字体大小</li></ul><p><strong>重绘（Repaint）</strong>： 重绘是指浏览器重新绘制 DOM 元素的过程，但不涉及元素的几何属性计算。当元素的外观样式（如颜色、背景、边框等）发生变化时，浏览器需要重新绘制这些元素，以反映样式的变化。相较于重排，重绘的性能开销较小。</p><p>触发重绘的操作包括：</p><ul><li>修改元素颜色、背景等视觉样式</li><li>元素的几何属性发生变化，触发重排（重排会导致重绘）</li></ul><p>为了提高页面渲染性能，我们应尽量减少重排和重绘的发生。一些优化措施包括：</p><ul><li>避免频繁修改 DOM 结构和样式，可以将修改操作合并后一次性执行</li><li>使用 <code>requestAnimationFrame</code> 或者 <code>setTimeout</code> 函数进行样式更新的节流</li><li>对于不可见或者离屏的元素，可以先将它们移除或隐藏，然后在内存中进行样式修改，最后再重新插入或显示</li><li>使用 CSS3 动画替代 JavaScript 动画，以利用 GPU 加速</li><li>使用虚拟 DOM 技术（如 React、Vue 等框架），避免不必要的 DOM 更新</li></ul><h3 id="谈一谈跨域，同源策略，以及跨域解决方案"><a href="#谈一谈跨域，同源策略，以及跨域解决方案" class="headerlink" title="谈一谈跨域，同源策略，以及跨域解决方案"></a>谈一谈跨域，同源策略，以及跨域解决方案</h3><p><strong>同源策略</strong>： 同源策略是一种安全机制，用于限制文档或脚本从不同来源的数据进行交互。当两个资源具有相同的协议（如 http 或 https）、域名和端口时，它们被认为是同源的。同源策略限制了从一个源加载的网页脚本与来自另一个源的资源进行交互的能力，以防止恶意行为，如跨站脚本攻击（XSS）或数据窃取。</p><p><strong>跨域</strong>： 跨域是指当一个资源试图访问来自不同源的另一个资源时，由于同源策略的限制而无法进行的情况。例如，一个从 <code>http://example-a.com</code> 加载的网页试图通过 AJAX 请求 <code>http://example-b.com</code> 上的数据，这就是一个跨域请求。</p><p><strong>跨域解决方案</strong>： 有多种方法可以绕过同源策略的限制，实现跨域请求。以下是一些常见的跨域解决方案：</p><ol><li><strong>CORS（跨域资源共享）</strong>： CORS 是一种官方推荐的跨域解决方案。它允许服务器通过设置响应头（如 <code>Access-Control-Allow-Origin</code>）来放宽对跨域请求的限制。浏览器将根据这些响应头决定是否允许跨域请求。</li><li><strong>JSONP（JSON with Padding）</strong>： JSONP 利用了 <code>&lt;script&gt;</code> 标签的 src 属性不受同源策略限制的特性。它通过动态创建一个 <code>&lt;script&gt;</code> 标签，并将回调函数作为参数传递给服务器。服务器将请求数据包装在回调函数中，并将其作为响应返回。客户端脚本收到响应后，会立即执行回调函数以获取数据。</li><li><strong>使用代理服务器</strong>： 可以通过代理服务器将跨域请求转发到目标服务器。这样，客户端与代理服务器之间的请求就是同源的，而代理服务器与目标服务器之间的请求则由代理服务器完成。常见的代理服务器实现方式有 Nginx 反向代理、Node.js 中间件代理等。</li><li><strong>使用 iframe 和 postMessage</strong>： 可以使用 iframe 加载跨域页面，然后通过 <code>window.postMessage</code> 方法在不同源的窗口之间传递消息。这种方法需要跨域页面的配合，以便在接收到消息时执行相应操作。</li><li><strong>使用 WebSockets</strong>： WebSockets 可以实现跨域通信，因为它们不受同源策略限制。通过建立一个 WebSocket 连接，客户端和服务器可以进行双向通信，实现跨域数据交换。</li><li><strong>使用 CORS 代理</strong>： 如果目标服务器没有实现 CORS，而你又不想在自己的服务器上设置反向代理，可以使用第三方 CORS 代理服务。这些服务在请求目标服务器时为你添加 CORS 响应头，从而使浏览器允许跨域请求。但请注意，这可能会带来安全风险，因此不建议在生产环境中使用。</li><li><strong>使用 document.domain</strong>： 当两个具有相同根域名但子域名不同的页面需要进行跨域通信时，可以将它们的 <code>document.domain</code> 设置为相同的值。这样，它们将被视为同源，可以进行通信。但此方法仅适用于具有相同根域名的情况。</li><li><strong>使用 window.name</strong>： 可以利用 <code>window.name</code> 在同源和跨域的窗口之间传递数据。<code>window.name</code> 属性在窗口跳转时会保留其值，因此可以将数据存储在 <code>window.name</code> 中，然后通过跳转到同源页面来读取数据。但这种方法受到一些限制，只能传递字符串数据，且安全性和可靠性相对较低。</li></ol><p>每种跨域解决方案都有其优缺点，需要根据实际场景和需求选择合适的方法。现代 Web 开发中，CORS 是最常用且推荐的解决方案。但在某些特殊场景或者兼容旧版浏览器时，可能需要考虑其他方案。在实现跨域时，始终要关注安全性和数据保护，确保不会引入安全漏洞。</p><h3 id="前端如何进行-seo-优化"><a href="#前端如何进行-seo-优化" class="headerlink" title="前端如何进行 seo 优化"></a>前端如何进行 seo 优化</h3><p>前端在进行搜索引擎优化（SEO）时，可以从以下几个方面进行优化：</p><ol><li><strong>合理的标题、描述和关键词</strong>： 确保每个页面都有独特且描述准确的<code>&lt;title&gt;</code>标签和<code>&lt;meta name=&quot;description&quot;&gt;</code>标签。这有助于搜索引擎理解页面内容，同时也为用户在搜索结果中显示更具吸引力的信息。</li><li><strong>语义化的 HTML 结构</strong>： 使用语义化的 HTML 标签，如<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>等，以帮助搜索引擎更好地理解页面结构和内容。</li><li><strong>良好的页面结构</strong>： 确保页面具有清晰的层次结构和导航，这有助于搜索引擎爬虫更容易地抓取和索引页面内容。</li><li><strong>优化 URL 结构</strong>： 使用简洁且描述性的 URL，避免过长或包含不必要的参数。这有助于搜索引擎理解页面内容，并提高用户体验。</li><li><strong>使用 header 标签</strong>： 使用<code>&lt;h1&gt;</code>至<code>&lt;h6&gt;</code>等 header 标签来组织页面内容，确保每个页面只有一个<code>&lt;h1&gt;</code>标签。这有助于搜索引擎理解页面的主题和重要性。</li><li><strong>图片优化</strong>： 为所有图片添加<code>alt</code>属性，以便搜索引擎了解图片内容。同时，优化图片大小和格式，以提高页面加载速度。</li><li><strong>内部链接和锚文本</strong>： 合理地使用内部链接和有意义的锚文本，以帮助搜索引擎更好地理解站点结构和内容之间的关联。</li><li><strong>响应式设计</strong>： 确保网站适应不同设备和屏幕尺寸，提供良好的用户体验。搜索引擎倾向于对移动友好的网站给予更高的排名。</li><li><strong>网站速度优化</strong>： 提高网站加载速度，减少页面渲染时间。这包括压缩资源、合并文件、优化图片、使用浏览器缓存等。搜索引擎会考虑网站速度作为排名的因素之一。</li><li><strong>遵循 W3C 标准</strong>： 确保代码符合 W3C 标准，减少 HTML、CSS 和 JavaScript 的错误。这有助于搜索引擎更容易地抓取和解析页面内容。</li><li><strong>生成 XML Sitemap</strong>： 为网站创建一个 XML Sitemap，并提交给搜索引擎。这有助于搜索引擎更有效地抓取和索引网站内容。</li><li><strong>使用结构化数据</strong>： 使用结构化数据（如 Schema.org、JSON-LD、Microdata 等）来标注页面内容，有助于搜索引擎更准确地理解页面信息，并可能在搜索结果中显示为富文本摘要，提高点击率。</li><li><strong>使用 robots.txt 控制爬虫访问</strong>： 合理设置 robots.txt 文件，指定搜索引擎爬虫可以访问和抓取的页面，避免爬虫抓取不相关或低质量的页面。</li><li><strong>优化站内搜索</strong>： 提供高效、准确的站内搜索功能，有助于提高用户体验和用户停留时间，间接影响搜索排名。</li><li><strong>社交媒体整合</strong>： 将网站内容与社交媒体平台整合，提高内容的曝光度和分享率，增加外部链接，有助于提高搜索排名。</li><li><strong>网站安全</strong>： 使用 HTTPS 加密，保护用户数据和隐私。搜索引擎会将安全性作为排名因素之一。</li></ol><p>总之，前端在进行 SEO 优化时，要关注页面结构、内容、用户体验和技术实现等多个方面。通过提高页面质量、提升用户体验和遵循搜索引擎的最佳实践，有助于提高网站在搜索结果中的排名和可见度。</p><h3 id="requestAnimationFrame-与-requestIdleCallback-区别"><a href="#requestAnimationFrame-与-requestIdleCallback-区别" class="headerlink" title="requestAnimationFrame 与 requestIdleCallback 区别"></a>requestAnimationFrame 与 requestIdleCallback 区别</h3><p><code>requestAnimationFrame</code>和<code>requestIdleCallback</code>都是浏览器提供的用于优化 JavaScript 任务调度的 API。它们之间的主要区别在于它们的使用场景和触发时机。</p><ol><li><strong>requestAnimationFrame</strong>：</li></ol><p><code>requestAnimationFrame</code>主要用于优化浏览器的动画渲染。它允许你在浏览器即将进行下一次重绘之前安排一个回调函数执行。这意味着，回调函数将在最佳的时间点执行，从而提高动画的性能和流畅度。</p><p><code>requestAnimationFrame</code>的优点包括：</p><ul><li>与浏览器的刷新率同步，避免动画卡顿或丢帧现象。</li><li>当页面不可见或最小化时，浏览器会暂停执行<code>requestAnimationFrame</code>回调，从而减少 CPU 和 GPU 的使用，节省资源。</li></ul><p>典型的<code>requestAnimationFrame</code>用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行动画操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 在下一次重绘之前请求执行动画</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(animate);</span><br></pre></td></tr></table></figure><ol><li><strong>requestIdleCallback</strong>：</li></ol><p><code>requestIdleCallback</code>用于优化非关键性任务的执行，例如代码分析、日志报告、数据存储等。当浏览器空闲时，<code>requestIdleCallback</code>会触发回调函数执行，从而避免阻塞关键任务，如渲染、动画和用户交互。</p><p><code>requestIdleCallback</code>的优点包括：</p><ul><li>利用浏览器的空闲时间执行低优先级任务，避免干扰关键任务。</li><li>可以设置超时时间，确保在指定时间内完成任务。</li></ul><p>典型的<code>requestIdleCallback</code>用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performNonCriticalTask</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行非关键任务</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还有未完成的任务，继续请求空闲回调</span></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(performNonCriticalTask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(performNonCriticalTask);</span><br></pre></td></tr></table></figure><p>总之，<code>requestAnimationFrame</code>和<code>requestIdleCallback</code>分别用于优化动画渲染和非关键性任务的执行。<code>requestAnimationFrame</code>在每次浏览器重绘之前执行回调，以实现高性能的动画效果；<code>requestIdleCallback</code>则在浏览器空闲时执行回调，避免影响关键任务。</p><h3 id="SSR-的实现原理？"><a href="#SSR-的实现原理？" class="headerlink" title="SSR 的实现原理？"></a>SSR 的实现原理？</h3><p>服务器端渲染（Server Side Rendering，简称 SSR）是一种 web 应用的渲染方式，其实现原理是在服务器端将页面内容渲染为 HTML 字符串，然后将这些字符串发送到客户端，客户端接收到 HTML 后直接显示，无需等待 JavaScript 的解析、执行和渲染。</p><p>SSR 的核心实现原理可以概括为以下几个步骤：</p><ol><li><strong>请求处理</strong>：客户端发起请求时，请求首先到达服务器。</li><li><strong>服务器渲染</strong>：服务器接收到请求后，根据路由和数据，将对应的页面内容渲染为 HTML 字符串。这一步通常涉及到模板引擎或服务器端 JavaScript 框架的使用，例如 React 的 <code>ReactDOMServer.renderToString()</code> 和 Vue 的 <code>vue-server-renderer</code>。</li><li><strong>数据注入</strong>：在渲染过程中，服务器还需要获取所需的数据，将其注入到 HTML 中。这可以通过内联脚本、JSON 格式或其他方式实现。数据注入的目的是在客户端 JavaScript 代码运行时能够获取到服务器端已经准备好的数据，避免重复请求。</li><li><strong>生成完整 HTML</strong>：将渲染好的 HTML 字符串插入到 HTML 模板中，形成一个完整的 HTML 页面。这个页面包含了已经渲染好的内容以及必要的 JavaScript、CSS 等资源引用。</li><li><strong>发送响应</strong>：服务器将完整的 HTML 页面作为响应发送给客户端。客户端接收到响应后，直接将 HTML 页面展示给用户。</li><li><strong>客户端接管</strong>：在客户端，浏览器会解析和执行 JavaScript 代码，接管页面的交互和操作。这一步通常被称为 “hydration” 或 “激活”，因为客户端 JavaScript 代码需要 “激活” 服务器端渲染的静态 HTML，使其具有动态功能。</li></ol><p>通过 SSR，用户可以更快地看到页面的内容，因为无需等待客户端的 JavaScript 代码下载、解析、执行和渲染。此外，由于搜索引擎爬虫能够更好地解析服务器端渲染的 HTML，因此 SSR 对 SEO 也有一定的优势。然而，SSR 也会增加服务器的负担，因为服务器需要负责渲染页面。在实际应用中，可以根据项目需求和性能要求，选择合适的渲染方式。</p><h3 id="讲讲你对-PWA-的理解"><a href="#讲讲你对-PWA-的理解" class="headerlink" title="讲讲你对 PWA 的理解"></a>讲讲你对 PWA 的理解</h3><p>PWA（Progressive Web App，渐进式 web 应用）是一种将现代 web 技术与传统移动应用功能结合的应用开发模式。PWA 旨在通过提供原生应用的类似体验，改进 web 应用的可用性、性能和用户体验。PWA 的核心技术包括 Service Workers、Web App Manifest 和离线缓存等。</p><p>PWA 的主要特点如下：</p><ol><li><strong>可靠性</strong>：通过 Service Workers 和离线缓存技术，PWA 可以在无网络或网络不稳定的环境下运行。用户在访问 PWA 时，即使断网，也能看到离线内容或自定义的离线提示页面。</li><li><strong>快速</strong>：PWA 通过预缓存关键资源和优化加载策略，提高了应用的加载速度和运行性能。在访问 PWA 时，用户可以更快地看到页面内容，并感受到流畅的交互体验。</li><li><strong>可安装</strong>：通过 Web App Manifest，PWA 可以被添加到用户的设备主屏幕，并以独立窗口运行，类似于原生应用。用户可以直接从主屏幕启动 PWA，而无需通过浏览器。</li><li><strong>跨平台</strong>：PWA 基于 web 技术，因此可以在不同的操作系统和设备上运行，包括桌面和移动设备。这意味着，开发者只需维护一套代码，就能为多个平台提供类似的应用体验。</li><li><strong>更新简便</strong>：PWA 无需通过应用商店发布和更新。当用户访问 PWA 时，应用会自动检查并应用更新。这样，用户总是能获取到最新的应用版本，而开发者也能更轻松地发布和管理更新。</li><li><strong>安全</strong>：PWA 需要通过 HTTPS 运行，确保数据传输的安全性。同时，由于 Service Workers 可以拦截和处理请求，PWA 还可以实现更丰富的安全策略和功能，如请求过滤、内容安全策略（CSP）等。</li><li><strong>可搜索</strong>：PWA 作为 web 应用，可以被搜索引擎抓取和索引。这意味着，PWA 可以获得更好的搜索引擎优化（SEO），提高应用的可见度和用户获取途径。</li></ol><p>总之，PWA 是一种充分利用现代 web 技术，为用户提供原生应用般体验的 web 应用开发模式。通过 PWA，开发者可以实现更可靠、快速、可安装和跨平台的应用，提升用户体验和满意度。</p><h3 id="谈谈浏览器的离线缓存与本地缓存的区别"><a href="#谈谈浏览器的离线缓存与本地缓存的区别" class="headerlink" title="谈谈浏览器的离线缓存与本地缓存的区别"></a>谈谈浏览器的离线缓存与本地缓存的区别</h3><p>浏览器的离线缓存和本地缓存都是用于在用户设备上存储数据以提高网页性能的技术，但它们的实现方式和使用场景略有不同。下面是它们之间的一些主要区别：</p><ol><li>目的：</li></ol><p>离线缓存：主要用于在用户离线时仍然可以访问网页。它可以在没有网络连接的情况下提供基本的功能，如查看已缓存页面的内容。</p><p>本地缓存：主要用于减少网络延迟，提高加载速度。通过在用户设备上缓存常用资源，如图片、脚本、样式等，可以在用户再次访问网站时直接从缓存中读取，降低服务器负担和提高用户体验。</p><ol start="2"><li>存储类型：</li></ol><p>离线缓存：使用 HTML5 的 Application Cache（AppCache）和 Service Worker 技术实现。这些技术允许开发者为用户设备创建一个离线版本的网页，包括 HTML、CSS、JavaScript 等资源。</p><p>本地缓存：使用浏览器提供的缓存策略和存储机制实现，如 HTTP 缓存、Cookie、Web Storage（包括 localStorage 和 sessionStorage）和 IndexedDB 等。</p><ol start="3"><li>生命周期：</li></ol><p>离线缓存：由开发者通过 AppCache 或 Service Worker 配置文件控制，包括缓存资源的更新和过期策略。</p><p>本地缓存：由浏览器或服务器通过 HTTP 头部字段（如 Cache-Control、Expires 等）控制，或通过脚本（如 localStorage 和 IndexedDB）设置的存储时间限制。</p><ol start="4"><li>适用场景：</li></ol><p>离线缓存：适用于需要在无网络环境下访问的网页，例如离线阅读应用、PWA（Progressive Web Apps）等。</p><p>本地缓存：适用于任何需要提高网站性能和加载速度的场景，减少不必要的网络请求。</p><p>总之，离线缓存和本地缓存都是为了优化网页性能，它们各自针对不同的使用场景。离线缓存主要是为了在没有网络连接时继续访问网页，而本地缓存则是为了提高网页加载速度和降低服务器负担。</p><h3 id="谈谈你对-Shadow-DOM-的理解"><a href="#谈谈你对-Shadow-DOM-的理解" class="headerlink" title="谈谈你对 Shadow DOM 的理解"></a>谈谈你对 Shadow DOM 的理解</h3><p>Shadow DOM 是 Web Components 规范的一个重要组成部分，它提供了一种将 HTML、CSS 和 JavaScript 封装在独立、隔离的 DOM 结构中的方法，从而实现组件的样式和行为的封装。Shadow DOM 解决了全局样式污染的问题，使得开发者可以创建具有独立样式和逻辑的可重用组件。</p><p>Shadow DOM 的关键特点如下：</p><ol><li><strong>封装</strong>：Shadow DOM 允许将一组 DOM 元素和相关样式封装在一个独立的、隔离的 DOM 树中。这样，组件的样式不会影响到主文档，同样主文档的样式也不会影响到组件。通过这种封装，组件可以在不同的应用中重用，而无需担心样式污染和冲突。</li><li><strong>隔离</strong>：Shadow DOM 的树结构是隔离的，意味着组件内的 DOM 元素和 JavaScript 逻辑与主文档是分开的。这有助于保护组件内的数据和方法，避免被外部访问和修改。</li><li><strong>附件阴影树</strong>：通过 <code>attachShadow</code> 方法，可以在一个普通的 DOM 元素上创建一个 Shadow DOM。这个普通元素被称为 “Shadow Host”，而创建的 Shadow DOM 被称为 “Shadow Tree”。Shadow Tree 与主文档的 DOM 树是并列的，互不干扰。</li><li><strong>插槽（Slot）</strong>：Shadow DOM 支持使用 <code>&lt;slot&gt;</code> 元素来分发（或投影）主文档中的内容。这使得组件可以定义可自定义的内容区域，让使用者在引入组件时提供所需的内容。</li><li><strong>样式隔离</strong>：组件内的 CSS 样式只对 Shadow Tree 中的元素生效，不会影响到主文档。同时，主文档的 CSS 样式（除了 CSS 变量）也不会影响到组件。这样，组件的样式能够完全独立，避免了全局样式污染。</li></ol><p>总之，Shadow DOM 提供了一种在 Web 开发中实现组件封装和样式隔离的机制。通过使用 Shadow DOM，开发者可以创建具有独立样式和行为的可重用组件，简化开发过程，提高组件的可维护性。</p><h3 id="谈谈你对微前端的理解？"><a href="#谈谈你对微前端的理解？" class="headerlink" title="谈谈你对微前端的理解？"></a>谈谈你对微前端的理解？</h3><p>微前端（Micro Frontends）是一种架构模式，它的主要目标是将单一的，通常较大的前端应用程序（如单页面应用）拆分为多个较小的、独立的部分。这些独立的部分通常被称为”微应用”（micro apps）。</p><p>微前端的主要理念来源于微服务架构，后者在后端开发中已经变得非常流行。与微服务一样，微前端也强调团队的独立性和技术栈的多样性。每个微应用可以由不同的团队使用不同的技术栈来开发，然后再集成到一个统一的用户界面中。</p><p>以下是我对微前端的一些理解：</p><ol><li><p><strong>解耦</strong>：微前端的一个关键优点是解耦。每个微应用都是独立的，有自己的代码库、构建流程、开发团队和生命周期。这可以使每个团队更专注于自己的部分，降低开发复杂性，提高开发速度。</p></li><li><p><strong>技术栈无关</strong>：每个微应用可以选择适合自己需求的技术栈，不必受限于整个应用的技术选择。这使得前端开发可以跟上技术的发展，逐步引入新的技术和工具，而无需进行大规模的重构。</p></li><li><p><strong>并行开发</strong>：由于每个微应用都是独立的，所以可以并行开发，提高开发效率。也可以更灵活地调整开发资源和计划，因为每个团队的工作不会直接影响到其他团队。</p></li><li><p><strong>独立部署</strong>：每个微应用可以独立部署，不需要重新部署整个应用。这可以大大减少部署带来的风险，并且可以更快地将新功能和修复推送到用户那里。</p></li></ol><p>但是，微前端也不是没有挑战的。例如，微应用间的通信和协调、整体用户体验的一致性、性能问题（比如加载时间和资源占用）等，都需要在实施微前端架构时仔细考虑。</p><p>总的来说，我认为微前端是一个有前景的架构模式，它在前端开发中引入了微服务的思想，有助于解决大型、复杂的前端应用开发和维护的问题。但是，它也需要对前端架构和工程化有深入的理解，才能有效地实施和管理。</p><h3 id="讲讲浏览器的进程和线程"><a href="#讲讲浏览器的进程和线程" class="headerlink" title="讲讲浏览器的进程和线程"></a>讲讲浏览器的进程和线程</h3><p>浏览器的进程和线程是浏览器实现其功能的基础。它们之间的关系和任务分工对于理解浏览器的运行原理和性能优化至关重要。简单来说，进程是操作系统资源分配的最小单位，而线程是操作系统调度（CPU 利用率）的最小单位。</p><p><strong>进程</strong>：</p><p>进程是一个运行中的程序实例，它包含程序所需的所有资源。一个进程拥有独立的内存空间、全局变量、打开的文件和设备等。浏览器中的进程主要有以下几类：</p><ol><li><strong>浏览器主进程</strong>：负责协调浏览器的各个模块，包括用户界面、地址栏、书签栏等。它还负责管理浏览器的各个标签页进程和插件进程。</li><li><strong>渲染进程</strong>：负责将网页内容渲染到屏幕上。每个标签页通常对应一个渲染进程（在某些情况下，标签页可能会共享一个渲染进程）。渲染进程包括 HTML、CSS 和 JavaScript 的解析、布局、渲染以及执行等任务。</li><li><strong>插件进程</strong>：负责运行和管理浏览器插件（如 Flash）。</li><li><strong>网络进程</strong>：负责处理网络请求，包括资源的下载、上传和缓存。</li></ol><p><strong>线程</strong>：</p><p>线程是进程中的一个执行单元，它共享进程的资源，如内存空间和文件句柄。一个进程可以有多个线程，这些线程可以并发执行任务。在浏览器中，有以下几种主要的线程：</p><ol><li><strong>主线程</strong>：渲染进程的主要执行线程，负责解析和执行 JavaScript 代码、处理 DOM 事件、执行 CSS 动画等任务。主线程是单线程的，这意味着 JavaScript 的执行和页面渲染任务需要排队执行。</li><li><strong>Web Workers</strong>：一种可以在后台运行 JavaScript 代码的线程，它与主线程独立，不会阻塞主线程。Web Workers 可以用于执行耗时的计算任务，避免影响页面渲染。</li><li><strong>Service Workers</strong>：用于实现离线缓存、消息推送、后台同步等功能的独立线程。Service Workers 与 Web Workers 类似，但具有更多的 API 和能力。</li><li><strong>渲染线程</strong>：负责将解析好的 HTML、CSS 和图像资源绘制到屏幕上。渲染线程与主线程是分离的，这意味着页面的渲染和 JavaScript 的执行是并行进行的。</li><li><strong>合成线程</strong>：负责处理页面的合成和分层。当浏览器检测到可以使用 GPU 加速的动画时，合成线程会将这些动画分离出来并在 GPU 上独立运行。这可以避免主线程的阻塞，提高页面的性能。</li><li><strong>网络线程</strong>：负责处理 HTTP 请求和响应，以及与服务器之间的通信。网络线程与主线程独立，以避免网络请求导致的阻塞。</li><li><strong>定时器线程</strong>：负责处理 JavaScript 中的定时器任务（如 <code>setTimeout</code> 和 <code>setInterval</code>）。这些任务会在定时器线程上排队执行，然后在指定的时间后将回调函数推送到主线程的任务队列中。</li><li><strong>解析线程</strong>：负责解析 HTML 和 CSS。解析线程会将解析后的 DOM 树和 CSSOM 树合并为渲染树，并传递给渲染线程进行绘制。在某些情况下，解析线程和主线程可能会合并为一个线程，这取决于浏览器的具体实现。</li><li><strong>文件线程</strong>：负责处理与文件系统的交互，如读取和写入操作。这些操作在文件线程上执行，避免阻塞主线程。</li></ol><p>以上就是浏览器中的一些主要进程和线程。需要注意的是，不同浏览器的实现可能会有所不同，但它们的基本原理和任务分工是类似的。理解这些进程和线程之间的关系有助于我们更好地理解浏览器的运行原理，从而优化前端性能。</p><h3 id="html-解析过程"><a href="#html-解析过程" class="headerlink" title="html 解析过程"></a>html 解析过程</h3><p>HTML（超文本标记语言）是用于构建和呈现网页内容的标准标记语言。浏览器解析 HTML 的过程包括以下几个步骤：</p><ol><li>获取 HTML 文档：浏览器首先向服务器发送请求，获取 HTML 文档。服务器响应请求并返回 HTML 文件，通常是一个以<code>.html</code>或<code>.htm</code>为扩展名的文件。</li><li>词法分析：浏览器开始对 HTML 文档进行词法分析，将其分解成各种符号（tokens），例如标签、属性和文本内容。词法分析的结果是一系列 token，这些 token 有助于构建 DOM 树。</li><li>构建 DOM 树：浏览器将词法分析得到的 tokens 用于构建 DOM（文档对象模型）树。DOM 树是一种表示 HTML 文档结构的树形数据结构，其中每个节点代表页面上的一个元素、属性或文本内容。</li><li>解析 CSS：浏览器会解析与 HTML 文档关联的 CSS 样式表，包括内联样式、内部样式和外部样式。解析 CSS 样式后，浏览器会生成 CSSOM（CSS 对象模型）树，这是一种表示 CSS 样式的树形结构。</li><li>构建渲染树：浏览器将 DOM 树和 CSSOM 树合并，生成渲染树。渲染树包含了页面上可见的所有元素及其样式信息。隐藏元素（如<code>display: none;</code>）不会包含在渲染树中。</li><li>布局（Layout）：根据渲染树，浏览器计算每个元素在页面上的准确位置和大小。这个过程也被称为重排（reflow）。</li><li>绘制（Painting）：布局完成后，浏览器开始将元素绘制到屏幕上。这个过程包括绘制文本、颜色、图片、边框等视觉效果。</li><li>合成（Compositing）：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。</li></ol><p>在整个解析过程中，浏览器可能还需要处理 JavaScript 代码。JavaScript 可以通过修改 DOM 树、CSSOM 树和触发事件等方式影响页面的呈现。</p><h3 id="说一说从输入-URL-到页面呈现发生了什么"><a href="#说一说从输入-URL-到页面呈现发生了什么" class="headerlink" title="说一说从输入 URL 到页面呈现发生了什么"></a>说一说从输入 URL 到页面呈现发生了什么</h3><p>从输入 URL 到页面呈现，经历了以下几个主要步骤：</p><ol><li><p><strong>地址解析</strong>：浏览器首先解析输入的 URL，提取协议、域名、端口和路径等信息。</p></li><li><p><strong>DNS 查询</strong>：浏览器通过 DNS 查询将域名解析为 IP 地址。如果浏览器或操作系统缓存中已有相应的 DNS 记录，将直接使用缓存的结果；否则，浏览器将发送请求到 DNS 服务器进行查询。</p></li><li><p><strong>建立 TCP 连接</strong>：浏览器与目标服务器建立 TCP 连接，进行三次握手。这一步确保了数据传输的可靠性。</p></li><li><p><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求报文，包含请求头（如 User-Agent、Accept 等）和请求体（如 POST 提交的表单数据），然后通过建立的 TCP 连接将请求报文发送给服务器。</p></li><li><p><strong>服务器响应</strong>：服务器收到请求后，处理请求并生成响应报文，包含响应头（如 Content-Type、Content-Length 等）和响应体（如请求的 HTML 文件）。服务器通过 TCP 连接将响应报文发送回浏览器。</p></li><li><p><strong>浏览器接收响应</strong>：浏览器接收并解析响应报文，提取状态码、响应头和响应体等信息。</p></li><li><p><strong>解析 HTML</strong>：浏览器开始解析 HTML 文档，构建 DOM 树。遇到外部资源（如 CSS、JavaScript、图片等），浏览器会发起额外的请求获取这些资源。</p></li><li><p><strong>解析 CSS</strong>：浏览器解析 CSS 文件，构建 CSSOM 树。CSSOM 树和 DOM 树会被合并为渲染树。</p></li><li><p><strong>执行 JavaScript</strong>：浏览器解析并执行 JavaScript 代码。注意，JavaScript 的执行可能会修改 DOM 树和 CSSOM 树，从而影响渲染树的构建。</p></li><li><p><strong>构建渲染树</strong>：浏览器将 DOM 树和 CSSOM 树合并为渲染树，包含每个可见元素的布局信息。</p></li><li><p><strong>布局</strong>：浏览器根据渲染树计算每个元素的准确位置和大小，确定页面的布局。</p></li><li><p><strong>绘制</strong>：浏览器遍历渲染树，将每个元素绘制到屏幕上。</p></li><li><p><strong>合成</strong>：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。</p></li><li><p><strong>页面呈现</strong>：浏览器将渲染好的页面呈现给用户。</p></li></ol><p>总之，从输入 URL 到页面呈现，浏览器经历了一系列复杂的过程。理解这些过程有助于我们优化前端性能，提高用户体验。</p><h3 id="当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？"><a href="#当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？" class="headerlink" title="当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？"></a>当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？</h3><p>当前主要的前端渲染方式有三种：服务器端渲染（SSR）、客户端渲染（CSR）和预渲染（Prerendering）。下面分别阐述这三种渲染方式的特点及优缺点：</p><ol><li><p><strong>服务器端渲染（SSR）</strong>：</p><p>服务器端渲染指的是在服务器上将网页的 HTML、CSS 和 JavaScript 渲染成完整的 HTML 页面，然后将渲染后的页面发送给客户端。客户端接收到页面后直接展示，无需执行额外的 JavaScript。</p><ul><li>优点：<ol><li>有利于 SEO，因为搜索引擎可以直接爬取完整的 HTML 页面。</li><li>首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。</li></ol></li><li>缺点：<ol><li>服务器端压力较大，因为每次请求都需要服务器进行页面渲染。</li><li>用户交互复杂度受限，因为每次交互都可能需要重新渲染页面。</li></ol></li></ul></li><li><p><strong>客户端渲染（CSR）</strong>：</p><p>客户端渲染指的是将 HTML、CSS 和 JavaScript 发送给客户端，然后在客户端执行 JavaScript 来生成页面内容。这种方式在现代前端框架（如 React、Vue 和 Angular）中非常常见。</p><ul><li>优点：<ol><li>服务器压力较小，因为页面渲染工作由客户端完成。</li><li>用户交互体验较好，因为客户端可以实现动态的、无需刷新页面的交互。</li></ol></li><li>缺点：<ol><li>首屏加载速度较慢，因为客户端需要等待 JavaScript 执行完毕才能看到页面内容。</li><li>不利于 SEO，因为搜索引擎在爬取页面时可能无法执行 JavaScript。</li></ol></li></ul></li><li><p><strong>预渲染（Prerendering）</strong>：</p><p>预渲染是在构建过程中生成静态 HTML 文件，然后将这些静态文件部署到服务器。当用户请求页面时，服务器直接返回对应的静态 HTML 文件。这种方法适用于内容不经常变动的网站。</p><ul><li>优点：<ol><li>首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。</li><li>有利于 SEO，因为搜索引擎可以直接爬取静态 HTML 页面。</li><li>服务器压力较小，因为页面在构建过程中已经渲染完成。</li></ol></li><li>缺点：<ol><li>构建过程可能较慢，尤其是对于大型网站。</li><li>如果网站内容经常变动，需要频繁地重新构建和部署页面。</li></ol></li></ul></li></ol><p>总结：</p><p>每种渲染方式都有其优缺点，具体选择哪种方式要根据实际项目需求进行权衡。以下是一些建议：</p><ul><li>如果 SEO 对项目至关重要，而且项目内容相对稳定，则可以考虑使用预渲染或服务器端渲染。</li><li>如果项目需要提供丰富的用户交互体验，可以考虑使用客户端渲染，这样能够充分利用现代前端框架的优势。</li><li>如果项目的内容动态性较强，可以考虑使用服务器端渲染或客户端渲染。但对于客户端渲染，可能需要考虑使用服务端渲染的同构应用或者采用一些服务器端渲染辅助的技术（如 prerender.io）来提高 SEO 效果。</li><li>对于首屏加载速度有较高要求的项目，可以考虑使用服务器端渲染或预渲染。</li></ul><p>实际项目中，可以根据需求灵活地将不同渲染方式结合使用，以达到最佳的性能和用户体验。例如，可以在服务器端渲染首屏内容以提高首屏加载速度，然后在客户端渲染后续的页面内容以提供更好的交互体验。</p><h3 id="谈谈你对-Web-Workers-的理解"><a href="#谈谈你对-Web-Workers-的理解" class="headerlink" title="谈谈你对 Web Workers 的理解"></a>谈谈你对 Web Workers 的理解</h3><p>Web Workers 在浏览器中提供了一个单独的、并行的执行环境，可以运行长时间运行的脚本而不会阻塞 UI 线程。然而，这个执行环境与主 JavaScript 执行环境相比有一些限制。以下是主要的一些限制：</p><ol><li><p>无法访问 DOM：Web Workers 运行在隔离的线程中，不能直接访问网页的 DOM。任何与 UI 相关的操作都需要通过主线程完成。</p></li><li><p>无法访问全局对象：Web Workers 不能访问许多全局对象，如 <code>window</code> 对象，因为这些对象与 UI 相关或者包含与 UI 相关的功能。</p></li><li><p>无法访问某些 Web API：像 navigator.geolocation 或者 window.localStorage 这样的 Web API 无法在 Web Workers 中使用。</p></li><li><p>无法加载其他脚本：Web Workers 无法使用 <code>&lt;script&gt;</code> 标签加载其他脚本。但是，可以使用 <code>importScripts()</code> 函数来导入其他脚本。</p></li><li><p>数据传递限制：Web Workers 通过消息传递与主线程通信。这意味着所有的数据在传送时都需要被序列化和反序列化，这可能会对性能产生影响。</p></li><li><p>运行环境的限制：Web Workers 运行在不同的全局上下文中，即 <code>DedicatedWorkerGlobalScope</code>，而不是主线程的 <code>window</code>。因此，一些预期在 <code>window</code> 上下文中使用的代码在 Web Worker 中可能无法正常工作。</p></li></ol><p>总的来说，Web Workers 是设计用于执行计算密集型或者长时间运行的任务，而非操作 UI 或者处理与 UI 相关的逻辑。对于需要与 UI 交互的操作，仍然需要在主线程中完成。</p><h3 id="谈谈你对-V8-垃圾回收的理解？"><a href="#谈谈你对-V8-垃圾回收的理解？" class="headerlink" title="谈谈你对 V8 垃圾回收的理解？"></a>谈谈你对 V8 垃圾回收的理解？</h3><p>V8 引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。</p><ol><li>分代收集：V8 将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用 Scavenge 算法进行垃圾回收，通常采用 Cheney 算法，将内存分为两个半区（From Space 和 To Space），每次垃圾回收时，会将存活的对象复制到 To Space 中，并清空 From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。</li><li>增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8 采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript 程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。</li></ol><p>V8 垃圾回收是对 JavaScript 垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。</p><h3 id="如何优化和减少垃圾回收的影响，从而提高应用性能？"><a href="#如何优化和减少垃圾回收的影响，从而提高应用性能？" class="headerlink" title="如何优化和减少垃圾回收的影响，从而提高应用性能？"></a>如何优化和减少垃圾回收的影响，从而提高应用性能？</h3><p>以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：</p><ol><li><strong>避免全局变量</strong>：全局变量不会被垃圾回收，除非它们被设置为 <code>null</code>。只有在确实需要时才应该使用它们。</li><li><strong>使用对象池</strong>：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。</li><li><strong>小心闭包</strong>：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。</li><li><strong>手动释放大对象</strong>：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 <code>null</code>，从而提前提示垃圾回收器。</li><li><strong>避免循环引用</strong>：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。</li><li><strong>使用弱引用</strong>：在合适的场景下，使用 <code>WeakMap</code> 或 <code>WeakSet</code> 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。</li><li><strong>优化事件监听器</strong>：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。</li><li><strong>减少内存分配</strong>：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。</li><li><strong>使用浏览器开发者工具</strong>：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。</li><li><strong>考虑使用 WebAssembly</strong>：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。</li></ol><hr /><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="谈谈你对-OSI-模型的理解"><a href="#谈谈你对-OSI-模型的理解" class="headerlink" title="谈谈你对 OSI 模型的理解"></a>谈谈你对 OSI 模型的理解</h3><p>OSI（开放式系统互联）模型是一个用于描述计算机网络协议的七层参考模型。它是 ISO（国际标准化组织）在 20 世纪 80 年代提出的，旨在促进不同类型的计算机和网络系统之间的互通性和互操作性。OSI 模型可以帮助我们更好地理解网络通信过程中的各个步骤，以及如何在这些步骤中组织和使用各种协议。</p><p>OSI 模型从下到上共有 7 层，每一层都有特定的职责，它们分别是：</p><ol><li>物理层（Physical Layer）：这一层负责处理与传输介质（如电缆、光纤）有关的硬件方面的问题，包括比特（0 和 1）的传输、电压、接口等。物理层的主要目标是确保数据在传输过程中的完整性和可靠性。</li><li>数据链路层（Data Link Layer）：数据链路层负责在网络节点之间建立、维护和拆除数据链路。它将物理层传输的比特组合成帧（frame），同时负责错误检测和流量控制。典型的数据链路层协议有以太网（Ethernet）、Wi-Fi 和 PPP（点对点协议）等。</li><li>网络层（Network Layer）：网络层负责将数据包（packet）从源节点路由到目标节点。它处理 IP 地址、路由选择、分片和重组等问题。网络层的主要协议有 IP（互联网协议）、ICMP（互联网控制消息协议）等。</li><li>传输层（Transport Layer）：传输层负责在源端和目标端之间提供端到端（end-to-end）的数据传输服务。它处理数据的分段、重组、流量控制、错误检测和校正等问题。常见的传输层协议有 TCP（传输控制协议）和 UDP（用户数据报协议）。</li><li>会话层（Session Layer）：会话层负责在通信双方之间建立、管理和终止会话。会话层的主要职责是维护会话状态、同步数据流和进行恢复操作。尽管 OSI 模型中包含了会话层，但在实际的互联网协议中，很多功能已经与其他层次结合在一起，例如 TCP 协议。</li><li>表示层（Presentation Layer）：表示层负责处理数据的表示、编码和解码，以便在不同系统之间进行交换。这包括数据压缩、加密和字符集转换等等功能。表示层的一个典型例子是 SSL&#x2F;TLS 协议，它在应用层协议（如 HTTP）之下提供数据加密和解密服务。然而，在现代网络协议中，表示层的很多功能通常直接集成在应用层协议中，如 JSON、XML 等数据格式。</li><li>应用层（Application Layer）：应用层是 OSI 模型中最高层，它负责处理用户与网络之间的交互，提供面向用户的服务。应用层协议定义了各种应用程序如何与网络进行通信，例如发送电子邮件、浏览网页等。常见的应用层协议包括 HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等。</li></ol><p>OSI 模型的一个重要优点是它将网络功能划分为若干模块化的层次，每个层次都有明确的职责。这种分层架构有助于降低网络设计和实现的复杂性，同时还有利于对现有协议的改进和替换，以适应不断变化的技术需求。</p><p>然而，需要注意的是，OSI 模型主要是一个理论框架，用于帮助我们更好地理解网络协议的组织和交互。实际上，许多现代网络协议并不完全遵循 OSI 模型的严格分层结构，而是采用更灵活的混合模式。例如，TCP&#x2F;IP 模型是互联网中最常用的网络协议体系，它将 OSI 模型的 7 层合并为 4 层（应用层、传输层、网络层和链路层）。尽管如此，OSI 模型仍然是一个有用的概念工具，可以帮助我们更好地理解复杂的计算机网络。</p><h3 id="什么是-HTTP，它的用途是什么？"><a href="#什么是-HTTP，它的用途是什么？" class="headerlink" title="什么是 HTTP，它的用途是什么？"></a>什么是 HTTP，它的用途是什么？</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于在互联网上进行数据通信的应用层协议。它基于 TCP&#x2F;IP 协议栈工作，通常使用 TCP 作为传输层协议。HTTP 的主要作用是规定了客户端（例如浏览器）和服务器之间的请求和响应的格式与规则，从而实现数据的交换。</p><p>HTTP 的主要用途是：</p><ol><li><strong>资源获取</strong>：客户端可以通过 HTTP 向服务器发送请求，获取 HTML、CSS、JavaScript、图片、视频等各种资源，以便呈现和运行网页或其他应用。</li><li><strong>数据提交</strong>：客户端可以通过 HTTP 将数据提交给服务器，例如表单提交、文件上传等。</li><li><strong>API 交互</strong>：客户端和服务器可以通过 HTTP 进行 API 交互，以便在前后端之间传递数据。常见的数据格式包括 JSON 和 XML。</li></ol><p>HTTP 协议的特点：</p><ol><li><strong>无状态</strong>：HTTP 是无状态的，意味着服务器不会存储与客户端之间交互的信息。为了实现有状态的会话，可以使用 Cookie 和 Session 等技术。</li><li><strong>简单快速</strong>：HTTP 协议简单，易于实现。客户端和服务器之间的请求和响应报文格式统一，便于解析和处理。</li><li><strong>可扩展</strong>：HTTP 允许自定义请求头和响应头，可以根据需要扩展协议的功能。</li><li><strong>明文传输</strong>：HTTP 协议本身不提供数据加密功能，所有数据以明文形式传输。为了提高数据安全性，可以使用 HTTPS（HTTP Secure，基于 SSL&#x2F;TLS 的 HTTP）进行加密传输。</li></ol><p>HTTP 协议包括一系列请求方法（如 GET、POST、PUT、DELETE 等），用于指定请求的类型和目的。此外，HTTP 协议还定义了一系列状态码，用于表示请求的结果和相关信息。</p><h3 id="TCP-中三次握手和四次挥手的含义"><a href="#TCP-中三次握手和四次挥手的含义" class="headerlink" title="TCP 中三次握手和四次挥手的含义"></a>TCP 中三次握手和四次挥手的含义</h3><p>在 TCP（传输控制协议）中，三次握手和四次挥手是用来建立和终止连接的重要过程。下面分别解释它们的含义：</p><p><strong>三次握手（Three-Way Handshake）</strong>：</p><p>三次握手是建立 TCP 连接的过程，确保数据传输的可靠性和连接的双向通信。这个过程包含三个步骤：</p><ol><li>客户端向服务器发送一个 SYN（同步）报文，表示客户端希望建立连接。报文中包含一个随机生成的序列号（Sequence Number）。</li><li>服务器收到 SYN 报文后，回复一个 SYN+ACK（同步确认）报文，其中 ACK 的值为客户端序列号加一。同时，服务器也会发送一个自己的随机序列号。</li><li>客户端收到 SYN+ACK 报文后，发送一个 ACK（确认）报文给服务器，其中 ACK 的值为服务器序列号加一。</li></ol><p>完成这三个步骤后，客户端和服务器之间的 TCP 连接就建立好了，可以进行双向通信。</p><p><strong>四次挥手（Four-Way Handshake）</strong>：</p><p>四次挥手是终止 TCP 连接的过程。当数据传输完成后，客户端和服务器需要通过四次挥手来关闭连接。这个过程包含四个步骤：</p><ol><li>客户端发送一个 FIN（完成）报文给服务器，表示客户端已完成数据发送。</li><li>服务器收到 FIN 报文后，回复一个 ACK（确认）报文给客户端，表示已收到客户端的关闭请求。此时，客户端到服务器的连接被关闭，但服务器到客户端的连接仍然存在。</li><li>当服务器完成数据发送后，也会发送一个 FIN 报文给客户端，表示服务器准备关闭连接。</li><li>客户端收到服务器的 FIN 报文后，回复一个 ACK 报文给服务器，表示已收到服务器的关闭请求。经过一段时间（通常为 2MSL，即最长报文段寿命的两倍）后，客户端关闭与服务器的连接。</li></ol><p>完成这四个步骤后，客户端和服务器之间的 TCP 连接就被完全关闭了。</p><h3 id="TCP-提供了什么服务？"><a href="#TCP-提供了什么服务？" class="headerlink" title="TCP 提供了什么服务？"></a>TCP 提供了什么服务？</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它为应用程序之间提供可靠的数据传输服务。TCP 在 Internet 协议族中被广泛应用，与网络层协议 IP（Internet Protocol）共同组成 TCP&#x2F;IP 协议簇。</p><p>TCP 提供的服务包括：</p><ol><li>面向连接：TCP 在数据传输前建立一个连接。连接的建立、维护和终止都由 TCP 管理。这种面向连接的方式使得 TCP 适用于需要可靠通信的应用。</li><li>可靠传输：TCP 通过使用确认机制、重传机制和错误校验来确保数据的可靠传输。如果数据包丢失或损坏，TCP 会自动重发数据包，从而保证数据的完整性和正确性。</li><li>流量控制：TCP 使用滑动窗口机制来实现流量控制，确保接收方的缓冲区不会被发送方的数据溢出。这样，发送方和接收方可以根据自身处理能力和网络状况动态调整传输速率，提高传输效率。</li><li>拥塞控制：为了防止网络拥塞，TCP 使用拥塞控制算法来调整发送数据的速率。当网络出现拥塞时，TCP 会减少发送速率，避免网络拥塞进一步恶化。当网络恢复正常时，TCP 会逐渐提高发送速率。</li><li>数据排序：TCP 会为每个数据包分配一个序号，接收方可以根据序号重新组合数据包，从而确保数据按正确顺序传输。</li><li>复用与分用：TCP 允许多个应用程序在同一台主机上通过不同的端口共享网络资源。这意味着多个应用程序可以在同一时间使用 TCP 进行数据传输，而不会互相干扰。</li></ol><h3 id="SSL-x2F-TLS-是如何握手的？"><a href="#SSL-x2F-TLS-是如何握手的？" class="headerlink" title="SSL&#x2F;TLS 是如何握手的？"></a>SSL&#x2F;TLS 是如何握手的？</h3><p>SSL（安全套接层）和 TLS（传输层安全）协议用于在互联网上建立安全的、加密的通信连接。尽管 TLS 是 SSL 的后续版本，但在实际用语中，它们经常互换使用。TLS 握手过程可以分为以下几个步骤：</p><ol><li>客户端发起连接：客户端（例如，浏览器）向服务器发起一个安全连接请求。这个请求包括客户端支持的 TLS 版本、支持的加密套件（加密算法和密钥交换方法的组合）以及一个随机数（ClientHello 随机数）。</li><li>服务器响应：服务器从客户端提供的加密套件列表中选择一个加密套件，并向客户端返回服务器的证书（包含公钥和服务器身份信息）、选择的 TLS 版本和加密套件，以及一个随机数（ServerHello 随机数）。此外，如果需要客户端身份验证，服务器还会请求客户端的证书。</li><li>证书验证：客户端验证服务器证书的有效性。证书应由受信任的证书颁发机构（CA）签名。这一步的目的是确保与客户端通信的服务器是可信的，防止中间人攻击。</li><li>密钥交换：客户端使用服务器证书中的公钥加密一个新的随机数（称为 Pre-Master Secret），并将其发送给服务器。服务器使用其私钥解密 Pre-Master Secret。然后，客户端和服务器分别使用 ClientHello 随机数、ServerHello 随机数和 Pre-Master Secret，通过一个伪随机函数生成主密钥（Master Secret）。这个主密钥将用于之后的对称加密和解密操作。</li><li>客户端和服务器协商参数：客户端和服务器根据主密钥生成一组加密参数（例如，对称密钥、初始化向量、消息验证码等），这些参数将用于保护后续的数据传输。</li><li>客户端和服务器验证握手过程：客户端发送一个加密的 Finished 消息，服务器解密并验证消息的完整性。服务器也发送一个加密的 Finished 消息，客户端解密并验证。这一步的目的是确保双方已正确完成密钥交换和参数协商。</li><li>加密数据传输：完成握手过程后，客户端和服务器使用协商的加密参数进行安全的数据传输。此时，所有传输的数据都是加密的，以确保其机密性和完整性。</li></ol><p>TLS 握手过程旨在在客户端和服务器之间建立一个安全、加密的通信通道，以保护数据在互联网上的传输。</p><h3 id="数字证书里面主要包含什么信息？"><a href="#数字证书里面主要包含什么信息？" class="headerlink" title="数字证书里面主要包含什么信息？"></a>数字证书里面主要包含什么信息？</h3><p>数字证书，通常用于 SSL&#x2F;TLS 通信和其他加密场景，是一个电子文档，用于证明公钥的所有权和身份。数字证书通常由认证机构 (CA) 签署。以下是数字证书中主要的包含的信息：</p><ol><li><p><strong>主体信息（Subject）</strong>：</p><ul><li><strong>公钥（Public Key）</strong>：该证书对应的公钥。</li><li><strong>主体的名称（Subject Name）</strong>：通常为网站的域名或组织的名称。</li><li><strong>组织名称（Organization Name）</strong>：证书持有者的组织或公司名称（例如，”OpenAI Inc.”）。</li><li><strong>组织单位（Organizational Unit, OU）</strong>：组织内的特定部门或单位。</li><li><strong>地理位置信息</strong>：如国家（Country）、州&#x2F;省（State&#x2F;Province）、城市（Locality）等。</li></ul></li><li><p><strong>颁发者信息（Issuer）</strong>：</p><ul><li><strong>颁发者名称（Issuer Name）</strong>：签发该证书的证书认证机构 (CA) 的名称。</li><li>和主体类似，可能还包括组织名称、组织单位、国家等信息。</li></ul></li><li><p><strong>有效期（Validity Period）</strong>：</p><ul><li><strong>开始日期（Not Before）</strong>：证书的有效开始日期。</li><li><strong>结束日期（Not After）</strong>：证书的过期日期。</li></ul></li><li><p><strong>序列号（Serial Number）</strong>：颁发者给证书分配的唯一编号，用于识别。</p></li><li><p><strong>签名算法（Signature Algorithm）</strong>：用于签署此证书的算法（如 RSA、ECDSA 或其他）。</p></li><li><p><strong>证书签名（Signature）</strong>：CA 使用其私钥生成的证书的数字签名。这使得其他人可以使用 CA 的公钥来验证证书的真实性和完整性。</p></li><li><p><strong>扩展和约束（Extensions and Constraints）</strong>：这些是可选的，但在许多证书中都有。它们为证书提供了额外的属性和规则。例如：</p><ul><li><strong>Key Usage</strong>：描述公钥可以用于什么（例如，数据加密、数字签名等）。</li><li><strong>Extended Key Usage</strong>：进一步详细说明公钥的使用，如服务器身份验证、客户端身份验证等。</li><li>**Subject Alternative Name (SAN)**：除主体名称外，其他有效的名称（通常用于多域名或通配符证书）。</li><li><strong>Certificate Policies</strong>：关于证书如何使用和 CA 如何管理证书的策略。</li></ul></li><li><p><strong>版本（Version）</strong>：证书的版本号。目前，最常见的版本是 v3。</p></li></ol><p>当客户端（例如，web 浏览器）接收到数字证书时，它会使用相关 CA 的公钥来验证证书的签名，从而验证证书的真实性。此过程有助于确保在网络上进行的通信是安全和加密的。</p><h3 id="Websocket-与-Ajax-的区别？"><a href="#Websocket-与-Ajax-的区别？" class="headerlink" title="Websocket 与 Ajax 的区别？"></a>Websocket 与 Ajax 的区别？</h3><p>WebSocket 和 Ajax 是两种不同的 Web 技术，它们在实现客户端与服务器之间通信时有一些区别。以下是它们之间的主要区别：</p><ol><li><strong>连接方式</strong>：<ul><li>WebSocket：WebSocket 是一种全双工通信协议，建立连接后，客户端和服务器之间可以同时进行数据发送和接收。WebSocket 连接在建立后会保持连接状态，直至显式断开连接。</li><li>Ajax：Ajax（Asynchronous JavaScript and XML）是一种基于 HTTP 协议的异步请求技术。每次 Ajax 请求都需要建立一个新的 HTTP 连接，请求完成后连接会被关闭。因此，Ajax 是一种基于请求-响应模式的半双工通信方式。</li></ul></li><li><strong>实时性</strong>：<ul><li>WebSocket：由于 WebSocket 是全双工通信，服务器可以在任何时候主动向客户端发送数据，因此实时性较强，适用于实时通信、在线游戏等场景。</li><li>Ajax：由于 Ajax 基于请求-响应模式，服务器不能主动向客户端发送数据，客户端需要定期发起请求以获取更新。因此，实时性相对较弱，适用于非实时的数据获取和更新。</li></ul></li><li><strong>开销和性能</strong>：<ul><li>WebSocket：WebSocket 在建立连接后会保持连接状态，因此减少了频繁建立和断开连接的开销。同时，WebSocket 使用自己的二进制分帧格式进行数据传输，帧头较小，数据传输效率较高。</li><li>Ajax：每次 Ajax 请求都需要建立新的 HTTP 连接，这会导致一定的性能开销。另外，HTTP 协议的请求和响应头部较大，相对降低了数据传输效率。</li></ul></li></ol><p>总结：WebSocket 适用于实时性要求较高、需要双向通信的场景，而 Ajax 更适用于传统的 Web 应用，用于获取和更新数据。根据实际应用需求，可以选择合适的技术进行通信。</p><h3 id="HTTP1-0、HTTP1-1、HTTP2-0-之间有什么区别"><a href="#HTTP1-0、HTTP1-1、HTTP2-0-之间有什么区别" class="headerlink" title="HTTP1.0、HTTP1.1、HTTP2.0 之间有什么区别"></a>HTTP1.0、HTTP1.1、HTTP2.0 之间有什么区别</h3><ol><li><p><strong>HTTP&#x2F;1.0</strong>:</p><ul><li><strong>无连接</strong>：每个 HTTP 请求打开一个新的连接，请求结束后立即关闭连接。</li><li><strong>无状态</strong>：每个请求都是独立的，服务器不保存之前的请求信息。</li><li><strong>缓存</strong>：使用简单的 <code>Pragma: no-cache</code> 来避免缓存。</li></ul></li><li><p><strong>HTTP&#x2F;1.1</strong>:</p><ul><li><strong>长连接</strong>：引入了持久连接，这意味着多个 HTTP 请求和响应可以在一个连接中连续发送，避免了为每个请求都建立新连接的开销。这是通过 <code>Connection: keep-alive</code> 头来实现的。</li><li><strong>管线化</strong>：请求可以同时被发送，但是服务器必须按照它们接收到的顺序来逐一响应。</li><li><strong>缓存控制</strong>：更加详细和精确的缓存头，如 <code>Cache-Control</code>，提供了更好的缓存管理。</li><li><strong>主机头的要求</strong>：允许多个域名解析到同一 IP 地址，从而使虚拟主机成为可能。</li><li><strong>错误通知</strong>：增加了更多的状态码和更丰富的错误信息。</li></ul></li><li><p><strong>HTTP&#x2F;2</strong>:</p><ul><li><strong>二进制协议</strong>：不再是像 HTTP&#x2F;1.x 那样的文本协议，而是一个二进制协议。这使得协议的解析、网络传输更高效。</li><li><strong>多路复用</strong>：允许多个请求和响应在一个连接上同时并行交换，解决了 HTTP&#x2F;1.1 中的“线头阻塞”问题。</li><li><strong>优先级和权重</strong>：可以为请求设置优先级和权重，使得重要的请求得到更快的响应。</li><li><strong>服务器推送</strong>：服务器可以对客户端“推送”资源，即使客户端尚未请求。</li><li><strong>首部压缩</strong>：使用 HPACK 压缩，减少了请求和响应的大小。</li><li><strong>更强的流控制</strong>：为每一个流提供了流控制机制。</li></ul></li></ol><h3 id="HTTP-x2F-2-相比-HTTP-x2F-1-1-新增了什么"><a href="#HTTP-x2F-2-相比-HTTP-x2F-1-1-新增了什么" class="headerlink" title="HTTP&#x2F;2 相比 HTTP&#x2F;1.1 新增了什么"></a>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 新增了什么</h3><p>HTTP&#x2F;2 是 HTTP&#x2F;1.1 的升级版本，旨在解决 HTTP&#x2F;1.1 中的一些性能问题，提高网络传输的效率。HTTP&#x2F;2 相比于 HTTP&#x2F;1.1 主要有以下新增特性：</p><ol><li><strong>二进制分帧</strong>：HTTP&#x2F;2 将数据以二进制格式进行传输，请求和响应被分解为更小的帧，每个帧有自己的类型和标识符。这使得数据传输更加高效，易于解析。</li><li><strong>多路复用</strong>：HTTP&#x2F;2 允许在同一个 TCP 连接上同时发送和接收多个请求和响应，避免了 HTTP&#x2F;1.1 中的队头阻塞问题。这样可以提高页面加载速度，减少网络延迟。</li><li><strong>头部压缩</strong>：HTTP&#x2F;2 使用 HPACK 压缩算法对请求和响应头部进行压缩，减小了传输数据的大小，从而降低了传输延迟。</li><li><strong>服务器推送</strong>：HTTP&#x2F;2 服务器可以主动将一些尚未被客户端请求的资源推送给客户端，以便客户端在需要时立即使用，提高了资源加载速度。</li></ol><h3 id="HTTP-x2F-3-相比-HTTP-x2F-2-解决了哪些问题？"><a href="#HTTP-x2F-3-相比-HTTP-x2F-2-解决了哪些问题？" class="headerlink" title="HTTP&#x2F;3 相比 HTTP&#x2F;2 解决了哪些问题？"></a>HTTP&#x2F;3 相比 HTTP&#x2F;2 解决了哪些问题？</h3><p>HTTP&#x2F;3 是互联网工程任务组（IETF）制定的新一代 HTTP（超文本传输协议）标准，它基于 QUIC 协议（快速 UDP 互联网连接），旨在解决 HTTP&#x2F;2 存在的一些问题，提高网络性能和安全性。相较于 HTTP&#x2F;2，HTTP&#x2F;3 主要解决了以下问题：</p><ol><li>首部阻塞（Head-of-line blocking）：在 HTTP&#x2F;2 中，多个请求和响应通过同一个 TCP 连接进行多路复用。由于 TCP 是面向连接的、可靠的传输协议，要求数据按顺序到达，当其中一个数据包丢失或延迟时，整个连接的其他数据包必须等待，直到丢失的数据包被重新传输并到达。这种现象被称为首部阻塞。HTTP&#x2F;3 采用基于 UDP 的 QUIC 协议，它允许单独处理每个数据流，从而消除了首部阻塞问题。</li><li>连接建立延迟：HTTP&#x2F;2 在建立 TCP 连接之后，还需要通过 TLS 握手建立安全连接。这意味着需要多次往返才能完成连接建立。而 HTTP&#x2F;3 使用 QUIC 协议，它将传输层（TCP）和安全层（TLS）整合在一起，从而减少了连接建立所需的往返次数。对于已经与服务器建立过连接的客户端，QUIC 甚至可以实现 0-RTT（零往返时间）连接建立，大幅降低了延迟。</li><li>更好的网络路径迁移：当客户端或服务器的 IP 地址发生变化时（如移动设备在 Wi-Fi 和移动网络之间切换），TCP 连接可能中断，需要重新建立。HTTP&#x2F;3 的 QUIC 协议提供了内置的连接迁移特性，允许在 IP 地址变化时保持连接状态，减少中断和延迟。</li><li>拥塞控制和恢复：由于 HTTP&#x2F;3 使用 QUIC 协议，它可以在单独的数据流上实现更细粒度的拥塞控制。这意味着当一个数据流受到网络拥塞影响时，其他数据流可以继续正常传输，不受影响。同时，QUIC 采用了更先进的丢包恢复机制，使得数据传输更加高效和可靠。</li></ol><p>尽管 HTTP&#x2F;3 有很多优势，但它目前仍在逐步推广和普及。浏览器和服务器需要支持 QUIC 协议，以便充分利用 HTTP&#x2F;3 带来的改进。</p><h3 id="GET-和-POST-请求的区别是什么？"><a href="#GET-和-POST-请求的区别是什么？" class="headerlink" title="GET 和 POST 请求的区别是什么？"></a>GET 和 POST 请求的区别是什么？</h3><p>GET 和 POST 是 HTTP 协议中最常见的两种请求方法，它们之间的主要区别包括：</p><ol><li><p><strong>请求参数的传递方式不同</strong>：</p><ul><li>GET 请求的参数被附加到 URL 之后，以键值对的形式出现，各参数之间以&amp;符号分割，如<code>http://example.com/page?param1=value1&amp;param2=value2</code>。</li><li>POST 请求的参数存储在请求体（Request Body）中。</li></ul></li><li><p><strong>数据大小的限制不同</strong>：</p><ul><li>GET 由于受 URL 长度限制，所以能传递的参数量相对有限。</li><li>POST 请求由于参数在请求体中，理论上数据量没有限制，但实际上大小会受到 WEB 服务器的限制。</li></ul></li><li><p><strong>安全性不同</strong>：</p><ul><li>GET 请求的参数直接被包含在 URL 中，数据暴露给了用户，安全性较低，因此不适合传递敏感信息。</li><li>POST 请求的参数在请求体中，用户无法在地址栏看到，安全性相对较高。</li></ul></li><li><p><strong>可缓存</strong>：</p><ul><li>GET 请求的结果通常可以被浏览器或代理服务器缓存。</li><li>POST 请求的结果则通常不被缓存。</li></ul></li><li><p><strong>幂等性和副作用</strong>：</p><ul><li>GET 是幂等的，也就是说，无论调用一次还是多次，产生的效果是相同的。</li><li>POST 不是幂等的，每次请求都可能导致不同的结果。</li></ul></li><li><p><strong>请求的用途</strong>：</p><ul><li>GET 通常用于请求服务器数据，例如网页浏览、图片加载等。</li><li>POST 通常用于提交数据给服务器，例如表单提交、文件上传等。</li></ul></li></ol><p>虽然 GET 和 POST 是最常见的 HTTP 请求方法，但 HTTP 协议还定义了其他一些请求方法，如 PUT、DELETE、PATCH、HEAD 等，每种方法都有其特定的用途和语义。</p><h3 id="TCP-与-UDP-有什么区别？"><a href="#TCP-与-UDP-有什么区别？" class="headerlink" title="TCP 与 UDP 有什么区别？"></a>TCP 与 UDP 有什么区别？</h3><p>TCP（传输控制协议）和 UDP（用户数据报协议）是互联网协议套件的两个主要协议，它们用于不同类型的网络服务，并具有各自的特点和用途。以下是它们的主要区别：</p><ol><li><p><strong>连接类型</strong>：</p><ul><li>TCP 是一种面向连接的协议，这意味着在数据交换之前，必须首先建立连接。一旦建立了连接，就会保持开放状态，直到所有数据传输完毕。TCP 使用的是可靠的通信通道，确保数据的完整性和顺序。</li><li>UDP 是一种无连接的协议，这意味着它不需要在发送数据之前建立连接。因此，UDP 的通信通道是不可靠的，无法保证数据的完整性和顺序。</li></ul></li><li><p><strong>速度和可靠性</strong>：</p><ul><li>TCP 提供了一种可靠的数据传输方法，通过校验和、序列号、确认应答、重传机制和拥塞控制等机制，确保数据在网络中的正确无误的传输。但这些特性使得 TCP 相比 UDP 来说速度较慢。</li><li>UDP 不提供数据可靠性，它只是简单地发送数据，不进行错误检查或数据恢复。这意味着如果网络出现问题，数据可能会丢失。但由于缺少了这些额外的特性，UDP 的速度通常比 TCP 快。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>TCP 常用于需要高可靠性的应用，如 Web 浏览器、电子邮件服务、文件传输等。</li><li>UDP 常用于对实时性要求较高、可接受一些数据丢失的应用，如流媒体、在线游戏和 VoIP（网络电话）。</li></ul></li><li><p><strong>报头长度</strong>：</p><ul><li>TCP 的报头长度更长，最小为 20 字节，因为它包含了许多控制信息（如序列号和确认号）。</li><li>UDP 的报头长度较短，只有 8 字节，因为它只提供基本的功能。</li></ul></li><li><p><strong>流量控制和拥塞控制</strong>：</p><ul><li>TCP 有内置的流量控制和拥塞控制机制，这使得 TCP 可以在网络繁忙时降低数据发送速度，以防止数据丢失。</li><li>UDP 没有这些控制机制，所以在网络繁忙时可能会导致大量数据丢失。</li></ul></li></ol><p>总的来说，TCP 和 UDP 都有它们各自的优势和使用场景。选择使用哪一个协议取决于特定的应用需求，如需要可靠性还是速度，以及对数据丢失的容忍度。</p><h3 id="常见的-API-设计规范有哪些？"><a href="#常见的-API-设计规范有哪些？" class="headerlink" title="常见的 API 设计规范有哪些？"></a>常见的 API 设计规范有哪些？</h3><p>确实，RESTful 是 API 设计中的一种非常流行的设计风格，但并非唯一的设计规范。除了 RESTful 之外，还有一些其他的 API 设计规范和架构风格，包括：</p><ol><li>**REST (Representational State Transfer)**：REST 是一种软件架构风格，通常用于设计网络应用程序。RESTful API 遵循一组约定，如使用 HTTP 方法（GET，POST，PUT，DELETE 等），使用路径来表示资源，并在可能的情况下，使用 HTTP 状态代码来表示错误。RESTful API 通常使用 JSON 进行数据传输。</li><li><strong>GraphQL</strong>：GraphQL 是一个开源的数据查询和操作语言，同时也是一个运行时系统，用于现有数据的查询。与 REST 不同，GraphQL 允许客户端精确地获取它需要的数据，而无需获取额外的信息。这可以帮助解决 RESTful 设计中的过度获取和信息获取不足的问题。</li><li><strong>gRPC</strong>：gRPC 是一个高性能、开源的通用 RPC 框架，它由 Google 开发。gRPC 提供了一种简单的方法来定义服务：客户端应用程序可以直接在服务器上调用方法，就像是本地对象一样，而不用考虑底层的网络通信细节。</li><li><strong>JSON-RPC 和 XML-RPC</strong>：这两种都是远程过程调用(RPC)规范，它们允许在网络上的一台计算机（客户端）调用另一台计算机（服务器）上的方法或过程。JSON-RPC 使用 JSON 来编码数据，而 XML-RPC 使用 XML 来编码数据。</li><li>**OData (Open Data Protocol)**：OData 是一个用于构建和消费 RESTful API 的开放标准。使用 OData，你可以通过简单的 HTTP 请求进行查询和操作数据。</li><li><strong>SOAP</strong>：SOAP 是一种基于 XML 的消息协议，用于在 web 服务中交换结构化的信息。SOAP 可以与各种通信协议一起使用，包括 HTTP、SMTP 等。</li></ol><p>以上都是常见的 API 设计规范和架构风格，每种都有其特点和用途，设计 API 时应根据具体需求和场景进行选择。</p><h3 id="哪些协议底层使用-UDP？"><a href="#哪些协议底层使用-UDP？" class="headerlink" title="哪些协议底层使用 UDP？"></a>哪些协议底层使用 UDP？</h3><p>UDP（用户数据报协议）是一种无连接的网络通信协议，它不保证数据报的交付、顺序或校验，从而在通信速度和网络效率上优于 TCP。以下是一些在底层使用 UDP 的协议：</p><ol><li><p><strong>DNS (域名系统)</strong>: DNS 用于将互联网域名解析为 IP 地址。由于解析请求必须尽快完成，通常使用 UDP 作为传输协议。</p></li><li><p><strong>DHCP (动态主机配置协议)</strong>: DHCP 是一种网络协议，用于在网络上动态分配 IP 地址。因为 DHCP 请求需要快速处理，所以通常使用 UDP。</p></li><li><p><strong>RTP (实时传输协议)</strong>: RTP 用于实时传输音频和视频数据。RTP 通常与 RTCP (RTP 控制协议)一起使用，用于媒体流的同步和质量反馈。RTP 使用 UDP，因为对于实时媒体流来说，速度和效率比确保每个包的交付更重要。</p></li><li><p><strong>SNMP (简单网络管理协议)</strong>: SNMP 用于管理和监控网络设备。SNMP 消息需要快速发送并响应，因此使用 UDP。</p></li><li><p><strong>NTP (网络时间协议)</strong>: NTP 用于在网络中同步时钟。NTP 消息需要快速交付，所以通常使用 UDP。</p></li><li><p><strong>QUIC (快速 UDP 互联网连接)</strong>: QUIC 是一种多路复用的传输层协议，用于在 HTTP&#x2F;3 中替代 TCP。QUIC 使用 UDP，以减少连接和重新传输的延迟。</p></li><li><p><strong>VoIP (语音 over IP)</strong>: VoIP 技术，如 Skype 和一些其他的互联网电话应用，使用 UDP 进行音频数据传输，因为它们更关心实时性，而不是数据的完整性。</p></li></ol><h3 id="HTTP-中，get、post、put、delete-有什么区别？"><a href="#HTTP-中，get、post、put、delete-有什么区别？" class="headerlink" title="HTTP 中，get、post、put、delete 有什么区别？"></a>HTTP 中，get、post、put、delete 有什么区别？</h3><p>HTTP 中的 GET、POST、PUT、DELETE 是四种常见的 HTTP 方法（也称为“动词”），它们各自代表了不同的操作，通常用于 RESTful Web 服务中。以下是这四种方法的基本区别：</p><ol><li><p><strong>GET</strong>：</p><ul><li>用途：获取资源信息。</li><li>安全性：GET 是安全的，这意味着它只是获取信息并不改变资源状态。</li><li>幂等性：GET 是幂等的，这意味着多次执行同一 GET 请求，结果都是一样的。</li><li>数据传输：参数包含在 URL 中，因此数据量有限，并且可能被记录在日志中。</li><li>缓存：GET 请求的响应是可以被缓存的。</li><li>示例：访问一个网页或获取某个项目的详细信息。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>用途：提交数据并创建新资源。</li><li>安全性：POST 不是安全的，因为它可能改变资源的状态。</li><li>幂等性：POST 不是幂等的，因为重复发送同一个 POST 请求可能会有不同的效果（例如，重复创建相同的资源）。</li><li>数据传输：参数不在 URL 中，而是在请求体中。因此，可以发送大量的数据。</li><li>示例：填写并提交一个表单。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>用途：更新现有资源或创建新资源。</li><li>安全性：PUT 不是安全的。</li><li>幂等性：PUT 是幂等的，重复执行同一 PUT 请求应该总是产生相同的结果。</li><li>数据传输：数据在请求体中。</li><li>示例：更新一个项目的详细信息。</li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li>用途：删除资源。</li><li>安全性：DELETE 不是安全的。</li><li>幂等性：DELETE 是幂等的，因为无论删除多少次，资源都已经被删除。</li><li>数据传输：通常不带请求体，资源标识通常在 URL 中。</li><li>示例：删除一个项目。</li></ul></li></ol><hr /><h2 id="MVVM-框架"><a href="#MVVM-框架" class="headerlink" title="MVVM 框架"></a>MVVM 框架</h2><h3 id="为什么-data-在组件内必须是函数，而-vue-的根实例则没有此限制？"><a href="#为什么-data-在组件内必须是函数，而-vue-的根实例则没有此限制？" class="headerlink" title="为什么 data 在组件内必须是函数，而 vue 的根实例则没有此限制？"></a>为什么 data 在组件内必须是函数，而 vue 的根实例则没有此限制？</h3><p>在 Vue 组件中，<code>data</code> 必须是一个函数，因为组件可能会被多次实例化。如果 <code>data</code> 是一个对象，那么所有组件实例将共享相同的数据对象。这样一来，当一个组件实例修改了数据时，所有其他实例的数据也会被更改，这是我们不希望看到的。使用函数可以确保每次实例化组件时，都会返回一个全新的数据对象副本，从而保证组件实例之间的数据隔离。</p><p>在 Vue 的根实例中，这个限制并不适用。根实例只会被创建一次，因此不需要担心多个实例共享相同的数据对象。然而，将 <code>data</code> 作为函数返回对象的方式也是可以在根实例中使用的，这样可以保持一致性。但在实际开发中，为了简便，我们通常在根实例中直接使用对象作为 <code>data</code>。</p><h3 id="vue2-中选项-props、data、method、computed、watch-的优先级？"><a href="#vue2-中选项-props、data、method、computed、watch-的优先级？" class="headerlink" title="vue2 中选项 props、data、method、computed、watch 的优先级？"></a>vue2 中选项 props、data、method、computed、watch 的优先级？</h3><p>在 Vue2 中，props、data、methods、computed 和 watch 这些选项都扮演着不同的角色，因此它们之间没有严格的优先级顺序。然而，我们可以从两个方面来理解这些选项的关系和执行顺序：数据初始化和数据更新。</p><ol><li>数据初始化：</li></ol><p>在 Vue 组件实例创建和挂载的过程中，各选项的执行顺序如下：</p><p>a) props：父组件向子组件传递数据。当子组件实例创建时，首先从父组件接收 props 数据。</p><p>b) data：组件的本地状态数据。在接收 props 数据后，组件会初始化 data。</p><p>c) methods：用于在组件中定义各种方法。methods 选项在 data 初始化之后定义，这样可以在其他地方（如计算属性或侦听器）调用这些方法。</p><p>d) computed：计算属性是基于其他数据（如 props、data、methods 等）计算而来的。因为计算属性依赖于其他数据，所以它们在 data 和 methods 初始化之后计算。</p><p>e) watch：侦听器用于观察和响应 Vue 实例上的数据变化。watch 选项在数据初始化完成之后设置，以便在数据发生变化时触发回调函数。</p><ol start="2"><li>数据更新：</li></ol><p>当组件的数据发生变化时，Vue 会根据依赖关系来更新 computed 和 watch。在这种情况下，它们的执行顺序如下：</p><p>a) 数据变化：当 props 或 data 中的数据发生变化时，会触发更新。</p><p>b) computed：当依赖的数据发生变化时，计算属性会重新计算。由于计算属性具有缓存机制，只有当依赖数据发生变化时，它们才会重新计算。</p><p>c) watch：当被观察的数据发生变化时，侦听器会触发相应的回调函数。与计算属性不同，侦听器没有缓存机制，每次数据变化都会触发回调函数。</p><p>总结：在 Vue2 中，props、data、methods、computed 和 watch 这些选项都扮演着不同的角色。在组件实例创建和挂载的过程中，各选项按照特定顺序执行。在数据更新时，computed 和 watch 根据依赖关系来触发更新。</p><h3 id="谈谈你对-vue2-以及-vue3-双向绑定原理的理解"><a href="#谈谈你对-vue2-以及-vue3-双向绑定原理的理解" class="headerlink" title="谈谈你对 vue2 以及 vue3 双向绑定原理的理解"></a>谈谈你对 vue2 以及 vue3 双向绑定原理的理解</h3><p>Vue.js 是一个用于构建用户界面的渐进式 JavaScript 框架。Vue 具有响应式数据绑定功能，使得数据和 DOM 之间能够双向绑定。Vue2 和 Vue3 的双向绑定原理有所不同，接下来分别介绍它们的实现原理：</p><ol><li>Vue2 双向绑定原理：</li></ol><p>Vue2 使用的双向绑定核心原理是基于数据劫持和发布-订阅模式。Vue2 的双向绑定分为两部分：数据劫持（通过 Object.defineProperty()） 和 Watcher 类。</p><ul><li>数据劫持：Vue2 使用 Object.defineProperty() 方法劫持数据对象的属性，对属性的 getter 和 setter 进行拦截。当属性值被访问或修改时，会触发 getter 和 setter，实现数据的响应式。</li><li>Watcher 类：Watcher 用于订阅数据变化和更新视图。每个数据属性都有一个 Watcher 实例，当数据发生变化时，触发 setter，并通知 Watcher，然后 Watcher 会调用其更新函数，将新值应用到 DOM。</li></ul><ol start="2"><li>Vue3 双向绑定原理：</li></ol><p>Vue3 的双向绑定原理基于 Proxy 和 Reflect。Vue3 使用 Proxy 对象对数据进行代理，而不是像 Vue2 那样使用 Object.defineProperty() 进行数据劫持。</p><ul><li>Proxy：Vue3 使用 Proxy 对象创建一个数据代理，当代理对象的属性被访问或修改时，会触发 Proxy 的拦截器函数（如 get 或 set），实现数据的响应式。</li><li>Reflect：Vue3 使用 Reflect API 进行对象操作，如获取属性值、设置属性值等。Reflect API 提供了一种更简洁、安全的方法来操作对象，同时具有更好的性能。</li></ul><p>Vue3 相较于 Vue2 的优势：</p><ul><li>Vue3 使用 Proxy 代替 Object.defineProperty()，可以直接监听对象的变化，而不仅仅是属性。这解决了 Vue2 中无法监听数组变化和对象属性添加的问题。</li><li>Vue3 使用 Proxy 可以提高性能，因为 Proxy 是原生支持的，而 Object.defineProperty() 是基于 JavaScript 层面的劫持。</li><li>Vue3 代码结构更简洁，易于维护。</li></ul><p>总结：Vue2 和 Vue3 的双向绑定原理都是基于数据劫持，但它们使用的技术实现方式不同。Vue2 使用 Object.defineProperty() 和发布-订阅模式，而 Vue3 使用 Proxy 和 Reflect。Vue3 相对于 Vue2 在性能和功能上有所改进。</p><h3 id="Vue-中响应式属性、dep-以及-watcher-之间的关系是什么？"><a href="#Vue-中响应式属性、dep-以及-watcher-之间的关系是什么？" class="headerlink" title="Vue 中响应式属性、dep 以及 watcher 之间的关系是什么？"></a>Vue 中响应式属性、dep 以及 watcher 之间的关系是什么？</h3><p>Vue.js 中的响应式系统是其核心特性之一，该系统使得 Vue.js 可以在数据改变时更新视图。这个响应式系统主要包含以下三个核心概念：响应式属性、Dep（依赖）以及 Watcher（观察者）。</p><ol><li><p><strong>响应式属性</strong>：在 Vue.js 中，当我们在 data 对象中定义属性时，Vue.js 会将这些属性转化为 getter&#x2F;setter 形式，这样就实现了响应式。当我们访问或修改一个属性时，getter&#x2F;setter 就会被调用。</p></li><li><p><strong>Dep（依赖）</strong>：Dep 可以看作是一个订阅器，它维护着一个 Watcher 列表，当响应式属性被修改时，Dep 会通知它的所有 Watcher，告诉它们数据已经被更新。Dep 在 getter 中收集 Watcher，在 setter 中触发 Watcher 更新。</p></li><li><p><strong>Watcher（观察者）</strong>：Watcher 是一个观察者对象，它观察某个响应式属性的变化。当响应式属性的 getter 被访问时，Dep 会将当前的 Watcher 添加到自己的订阅者列表中。当响应式属性被修改时，Dep 会通知 Watcher，然后 Watcher 会执行相应的操作（比如更新视图）。</p></li></ol><p>所以，<strong>响应式属性、Dep 和 Watcher 之间的关系</strong>可以这样理解：响应式属性是被观察的目标，Dep 是观察者（Watcher）和目标（响应式属性）之间的桥梁，它负责添加观察者，也负责在目标发生改变时通知观察者。Watcher 则是观察者，它观察响应式属性的变化，当变化发生时，执行相应的操作。</p><p>总的来说，这种关系构成了 Vue.js 的响应式系统，使得 Vue.js 可以在数据改变时自动更新视图。</p><h3 id="Vue-中，Watcher-有哪些类型？"><a href="#Vue-中，Watcher-有哪些类型？" class="headerlink" title="Vue 中，Watcher 有哪些类型？"></a>Vue 中，Watcher 有哪些类型？</h3><p>在 Vue.js 中，Watcher（观察者）是响应式系统的重要组成部分，它用于在某个数据发生变化时执行特定的回调函数。在 Vue.js 中，主要有以下几种类型的 Watcher：</p><ol><li><p><strong>渲染 Watcher</strong>：每一个组件实例都有对应的一个渲染 Watcher。当组件的数据变化时，渲染 Watcher 会被触发，进而重新渲染组件。这种类型的 Watcher 是 Vue 内部自动创建的，用于保证组件视图的更新。</p></li><li><p><strong>用户 Watcher</strong>：这是用户通过 <code>vm.$watch()</code> API 或组件的 <code>watch</code> 选项创建的 Watcher。用户可以通过这种方式来监听某个数据的变化，并在变化时执行特定的回调函数。</p></li><li><p><strong>计算属性 Watcher</strong>：这种类型的 Watcher 用于计算属性（computed property）。当计算属性所依赖的数据发生变化时，计算属性 Watcher 会被触发，从而重新计算属性的值。</p></li></ol><p>以上就是 Vue.js 中主要的几种 Watcher。这些 Watcher 都在 Vue 的响应式系统中起到了关键的作用，使得 Vue 可以在数据改变时自动更新视图。</p><h3 id="vue2-和-vue3-分别的父组件和子组件的渲染时机？"><a href="#vue2-和-vue3-分别的父组件和子组件的渲染时机？" class="headerlink" title="vue2 和 vue3 分别的父组件和子组件的渲染时机？"></a>vue2 和 vue3 分别的父组件和子组件的渲染时机？</h3><p><strong>vue2:</strong></p><ul><li><p><strong>初始化渲染时机</strong></p><p>父 beforeCreate &#x3D;&gt; 父 created &#x3D;&gt; 父 beforeMount &#x3D;&gt; 子 beforeCreate &#x3D;&gt; 子 created &#x3D;&gt; 子 beforeMount &#x3D;&gt; 子 mounted &#x3D;&gt; 父 mounted</p></li><li><p><strong>更新过程</strong></p><p>父 beforeUpdate &#x3D;&gt; 子 beforeUpdate &#x3D;&gt; 子 updated &#x3D;&gt; 父 updated</p></li><li><p><strong>销毁过程</strong></p><p>父 beforeDestory &#x3D;&gt; 子 beforeDestory &#x3D;&gt; 子 destoryed &#x3D;&gt; 父 destoryed</p></li></ul><p><strong>vue3:</strong></p><ul><li><p><strong>初始化渲染时机</strong></p><p>父 setup &#x3D;&gt; 父 beforeCreate &#x3D;&gt; 父 created &#x3D;&gt; 父 beforeMount &#x3D;&gt; 子 setup &#x3D;&gt; 子 beforeCreate &#x3D;&gt; 子 created &#x3D;&gt; 子 beforeMount &#x3D;&gt; 子 mounted &#x3D;&gt; 父 mounted</p></li><li><p><strong>更新过程</strong></p><p>父 beforeUpdate &#x3D;&gt; 子 beforeUpdate &#x3D;&gt; 子 updated &#x3D;&gt; 父 updated</p></li><li><p><strong>销毁过程</strong></p><p>父 beforeUnmount &#x3D;&gt; 子 beforeUnmount &#x3D;&gt; 子 unmounted &#x3D;&gt; 父 unmounted</p></li></ul><h3 id="谈谈你对-vue2-以及-vue3-整个渲染过程的理解"><a href="#谈谈你对-vue2-以及-vue3-整个渲染过程的理解" class="headerlink" title="谈谈你对 vue2 以及 vue3 整个渲染过程的理解"></a>谈谈你对 vue2 以及 vue3 整个渲染过程的理解</h3><p>Vue.js 是一个用于构建用户界面的渐进式 JavaScript 框架。Vue2 和 Vue3 的渲染过程有所不同，下面分别介绍它们的渲染过程：</p><ol><li>Vue2 渲染过程：</li></ol><p>Vue2 的渲染过程主要包括以下步骤：</p><ol><li><p>解析模板：Vue2 使用基于 HTML 的模板语法。Vue 会将模板解析成抽象语法树（AST）。</p></li><li><p>生成渲染函数：Vue2 会将 AST 转换为渲染函数（render function）。渲染函数是一个纯 JavaScript 函数，用于创建和更新虚拟 DOM 树。</p></li><li><p>响应式数据：Vue2 使用 Object.defineProperty() 为数据对象创建 getter 和 setter。当数据发生变化时，会触发 setter，并通知对应的 Watcher 实例。</p></li><li><p>创建 Watcher：对于每个数据属性，Vue2 会创建一个 Watcher 实例。Watcher 负责订阅数据变化，并在数据更新时调用渲染函数。</p></li><li><p>首次渲染：在实例创建时，Vue2 会调用渲染函数生成虚拟 DOM 树，并将其映射到实际的 DOM 节点上。</p></li><li><p>更新：当数据发生变化时，Vue2 会重新调用渲染函数生成新的虚拟 DOM 树。然后，使用虚拟 DOM 的 diff 算法（称为 patching）找出变化的部分，并更新实际的 DOM。</p></li></ol><p>Vue3 渲染过程：</p><p>Vue3 的渲染过程与 Vue2 类似，但有一些关键的改进和优化。以下是 Vue3 渲染过程的主要步骤：</p><ol><li>解析模板：Vue3 同样使用基于 HTML 的模板语法，并将模板解析成抽象语法树（AST）。</li><li>生成渲染函数：Vue3 会将 AST 转换为渲染函数。Vue3 的渲染函数使用了一种新的编译策略，称为 “优化模式”，可以在编译阶段静态地分析模板中的动态绑定，并生成更高效的代码。</li><li>响应式数据：Vue3 使用 Proxy 对象代替 Object.defineProperty()，创建数据的响应式代理。这提供了更好的性能和更广泛的数据监听能力。</li><li>创建 Watcher：Vue3 中仍然使用 Watcher 实例订阅数据变化，并在数据更新时调用渲染函数。但 Vue3 的 Watcher 实现有所优化，减少了不必要的计算和渲染。</li><li>首次渲染：与 Vue2 类似，Vue3 会在实例创建时调用渲染函数生成虚拟 DOM 树，并将其映射到实际的 DOM 节点上。</li><li>更新：当数据发生变化时，Vue3 会重新调用渲染函数生成新的虚拟 DOM 树。然后，使用优化后的虚拟 DOM diff 算法找出变化的部分，并更新实际的 DOM。Vue3 的 diff 算法经过优化，可以更快地找到差异并更新 DOM。</li><li>组合式 API：Vue3 引入了组合式 API，它是一种更灵活的组织和复用组件逻辑的方式。使用组合式 API，可以更容易地将代码分解为独立的、可重用的函数。这对于更大型的项目和更复杂的组件逻辑非常有用。</li></ol><p>总结：Vue2 和 Vue3 的渲染过程有很多相似之处，如解析模板、生成渲染函数、响应式数据、创建 Watcher、首次渲染和更新。然而，Vue3 在性能、响应式系统和组件逻辑复用方面进行了优化和改进，提供了更高效和灵活的渲染过程。</p><img src="https://images-1256612942.cos.ap-guangzhou.myqcloud.com/2022_05_31_BBZDb5.jpg" style="width: 50%" /><h3 id="说下-nextTick-的原理"><a href="#说下-nextTick-的原理" class="headerlink" title="说下 nextTick 的原理"></a>说下 nextTick 的原理</h3><p>Vue 的 <code>nextTick</code> 函数是一个非常实用的工具方法，它允许我们在 DOM 更新完成后延迟执行一个回调函数。这在某些情况下非常有用，例如当你需要在数据变化后操作 DOM 元素时。接下来我们来详细了解 <code>nextTick</code> 的原理。</p><p>Vue 中的数据变化是异步的。当数据发生变化时，Vue 不会立即更新 DOM，而是将更新任务推入一个队列。在同一事件循环中发生的所有数据变化都会被加入到这个队列中。在下一个事件循环（也就是下一个 “tick”）开始时，Vue 会清空队列，并批量执行 DOM 更新。这种机制可以避免不必要的 DOM 更新，从而提高性能。</p><p><code>nextTick</code> 的作用就是在这个队列清空并且 DOM 更新完成后，执行我们传给它的回调函数。这样我们可以确保回调函数在 DOM 更新后执行，让我们可以安全地操作已经更新过的 DOM 元素。</p><p>为了实现 <code>nextTick</code>，Vue 使用了一个任务队列和一种任务调度策略。具体实现取决于浏览器支持的 API。Vue 首选使用 <code>Promise.then()</code>、<code>MutationObserver</code> 或 <code>setImmediate</code> 进行异步调度。如果浏览器不支持这些 API，Vue 会退回到使用 <code>setTimeout(fn, 0)</code>。</p><p>总结，<code>nextTick</code> 的原理是基于 Vue 的异步更新队列和任务调度策略。通过使用 <code>nextTick</code>，我们可以在 DOM 更新完成后执行回调函数，确保在操作 DOM 时，数据已经被更新。</p><h3 id="谈谈你对-keep-alive-的理解"><a href="#谈谈你对-keep-alive-的理解" class="headerlink" title="谈谈你对 keep-alive 的理解"></a>谈谈你对 keep-alive 的理解</h3><p><code>keep-alive</code> 是 Vue 中的一个内置组件，它用于缓存组件的状态以提高性能。当我们在不同组件之间切换时，通常组件会被销毁并重新创建。然而，在某些情况下，我们可能希望保留组件的状态，以避免不必要的重新渲染。这时，我们可以使用 <code>keep-alive</code> 组件来实现这个目的。</p><p>以下是关于 <code>keep-alive</code> 的一些关键点：</p><ol><li>缓存组件：将组件包裹在 <code>keep-alive</code> 标签内，可以使其状态得到缓存。当组件被切换时，它不会被销毁，而是被缓存起来。当组件重新被激活时，它的状态会被恢复，而不是重新创建。</li><li>生命周期钩子：当组件被 <code>keep-alive</code> 包裹时，组件的生命周期钩子会发生变化。组件在被激活和停用时，分别触发 <code>activated</code> 和 <code>deactivated</code> 生命周期钩子。这使得我们可以在这两个钩子函数中执行一些特定的逻辑，如获取数据或重置状态。</li><li>包含和排除组件：<code>keep-alive</code> 组件提供了 <code>include</code> 和 <code>exclude</code> 属性，允许我们有选择地缓存特定的组件。我们可以通过组件名称或正则表达式来指定要缓存的组件。</li><li>缓存策略：<code>keep-alive</code> 还提供了一个 <code>max</code> 属性，允许我们设置缓存组件的最大数量。当缓存组件的数量超过这个限制时，最早的组件会被销毁。</li></ol><p>总结：<code>keep-alive</code> 是 Vue 的内置组件，用于缓存组件状态以提高性能。通过将组件包裹在 <code>keep-alive</code> 标签内，我们可以在不同组件之间切换时保留它们的状态。<code>keep-alive</code> 还提供了一些属性来控制缓存行为，如包含和排除组件、设置缓存最大数量等。同时，<code>keep-alive</code> 影响了组件的生命周期钩子，引入了 <code>activated</code> 和 <code>deactivated</code> 钩子。</p><h3 id="讲讲-vue-组件之间的通信"><a href="#讲讲-vue-组件之间的通信" class="headerlink" title="讲讲 vue 组件之间的通信"></a>讲讲 vue 组件之间的通信</h3><p>组件通信有如下分类：</p><ul><li>父子组件之间的通信<ul><li><code>props</code>&#x2F;<code>$emit</code>。</li><li><code>$parent</code>&#x2F;<code>$children</code></li><li><code>ref</code></li><li><code>provide</code>&#x2F;<code>inject</code></li><li><code>$attrs</code>&#x2F;<code>$listeners</code> &#x3D;&gt; vue3 已移除</li><li><code>$on</code>&#x2F;<code>$emit</code> &#x3D;&gt; vue3 已移除</li></ul></li><li>兄弟组件之间的通信<ul><li><code>eventBus</code></li><li><code>vuex</code></li></ul></li><li>跨级通信<ul><li><code>eventBus</code></li><li><code>vuex</code></li><li><code>provide</code>&#x2F;<code>inject</code></li><li><code>$attrs</code>&#x2F;<code>$listeners</code></li><li><code>$on</code>&#x2F;<code>$emit</code></li></ul></li></ul><p>这里讲下 eventBus，eventBus 又称为事件总线，在 vue 中可以用来作为组件间的沟通桥梁，所有组件公用相同的事件中心，可以向该中心发送事件和监听事件。eventBus 的缺点是就是当项目较大时，容易造成难以维护的灾难。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Children1.vue</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Children2.vue</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&quot;foo&quot;</span>, <span class="variable language_">this</span>.<span class="property">handle</span>);</span><br></pre></td></tr></table></figure><h3 id="谈谈你对-vue2-以及-vue3-生命周期的理解"><a href="#谈谈你对-vue2-以及-vue3-生命周期的理解" class="headerlink" title="谈谈你对 vue2 以及 vue3 生命周期的理解"></a>谈谈你对 vue2 以及 vue3 生命周期的理解</h3><p>Vue 生命周期指的是 Vue 组件从创建到销毁经历的不同阶段。在组件的生命周期中，Vue 提供了一系列生命周期钩子函数，允许我们在特定时刻执行一些自定义逻辑。Vue2 和 Vue3 的生命周期钩子有些许不同，下面分别介绍它们。</p><ol><li>Vue2 生命周期钩子：</li></ol><p>a) beforeCreate：在实例创建之后，数据观测、属性计算等初始化之前触发。</p><p>b) created：在实例创建完成后，数据观测、属性计算等已经初始化完毕，但尚未开始 DOM 编译和挂载。</p><p>c) beforeMount：在模板编译完成、挂载 DOM 之前触发。此时，虚拟 DOM 已创建，真实 DOM 尚未更新。</p><p>d) mounted：在模板编译完成、挂载 DOM 之后触发。此时，真实 DOM 已经更新。</p><p>e) beforeUpdate：在数据发生变化，组件重新渲染之前触发。此时，可以获取到旧的 DOM 结构。</p><p>f) updated：在数据发生变化，组件重新渲染并更新 DOM 之后触发。此时，可以获取到新的 DOM 结构。</p><p>g) beforeDestroy：在实例销毁之前触发。此时，实例仍然完全可用。</p><p>h) destroyed：在实例销毁之后触发。此时，实例的所有指令绑定、事件监听器等都已经解除。</p><ol><li>Vue3 生命周期钩子：</li></ol><p>Vue3 的生命周期钩子基本与 Vue2 类似，但有一些命名上的变化。这些变化主要是为了与 Vue3 的组合式 API 保持一致：</p><p>a) beforeCreate -&gt; setup：在 Vue3 中，setup 函数取代了 beforeCreate 和 created 生命周期钩子。组件的数据和方法在 setup 函数中定义。</p><p>b) created：由于有了 setup 函数，created 生命周期钩子在 Vue3 中不再使用。</p><p>c) beforeMount：与 Vue2 中相同。</p><p>d) mounted：与 Vue2 中相同。</p><p>e) beforeUpdate：与 Vue2 中相同。</p><p>f) updated：与 Vue2 中相同。</p><p>g) beforeUnmount：Vue3 中将 beforeDestroy 重命名为 beforeUnmount。</p><p>h) unmounted：Vue3 中将 destroyed 重命名为 unmounted。</p><p>总结：Vue2 和 Vue3 的生命周期钩子基本相似，允许我们在组件的不同阶段执行自定义逻辑。主要区别在于 Vue3 引入了 setup 函数取代了 beforeCreate 和 created 生命周期钩子，并将 beforeDestroy 和 destroyed 重命名为 beforeUnmount 和 unmounted。这些变化使得 Vue3 生命周期钩子与组合式 API 保持一致。</p><h3 id="什么情况下会创建-Watcher-观察者-？什么情况下会创建-Dep-依赖容器-对象？"><a href="#什么情况下会创建-Watcher-观察者-？什么情况下会创建-Dep-依赖容器-对象？" class="headerlink" title="什么情况下会创建 Watcher(观察者)？什么情况下会创建 Dep(依赖容器)对象？"></a>什么情况下会创建 Watcher(观察者)？什么情况下会创建 Dep(依赖容器)对象？</h3><p>在 Vue.js 中，Watcher 对象和 Dep 对象的创建时机如下：</p><ol><li>创建 Watcher 对象的情况：</li></ol><ul><li>编译模板：在编译模板时，Vue.js 解析模板中的指令（如 v-model、v-bind 等）和插值表达式（如 ），为每个指令或表达式创建一个 Watcher 对象。这些 Watcher 对象负责监听数据变化并在数据发生变化时更新视图。</li><li>手动实例化：当需要手动监控某个表达式或计算属性时，可以创建一个 Watcher 对象。例如，在 Vue 组件中，可以使用 vm.$watch() 方法创建一个 Watcher 对象以监听某个数据属性或计算属性的变化。</li></ul><ol><li>创建 Dep 对象的情况：</li></ol><ul><li>响应式数据：当 Vue 组件实例化时，Vue.js 会遍历组件的 data 对象。对于 data 对象中的每个属性，Vue.js 使用 Object.defineProperty() 方法进行劫持。在这个过程中，会为每个属性创建一个 Dep 对象。Dep 对象（依赖容器）负责收集所有与该属性相关的 Watcher 对象（观察者）。当属性被访问时，Dep 会将当前的 Watcher 对象添加到其依赖列表中，实现依赖收集。</li></ul><p>总结一下，Watcher 对象主要在编译模板和手动监控表达式或计算属性时创建。Dep 对象主要在 Vue 组件实例化时为 data 对象中的每个属性创建。这两种对象共同构成了 Vue.js 的响应式系统，实现数据与视图之间的双向绑定。</p><h3 id="vue3-相比-vue2-新增了什么？"><a href="#vue3-相比-vue2-新增了什么？" class="headerlink" title="vue3 相比 vue2 新增了什么？"></a>vue3 相比 vue2 新增了什么？</h3><p>Vue3 相对于 Vue2 引入了许多新特性和优化，这些变化使得 Vue3 在性能、可扩展性和易用性方面有了很大提升。以下是 Vue3 相比于 Vue2 的主要新增内容：</p><ol><li>Composition API：Vue3 引入了组合式 API，这是一种新的组件逻辑组织方式，允许更灵活地复用和组合组件逻辑。相比于 Vue2 的选项式 API，组合式 API 更容易让我们在大型项目中管理和维护代码。</li><li>更好的性能：Vue3 在性能方面进行了很多优化，包括更小的打包体积、更快的渲染速度以及更高效的组件更新。这些优化使得 Vue3 的性能比 Vue2 更强大。</li><li>更小的体积：Vue3 的编译器和运行时都经过了优化，使得打包后的体积更小。此外，Vue3 支持 tree-shaking，可以进一步减小最终构建文件的大小。</li><li>更好的 TypeScript 支持：Vue3 的源代码完全使用 TypeScript 重写，因此 Vue3 提供了更好的 TypeScript 支持和类型推导。</li><li>新的生命周期钩子和更改：Vue3 为了与组合式 API 保持一致，对生命周期钩子进行了一些重命名，例如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。同时，Vue3 引入了 setup 函数来代替 beforeCreate 和 created 生命周期钩子。</li><li>更强大的响应式系统：Vue3 使用 Proxy 对象重写了响应式系统，解决了 Vue2 中的一些限制（例如，对象属性的动态添加和删除）。新的响应式系统还提供了更好的性能和内存管理。</li><li>Fragment 和 Teleport：Vue3 支持 Fragment（片段），允许一个组件具有多个根元素。此外，Vue3 引入了 Teleport 组件，可以将子组件渲染到 DOM 中的任意位置，解决了一些特殊场景下的渲染问题。</li><li>Suspense：Vue3 引入了 Suspense 组件，允许我们在异步组件加载时展示一个 fallback 内容。这使得异步组件的加载和错误处理变得更加简单和优雅。</li></ol><p>总结：Vue3 相比于 Vue2 引入了许多新特性和优化，包括组合式 API、更好的性能、更小的体积、更好的 TypeScript 支持、新的生命周期钩子和更改、更强大的响应式系统、Fragment 和 Teleport 组件以及 Suspense 组件。这些变化使得 Vue3 在性能、可扩展性和易用性方面有了很大提升。</p><h3 id="谈谈你对-Vuex-以及-Pinia-的理解，以及它们之间的区别"><a href="#谈谈你对-Vuex-以及-Pinia-的理解，以及它们之间的区别" class="headerlink" title="谈谈你对 Vuex 以及 Pinia 的理解，以及它们之间的区别"></a>谈谈你对 Vuex 以及 Pinia 的理解，以及它们之间的区别</h3><p>Vuex 和 Pinia 都是 Vue.js 的状态管理库，它们帮助我们在 Vue 应用中管理和维护共享状态。这两者有一定的相似性，但也存在一些关键的区别。</p><ol><li>Vuex：</li></ol><p>Vuex 是 Vue 官方推荐的状态管理库，适用于 Vue2 和 Vue3。它提供了一种集中式存储来管理应用程序中所有组件的状态。Vuex 的核心概念包括：</p><ul><li>State：存储应用程序的状态数据。</li><li>Getters：从 state 中派生出新的状态，类似于计算属性。</li><li>Mutations：用于更改 state 的同步方法。</li><li>Actions：用于执行异步操作（例如 API 调用）并触发 mutations。</li></ul><p>Vuex 遵循严格的单向数据流，确保状态更改的可预测性。同时，Vuex 还提供了一些开发者工具，帮助我们在开发过程中跟踪和调试状态更改。</p><ol start="2"><li>Pinia：</li></ol><p>Pinia 是一个轻量级的状态管理库，专为 Vue3 设计。它充分利用了 Vue3 的组合式 API 和响应式系统，使得状态管理更加简洁和灵活。Pinia 的核心概念包括：</p><ul><li>Store：存储应用程序的状态数据和相关方法。</li><li>State：用于存储状态的响应式对象。</li><li>Actions：用于执行异步操作和更改 state。</li></ul><p>Pinia 的使用方法与 Vuex 类似，但其 API 更简洁，易于学习和使用。此外，Pinia 同样支持开发者工具，方便我们跟踪和调试状态更改。</p><ol start="3"><li>区别：</li></ol><ul><li>适用范围：Vuex 适用于 Vue2 和 Vue3，而 Pinia 专为 Vue3 设计。</li><li>API 设计：Pinia 的 API 更简洁，易于学习和使用。它充分利用了 Vue3 的组合式 API 和响应式系统。</li><li>状态更新：Vuex 通过 mutations 和 actions 分别处理同步和异步状态更新，而 Pinia 将这两者合并为 actions。</li><li>体积：Pinia 是一个轻量级库，相比于 Vuex 有更小的体积。</li><li>生命周期：Pinia store 支持更好的生命周期管理，如 onBeforeMount、onMounted 等。</li></ul><p>总结：Vuex 和 Pinia 都是 Vue 的状态管理库，用于管理和维护共享状态。它们之间的主要区别在于适用范围、API 设计、状态更新方式、体积和生命周期管理。对于 Vue3 项目，Pinia 可能是一个更轻量、更简洁的选择，但 Vuex 作为官方推荐的库，在稳定性和生态方面仍具有优势。</p><h3 id="谈谈你对-vue2-以及-vue3-中-diff-算法的理解"><a href="#谈谈你对-vue2-以及-vue3-中-diff-算法的理解" class="headerlink" title="谈谈你对 vue2 以及 vue3 中 diff 算法的理解"></a>谈谈你对 vue2 以及 vue3 中 diff 算法的理解</h3><p>Vue 的 diff 算法是用于在虚拟 DOM（Virtual DOM）更新过程中比较新旧两个虚拟节点树的差异，从而仅对有差异的部分进行真实 DOM 的更新，以提高性能。Vue2 和 Vue3 中的 diff 算法都基于 Snabbdom 库，但在 Vue3 中，diff 算法进行了一些优化，使得性能更高。</p><p>以下是对 Vue2 和 Vue3 中 diff 算法的理解：</p><ol><li>Vue2 diff 算法：</li></ol><p>Vue2 的 diff 算法主要通过同级节点之间的比较来进行。在对比新旧虚拟节点时，它采用<strong>双端比较</strong>的策略。首先分别比较新旧虚拟节点树的头部和尾部节点，通过四种可能的情况进行节点的移动、删除和创建。具体步骤如下：</p><ul><li>如果新旧头部节点相同，将两个头部节点向后移动。</li><li>如果新旧尾部节点相同，将两个尾部节点向前移动。</li><li>如果旧头部节点和新尾部节点相同，将旧头部节点移动到尾部。</li><li>如果旧尾部节点和新头部节点相同，将旧尾部节点移动到头部。</li></ul><p>如果以上四种情况都不满足，Vue2 会创建一个新的 key 到 index 的映射表，然后遍历新的子节点，查找旧节点中是否存在相同的 key。如果找到相同的 key，将旧节点移动到正确的位置。否则，创建一个新节点并插入到正确的位置。最后，删除旧节点中未匹配的节点。</p><ol start="2"><li>Vue3 diff 算法：</li></ol><p>Vue3 的 diff 算法在 Vue2 的基础上进行了优化。Vue3 利用<strong>了静态节点和动态节点</strong>的概念，通过对静态节点进行跳过，减少了不必要的比较。此外，Vue3 对于静态节点和动态节点的处理也进行了优化。在处理动态节点时，Vue3 使用了一个名为 <code>lis</code>（Longest Increasing Subsequence，最长递增子序列）的算法，通过查找最长递增子序列，找到需要移动的最少节点数量，从而减少节点移动操作，提高性能。</p><p>总结：Vue 的 diff 算法用于比较新旧虚拟节点树的差异，从而实现高效的 DOM 更新。Vue2 和 Vue3 的 diff 算法都基于 Snabbdom 库，采用双端比较策略。Vue3 在 Vue2 的基础上进行了优化，引入了静态节点和动态节点的概念，通过跳过静态节点的比较和使用 lis 算法减少节点移动操作，提高了性能。</p><p>尽管 Vue3 的 diff 算法相较于 Vue2 进行了优化，但在实际应用中，性能提升的程度还取决于组件的结构和数据变化。以下是一些建议，可以帮助我们在使用 Vue 时充分利用 diff 算法的优势：</p><ol><li>使用 key：为列表中的每个节点分配唯一的 key，可以帮助 diff 算法更快地找到相应的节点，从而提高性能。尽量避免使用不稳定的值（例如随机数或索引）作为 key。</li><li>避免不必要的节点更新：尽量避免在没有实际更改的情况下触发组件的重新渲染。可以使用计算属性、watchers 和 Vue 的性能优化功能（如 <code>shouldComponentUpdate</code> 和 <code>keep-alive</code>）来减少不必要的渲染。</li><li>合理划分组件：将大型组件拆分为更小的子组件，以便更好地控制组件的更新。当某个子组件的状态发生变化时，只需更新该子组件，而不会影响其他子组件。</li><li>优化动态节点：在 Vue3 中，利用静态节点和动态节点的概念，确保动态节点的数量和位置合理。这可以帮助减少 diff 算法的计算量，提高性能。</li></ol><p>通过了解 Vue2 和 Vue3 中的 diff 算法原理，并结合实际项目中的组件结构和数据变化情况，我们可以更好地利用 Vue 的性能优势，构建高效的前端应用。</p><h3 id="为什么虚拟-DOM-会提高性能？"><a href="#为什么虚拟-DOM-会提高性能？" class="headerlink" title="为什么虚拟 DOM 会提高性能？"></a>为什么虚拟 DOM 会提高性能？</h3><p>虚拟 DOM（Virtual DOM）是一种<strong>在内存中表示真实 DOM 的数据结构</strong>。它允许我们在内存中对 DOM 进行操作，而不是直接操作真实的 DOM。虚拟 DOM 的主要优势是性能提升，原因如下：</p><ol><li>减少 DOM 操作次数：真实 DOM 的操作（如创建、更新、删除元素）通常比内存操作更耗时。虚拟 DOM 允许我们在内存中进行大量操作，然后一次性将这些操作应用到真实 DOM 上，减少了对真实 DOM 的操作次数。</li><li>最小化更新范围：虚拟 DOM 结合 diff 算法，可以找出新旧虚拟 DOM 之间的差异，从而仅对有差异的部分进行真实 DOM 的更新。这可以减少不必要的 DOM 操作，提高性能。</li><li>批量更新：当有多个更改需要应用到真实 DOM 时，虚拟 DOM 可以将这些更改合并为一次更新。这有助于避免因多次操作导致的布局抖动（Layout Thrashing）和重绘，从而提高性能。</li><li>更好的跨平台兼容性：虚拟 DOM 不仅可以表示 Web 页面中的 DOM，还可以表示其他平台的 UI（例如移动应用或桌面应用）。这意味着使用虚拟 DOM 的框架（如 Vue 或 React）可以更容易地实现跨平台应用程序，而不必为每个平台编写特定的代码。</li></ol><p>虚拟 DOM 的性能提升并非绝对，它主要适用于大型应用和频繁更新的场景。对于简单的应用或更新较少的情况，虚拟 DOM 可能带来一定的开销。然而，在许多情况下，虚拟 DOM 提供了一种有效的方法来减少真实 DOM 操作，从而提高应用程序的性能。</p><h3 id="react-生命周期有哪些？"><a href="#react-生命周期有哪些？" class="headerlink" title="react 生命周期有哪些？"></a>react 生命周期有哪些？</h3><p>React 的生命周期方法可分为三个主要阶段：挂载阶段（Mounting）、更新阶段（Updating）和卸载阶段（Unmounting）。以下是 React 的类组件生命周期方法。需要注意的是，React 16.3 版本后引入了新的生命周期方法，废弃了一些旧的方法。</p><ol><li>挂载阶段（Mounting）： 这个阶段涉及到组件在 DOM 中创建和插入的过程。</li></ol><ul><li>constructor：构造函数，用于初始化组件的状态（state）和绑定事件处理器。</li><li>static getDerivedStateFromProps：在组件实例创建后和渲染前调用。根据传入的 props 计算出新的状态，返回一个用于更新状态的对象。这是一个静态方法，不能在其中使用 <code>this</code>。</li><li>render：用于创建虚拟 DOM，并返回要渲染的 JSX 结构。这是一个纯函数，不应在其中执行任何副作用操作。</li><li>componentDidMount：在组件挂载到 DOM 后立即调用。常用于触发 AJAX 请求、DOM 操作、添加事件监听等副作用操作。</li></ul><ol start="2"><li>更新阶段（Updating）： 当组件的状态（state）或属性（props）发生变化时，组件将重新渲染。这个阶段涉及到组件的更新过程。</li></ol><ul><li>static getDerivedStateFromProps：与挂载阶段中的相同，当组件接收到新的属性时调用。</li><li>shouldComponentUpdate：在重新渲染之前调用，可以根据变化的状态和属性来决定是否需要重新渲染。返回一个布尔值，如果为 false，则阻止组件更新。</li><li>render：与挂载阶段中的相同，重新渲染组件。</li><li>getSnapshotBeforeUpdate：在 DOM 更新之前获取快照，用于在 componentDidUpdate 中比较新旧 DOM。返回一个值或 null，作为 componentDidUpdate 的第三个参数。</li><li>componentDidUpdate：在组件更新并重新渲染后调用。常用于触发 AJAX 请求、DOM 操作、更新事件监听等副作用操作。</li></ul><ol start="3"><li>卸载阶段（Unmounting）： 当组件从 DOM 中移除时，进入卸载阶段。</li></ol><ul><li>componentWillUnmount：在组件卸载前调用。用于清理组件产生的副作用，如取消 AJAX 请求、移除事件监听等。</li></ul><p>需要注意的是，React 16.8 引入了 Hooks，它允许在函数组件中使用状态和生命周期特性。使用 <code>useState</code>、<code>useEffect</code> 和其他 Hooks 可以在函数组件中实现类似的生命周期行为。</p><h3 id="谈谈你对受控组件和非受控组件的理解"><a href="#谈谈你对受控组件和非受控组件的理解" class="headerlink" title="谈谈你对受控组件和非受控组件的理解"></a>谈谈你对受控组件和非受控组件的理解</h3><p>在 React 中，表单元素的类型可以被划分为受控组件和非受控组件。</p><p><strong>受控组件：</strong></p><p>受控组件是指表单元素（如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>等）的值被 React 的 state 控制的组件。换句话说，对于一个受控组件，其输入的值总是由 React 的 state 驱动的。我们通过设置组件的状态，并在每次用户交互时（如输入文本，选择下拉选项等）更新这个状态，来控制这个组件的值。</p><p>例如，以下是一个受控组件的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ControlledForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">inputValue</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">inputValue</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;this.state.inputValue&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;this.handleInputChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受控组件通常有更好的灵活性，因为你可以直接控制输入的内容，例如进行格式化、验证等。</p><p><strong>非受控组件：</strong></p><p>非受控组件则不通过 state 来控制输入的值。相反，它们使用原生的 DOM API 来获取或修改表单元素的值。通常，我们使用 React 的<code>ref</code>来获取 DOM 元素，然后从该元素上读取或设置值。</p><p>以下是一个非受控组件的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UncontrolledForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  myInput = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">myInput</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.myInput&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非受控组件的优点是它们更简单，更接近传统的 HTML 形式，但它们通常不能提供受控组件那样的灵活性。你需要使用 DOM API 来获取或设置值，这可能使得代码更难理解和维护。</p><p>在大多数情况下，推荐使用受控组件，因为它们使得应用的状态更可预测，并且更易于实现复杂的功能，如实时验证和输入限制。然而，在某些情况下，非受控组件可能更简单或更方便，例如当处理大量输入和动态输入时。</p><h3 id="讲讲-react-组件之间的通信"><a href="#讲讲-react-组件之间的通信" class="headerlink" title="讲讲 react 组件之间的通信"></a>讲讲 react 组件之间的通信</h3><p>React 组件之间的通信主要依赖于属性（props）和上下文（context）。以下是 React 组件间通信的几种常见方式：</p><ol><li><p>父组件向子组件传递数据（Props）： 父组件通过属性（props）将数据传递给子组件。子组件通过 <code>this.props</code>（类组件）或函数参数（函数组件）访问传递的数据。这是 React 中最常见的通信方式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChildComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Hello from parent!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">message</span>=<span class="string">&#123;message&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子组件向父组件传递数据（回调函数）： 子组件不能直接修改父组件的状态。为了让子组件向父组件传递数据，父组件可以将一个回调函数作为属性传递给子组件。子组件调用该回调函数时，可以将数据作为参数传递，从而实现向父组件传递数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChildComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> props.handleMessage(&quot;Hello from child!&quot;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      Send Message</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleMessage</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">handleMessage</span>=<span class="string">&#123;this.handleMessage.bind(this)&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>兄弟组件间通信： 兄弟组件间的通信需要依赖于它们共同的父组件。父组件可以通过状态（state）和回调函数将兄弟组件间的数据传递。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleMessage</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; message &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildComponent1</span> <span class="attr">handleMessage</span>=<span class="string">&#123;this.handleMessage.bind(this)&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildComponent2</span> <span class="attr">message</span>=<span class="string">&#123;this.state.message&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用上下文（Context）： 当多层嵌套的组件需要通信时，逐层传递属性可能变得繁琐。这时可以使用 React 的上下文（Context）API。Context 提供了一种在组件树中共享数据的方式，而无需显式地传递属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MessageContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;Hello from context!&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">MessageContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.message&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MessageContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChildComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MessageContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;(message) =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">MessageContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用状态管理库（如 Redux）： 在大型应用程序中，组件之间的通信可能变得复杂。使用状态管理库（如 Redux）可以集中管理应用程序的状态，简化组件间的通信。组件可以通过连接到状态管理库（如 Redux）来访问和更新全局状态。</p><p>使用 Redux 管理状态可以让你更好地处理大型应用程序中的组件间通信和共享状态。在实际项目中，你可能还需要使用一些额外的工具和技术，例如 Redux Toolkit、Redux Thunk 或 Redux Saga。</p></li></ol><h3 id="谈谈你对纯函数的理解"><a href="#谈谈你对纯函数的理解" class="headerlink" title="谈谈你对纯函数的理解"></a>谈谈你对纯函数的理解</h3><p>在 React 中，纯函数指的是给定相同的输入，始终返回相同的输出，而且没有副作用的函数。它们不会改变其输入，也不会影响到系统的任何其他部分，例如修改全局变量、修改传入的对象等。</p><p>在 React 中，纯函数特别重要，因为当父组件的状态或属性改变时，React 会重新渲染整个组件树。如果组件内部存在副作用，那么每次渲染时都会重新触发这些副作用，导致性能下降。而纯函数则不会有这个问题，它只会在必要的情况下被调用，从而优化了应用程序的性能。</p><h3 id="为什么-useState-不推荐放在-if-判断里面"><a href="#为什么-useState-不推荐放在-if-判断里面" class="headerlink" title="为什么 useState 不推荐放在 if 判断里面"></a>为什么 useState 不推荐放在 if 判断里面</h3><p>因为 React 依赖于 hook 调用的顺序和频率始终保持不变，以正确地跟踪和关联状态和副作用。</p><p>当在组件渲染过程中调用 useState，React 会保留这个状态的值，直到下一次渲染。React 保持一个内部的”记忆”，通过这个记忆，它知道在每次渲染时，状态值应该对应哪个 useState 调用。如果在 if 语句中调用 useState，那么 hook 的调用可能会在不同的渲染中跳过或者重复，导致 React 无法正确地追踪状态值。</p><p>为了遵循 Hooks 的使用规则，确保在函数式组件的顶层调用 <code>useState</code>。如果需要根据条件判断来决定是否使用状态，可以考虑将组件拆分成多个子组件，并在相应的子组件中使用 <code>useState</code>。这样可以保持 Hooks 的调用顺序一致，同时满足组件的逻辑需求。</p><h3 id="谈谈你对函数式组件和类组件的理解"><a href="#谈谈你对函数式组件和类组件的理解" class="headerlink" title="谈谈你对函数式组件和类组件的理解"></a>谈谈你对函数式组件和类组件的理解</h3><p>在 React 中，有两种主要的组件类型：函数式组件（Functional Component）和类组件（Class Component）。下面分别介绍它们的特点和区别。</p><p>函数式组件：</p><ol><li>通过定义一个纯 JavaScript 函数来创建的，接收 props 作为参数并返回 React 元素。</li><li>在 React 16.8 之前，函数式组件仅支持接收 props，不支持 state 和生命周期方法。</li><li>自 React 16.8 引入 Hooks 后，函数式组件可以使用<code>useState</code>和<code>useEffect</code>等 Hooks 来实现状态管理和生命周期方法的功能。</li><li>函数式组件通常更简洁，易于阅读和测试。</li><li>在性能方面，由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。</li></ol><p>类组件：</p><ol><li>是通过定义一个继承自<code>React.Component</code>的 JavaScript 类来创建的，该类包含一个<code>render</code>方法，接收 props 和 state 作为输入，并返回 React 元素。</li><li>支持 state 和生命周期方法，如<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>等。</li><li>需要通过<code>this</code>关键字来访问 props 和 state。</li><li>类组件通常相对复杂，可能难以理解和测试。</li><li>在性能方面，由于有生命周期方法和实例化过程，类组件在某些情况下可能比函数式组件稍慢。</li></ol><p>两者之间的主要区别：</p><ol><li>定义方式：函数式组件是纯函数，而类组件是继承自<code>React.Component</code>的类。</li><li>状态管理：在 React 16.8 之前，只有类组件可以使用 state。自 React 16.8 引入 Hooks 后，函数式组件也可以使用<code>useState</code>来管理状态。</li><li>生命周期方法：在 React 16.8 之前，只有类组件支持生命周期方法。自 React 16.8 引入 Hooks 后，函数式组件可以使用<code>useEffect</code>等 Hooks 来实现生命周期方法的功能。</li><li>语法和结构：函数式组件通常更简洁，而类组件可能相对复杂。</li><li>性能：由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。</li></ol><p>总的来说，随着 React Hooks 的引入，函数式组件的功能已经基本与类组件相当。在实际开发中，建议优先使用函数式组件，以保持代码简洁和易于维护。当然，在一些特定场景下，例如需要使用到生命周期方法或者需要访问组件实例（如使用 refs）时，类组件仍然具有一定的优势。</p><h3 id="在-React-中元素和组件有什么区别？"><a href="#在-React-中元素和组件有什么区别？" class="headerlink" title="在 React 中元素和组件有什么区别？"></a>在 React 中元素和组件有什么区别？</h3><p>React 中的元素和组件是两个非常核心的概念，理解它们的区别对于理解 React 非常重要。以下是我对这两者的理解：</p><ol><li><p><strong>React 元素</strong>：React 元素是描述了你在屏幕上想看到的内容的普通对象。元素包含了组件应该渲染什么的信息，你可以将它们看作是 DOM 节点或者组件的“快照”。React 元素是不可变的，一旦创建，你就不能改变它的子元素或属性。一个元素就像一帧电影——它代表了某一特定的时间点的 UI。</p></li><li><p><strong>React 组件</strong>：组件则可以视为函数或类，它们接受输入（即”props”），并返回 React 元素树，描述屏幕上应该显示什么。组件使你可以将 UI 拆分成独立的、可重用的部分，你可以独立地考虑每个部分。组件可以是 React 内置的组件，如<code>&lt;div /&gt;</code>，也可以是自定义的组件，如<code>&lt;MyComponent /&gt;</code>。</p></li></ol><p>简单来说，元素是你在代码中看到的，它描述了你想在屏幕上看到什么。而组件则是函数或者类，它决定了屏幕上应该展示什么。组件可以接受参数（props）并返回 React 元素，也可以包含自己的状态。因此，你可以说组件是动态的——它们描述了如何将输入（props 和状态）转换为 UI 输出。</p><h3 id="谈谈你对-React-合成事件的理解"><a href="#谈谈你对-React-合成事件的理解" class="headerlink" title="谈谈你对 React 合成事件的理解"></a>谈谈你对 React 合成事件的理解</h3><p>React 的合成事件系统（Synthetic Event）是 React 对原生浏览器事件进行的一层封装，主要是为了保证在所有浏览器中事件的行为是一致的，解决了浏览器之间对事件处理的差异问题。</p><p>以下是我对 React 合成事件的一些理解：</p><ol><li><p><strong>跨浏览器的一致性</strong>：不同的浏览器可能有不同的事件模型，对同一事件可能有不同的行为。React 合成事件为所有的事件提供了一套统一的接口，保证了在所有浏览器中事件行为的一致性。例如，所有的 React 事件处理函数都会接收到一个合成事件对象，你可以通过这个对象的<code>event.preventDefault()</code>和<code>event.stopPropagation()</code>等方法来控制事件的行为。</p></li><li><p><strong>事件委派</strong>：React 使用事件委派来提高性能。在 React 中，不是直接把事件处理函数绑定到真实的节点上，而是所有的事件都被绑定到文档的根节点上。当事件发生并冒泡到根节点时，React 会根据事件的信息找到对应的组件并执行相应的事件处理函数。</p></li><li><p><strong>池化</strong>：React 为了提高性能，会复用合成事件对象。事件回调被调用后，所有的事件属性都会被清空并放入事件池中。这就意味着你无法异步访问事件对象。如果你需要异步访问事件对象，你必须调用<code>event.persist()</code>来从池中移除合成事件对象，这样 React 就不会清空这个对象的属性。</p></li><li><p><strong>合成事件和原生事件的交互</strong>：虽然 React 事件被封装在合成事件中，但你仍然可以通过<code>event.nativeEvent</code>访问到浏览器的原生事件。</p></li><li><p><strong>完全的事件支持</strong>：React 合成事件提供了对所有常见的 DOM 事件的支持，包括鼠标、键盘、剪贴板、触摸等事件。</p></li></ol><p>总的来说，React 的合成事件系统提供了一种处理浏览器事件的高效、一致且跨浏览器的方式，它是 React 中一项非常重要的特性。</p><h3 id="请解释一下-React-Fiber-是什么，以及它的主要作用和优势"><a href="#请解释一下-React-Fiber-是什么，以及它的主要作用和优势" class="headerlink" title="请解释一下 React Fiber 是什么，以及它的主要作用和优势"></a>请解释一下 React Fiber 是什么，以及它的主要作用和优势</h3><p>React Fiber 是 React 16 中新的协调引擎或者说是重新实现的堆栈，它主要<strong>解决在大型应用中由于大量的更新导致的性能问题</strong>。Fiber 的目标是增强 React 在动画、布局和手势等领域的适应性，以及在不牺牲应用响应能力的前提下，使其具有更好的可扩展性。</p><p>主要的改进和优势包括：</p><ol><li><strong>增量渲染（Incremental Rendering）：</strong> 这是 Fiber 最大的改进。之前 React 的 reconciler（协调器） 是同步的，这意味着一旦开始就必须完成整个渲染树。相比之下，Fiber 引入了增量渲染，它<strong>将工作分割成多个小任务并将其在浏览器主线程空闲时进行</strong>。这就意味着 React 不会阻塞主线程太长时间，保持应用更流畅。</li><li><strong>能够暂停、终止、重用或者重启渲染工作：</strong> 这是通过引入了一个新的数据结构 Fiber，来跟踪组件的状态以及描述工作过程的。</li><li><strong>优先级处理：</strong> Fiber 引入了任务优先级的概念。不同类型的更新可以有不同的优先级，使得一些高优先级的任务（例如动画和手势）能够打断低优先级的任务（如数据同步）的执行，这样可以保证用户界面的流畅性。</li><li><strong>并发和错误边界处理：</strong> Fiber 的架构为 React 的并发模式和错误边界提供了基础。这使得在未来 React 可以在异步渲染和错误处理等方面有更好的发展。</li></ol><p>这就是 React Fiber 的基本概念和主要优势。然而，大多数开发者可能并不需要直接与 Fiber 接触，因为它是 React 内部的实现细节，React 的公共 API 在引入 Fiber 后并没有显著改变。但是理解 Fiber 的工作原理，可以帮助我们理解 React 如何处理更新，以及如何提高性能。</p><h3 id="请描述一下-React-的-Reconciliation（调和）和-Diffing-算法"><a href="#请描述一下-React-的-Reconciliation（调和）和-Diffing-算法" class="headerlink" title="请描述一下 React 的 Reconciliation（调和）和 Diffing 算法"></a>请描述一下 React 的 Reconciliation（调和）和 Diffing 算法</h3><p>React 的调和（Reconciliation）和 Diffing 算法是 React 在更新 UI 时决定什么需要改变的核心技术。</p><p><strong>调和（Reconciliation）</strong></p><p>调和是 React 用来通过比较新旧两个虚拟 DOM 树，确定要进行哪些更新的过程。当组件的 state 或 props 发生变化时，React 会创建一个新的虚拟 DOM 树，并将其与旧的虚拟 DOM 树进行比较。这就是调和过程。</p><p><strong>Diffing 算法</strong></p><p>Diffing 算法是调和过程的一部分，用于确定具体要对 DOM 做出哪些修改。React 在两棵树间进行 diffing 时，首先比较两棵树的根节点。如果根节点的类型不同，React 会销毁旧的树并构建一个全新的树。如果根节点的类型相同，React 会递归地对子节点进行 diffing。</p><p>React 使用两个假设来优化这个过程：</p><ol><li><p>不同类型的元素会产生不同类型的树。例如，<code>&lt;a&gt;</code>元素会产生与<code>&lt;img&gt;</code>元素不同的树。</p></li><li><p>开发者可以通过<code>key</code> prop 来指示哪些子元素在不同的渲染下能保持稳定。</p></li></ol><p><strong>React Fiber</strong></p><p>需要注意的是，从 React 16（Fiber 架构）开始，React 的调和过程变得更加复杂。Fiber 引入了能够分割渲染工作的新算法，使得 React 能够根据优先级在渲染过程中暂停和继续渲染工作，从而提高了大型应用的性能。</p><p>以上就是关于 React 的调和（Reconciliation）和 Diffing 算法的基本概述，实际上这个过程包含的细节和优化要复杂得多。</p><h3 id="怎样在-React-应用中实现-Server-Side-Rendering-SSR-？"><a href="#怎样在-React-应用中实现-Server-Side-Rendering-SSR-？" class="headerlink" title="怎样在 React 应用中实现 Server-Side Rendering(SSR)？"></a>怎样在 React 应用中实现 Server-Side Rendering(SSR)？</h3><p>Server-Side Rendering (SSR) 指的是将应用在服务器端渲染成 HTML 字符串，然后发送到客户端的技术。这样做的好处是首屏加载更快，对 SEO 更友好。</p><p>在 React 中实现 SSR 主要通过以下步骤：</p><ol><li><p>使用 <code>ReactDOMServer.renderToString()</code> 方法将 React 组件转换成 HTML 字符串。这个方法会渲染 React 元素到其初始 HTML。React 返回的 HTML 将在浏览器中加载，然后 React 将连接（hydrate）到这些标记，使其成为完全交互式的。</p><p>示例代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom/server&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> html = <span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li><li><p>将生成的 HTML 字符串插入服务器的模板中，然后发送给客户端。</p></li><li><p>客户端收到服务器返回的 HTML 并加载到浏览器中，同时也会加载 React 代码，React 会在客户端“接管”（hydrate）应用。</p></li><li><p>为了避免客户端在接管应用时重新获取数据和重新渲染，我们需要在服务器端将数据序列化并嵌入到页面中，然后在客户端将数据反序列化并提供给 React 应用。</p></li></ol><p>实现 SSR 需要处理许多细节，包括路由、数据预加载、代码分割、CSS 管理等。针对这些问题，有一些库（例如 Next.js）提供了开箱即用的解决方案。</p><h3 id="请解释一下-Higher-Order-Components-HOC-和-Render-Props-的工作原理。"><a href="#请解释一下-Higher-Order-Components-HOC-和-Render-Props-的工作原理。" class="headerlink" title="请解释一下 Higher Order Components(HOC)和 Render Props 的工作原理。"></a>请解释一下 Higher Order Components(HOC)和 Render Props 的工作原理。</h3><p>高阶组件（HOC）是接收一个组件并返回一个新组件的函数。HOC 在 React 中常用于代码复用，逻辑抽象和渲染劫持。HOC 不会修改接收的组件，也不会使用继承来复制它的行为。相反，HOC 通过组合来实现功能。它是纯函数，无副作用。</p><p>例如，下面这个<code>withLoader</code>就是一个 HOC，它显示一个加载中状态，直到 WrappedComponent 获取到所需数据：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withLoader</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">isLoading</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Render Props</strong></p><p>Render Props 是一个在 React 组件中用于共享代码的简单技术。更具体的说，一个 Render Props 是一个函数，这个函数返回一个 React 元素并由我们的组件执行。</p><p>例如，下面这个<code>DataLoader</code>组件使用 Render Props 模式。它获取数据并使用一个函数作为子元素（children prop）来渲染结果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataLoader</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">data</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">url</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">children</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该组件的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">DataLoader</span> url=<span class="string">&quot;/api/data&quot;</span>&gt;</span><br><span class="line">  &#123;<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;/* Render the data */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">&lt;/<span class="title class_">DataLoader</span>&gt;</span><br></pre></td></tr></table></figure><p>这两种模式在许多情况下可以互换使用，但它们各有优点。HOC 适合用于抽象和操作 props 和 state，而 Render Props 更适合用于动态决定要渲染什么。</p><h3 id="react-和-vue-在列表渲染时都需要提供-key，请问-key-有什么作用？"><a href="#react-和-vue-在列表渲染时都需要提供-key，请问-key-有什么作用？" class="headerlink" title="react 和 vue 在列表渲染时都需要提供 key，请问 key 有什么作用？"></a>react 和 vue 在列表渲染时都需要提供 key，请问 key 有什么作用？</h3><p>在 React 和 Vue 中，当你使用列表渲染时，需要为每个列表项提供一个唯一的 key。key 的作用主要有两点：</p><ol><li>提高性能：</li></ol><p>在列表渲染时，当列表中的元素发生变化（例如添加、删除或重新排序）时，React 和 Vue 都使用 diff 算法来比较新旧虚拟 DOM 树。通过为列表项分配唯一的 key，框架可以更快地识别和追踪每个元素的变化。这样，在列表更新时，只需重新渲染有所变化的元素，而不是整个列表，从而提高渲染性能。</p><ol start="2"><li>保持组件状态：</li></ol><p>在 React 和 Vue 中，组件实例的状态（state）和列表项是相关联的。如果列表项没有分配唯一的 key，框架将很难正确追踪组件实例与列表项之间的关系。这可能导致组件状态在更新时出现错误或丢失。</p><p>例如，如果你有一个包含输入框的列表，用户在输入框中输入了一些内容。当列表发生变化时，没有分配 key 的情况下，输入框的值可能会显示在错误的列表项中，或者完全丢失。</p><p>因此，为列表项分配唯一的 key 可以确保列表更新时，框架能够正确地追踪和保持组件实例的状态。</p><p>总之，在 React 和 Vue 中使用列表渲染时，为每个列表项提供一个唯一的 key 可以提高性能，并确保组件状态在更新过程中保持正确。通常，我们使用从后端获取的数据中的唯一标识（如 ID）作为 key，如果没有唯一标识，可以使用其他可靠且唯一的值。避免使用数组的索引作为 key，因为它可能会导致性能问题和状态错误。</p><h3 id="你如何在-React-应用中处理错误？什么是错误边界-Error-Boundaries-？"><a href="#你如何在-React-应用中处理错误？什么是错误边界-Error-Boundaries-？" class="headerlink" title="你如何在 React 应用中处理错误？什么是错误边界(Error Boundaries)？"></a>你如何在 React 应用中处理错误？什么是错误边界(Error Boundaries)？</h3><p>错误处理是任何应用程序必不可少的一部分，React 也不例外。在 React 中，错误处理的主要工具是错误边界(Error Boundaries)。</p><p><strong>错误边界（Error Boundaries）</strong> 是一种 React 组件，它可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p><p>创建错误边界组件需要定义一个新的生命周期方法 <code>getDerivedStateFromError</code> 或 <code>componentDidCatch</code>。这两个生命周期方法用于捕获子组件树中的错误。</p><p>这是一个简单的错误边界组件的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state，下一次渲染将会显示 fallback UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以渲染任何自定义的 fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在任何可能需要的地方使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure><p>这样，如果 <code>MyWidget</code> 组件出错，<code>ErrorBoundary</code> 组件就会捕获到这个错误，并渲染备用 UI，而不是让整个应用崩溃。</p><h3 id="请解释下-React-的-Context-API-的工作原理，以及它如何用于全局状态管理？"><a href="#请解释下-React-的-Context-API-的工作原理，以及它如何用于全局状态管理？" class="headerlink" title="请解释下 React 的 Context API 的工作原理，以及它如何用于全局状态管理？"></a>请解释下 React 的 Context API 的工作原理，以及它如何用于全局状态管理？</h3><p>React 的 Context API 是一个创建全局状态的方式，可以让数据在组件树中传递，而不需要手动地一层一层传递 props。</p><p>首先，我们使用<code>React.createContext</code>来创建一个 Context 对象：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure><p>然后，我们可以通过 Context 的 Provider 组件将状态传递到组件树中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span> value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>任何在<code>Provider</code>内部的组件都可以通过 Context 的 Consumer 组件来订阅这个状态，或者如果这个组件是函数组件，也可以使用<code>useContext</code> Hook：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="comment">/* 根据Context value渲染某些内容 */</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br></pre></td></tr></table></figure><p>虽然 Context API 提供了管理全局状态的方法，但它并没有提供一种在应用状态发生变化时通知 React 重新渲染的方式。因此，通常我们会将 Context 与 React 组件的 state 或者其他状态管理库（如 Redux，MobX 等）结合使用，以便当状态改变时，可以通知 React 进行重新渲染。</p><p>注意，虽然 Context 可以让我们很方便的进行全局状态管理，但并不意味着我们应该尽可能的使用它。因为使用 Context 会使得组件的重用变得困难，而且也会使得组件的测试变得复杂。因此，除非你需要在很多不同层级的组件间共享状态，否则应该优先使用组件的 props 和 state。</p><h3 id="如何进行-React-性能优化？"><a href="#如何进行-React-性能优化？" class="headerlink" title="如何进行 React 性能优化？"></a>如何进行 React 性能优化？</h3><p>React 是一个非常强大的前端 JavaScript 库，用于构建用户界面。然而，随着应用规模的扩大，可能会遇到一些性能问题。下面是一些优化 React 性能的技术：</p><ol><li><p><strong>使用 PureComponent 或 shouldComponentUpdate：</strong> React.PureComponent 通过对 props 和 state 的浅对比来实现 shouldComponentUpdate()。这可以帮助你避免不必要的 render，从而提高性能。</p></li><li><p><strong>利用 React.memo：</strong> 对于函数式组件，你可以使用 React.memo 进行优化，这也是一种避免不必要 render 的方式。</p></li><li><p><strong>避免使用匿名函数或 bind：</strong> 在 render 方法中使用箭头函数或者 bind 会创建一个新的函数实例，导致无效的重新渲染。</p></li><li><p><strong>合理使用 key：</strong> 在动态渲染元素时，应为每一个元素设置唯一的 key，这样可以帮助 React 识别哪些元素发生了变化。</p></li><li><p><strong>懒加载：</strong> 对于大型项目，可以采用代码分割和懒加载的方式，减少首次加载时的数据量。</p></li><li><p><strong>使用虚拟化长列表：</strong> 当你需要处理大量的数据并显示在列表中时，可以使用虚拟化（virtualization）。这可以有效减少页面元素的数量，提高性能。</p></li><li><p><strong>使用 Web Workers 处理复杂计算：</strong> Web Workers 允许你在后台线程中运行 JavaScript，从而不阻塞用户界面。</p></li><li><p><strong>合理使用第三方库：</strong> 一些大型的第三方库可能会影响 React 应用的性能，所以在选择时应充分考虑其性能和大小。</p></li><li><p><strong>优化图片和媒体内容：</strong> 确保你的图片和媒体内容已经过优化，以尽可能减少他们的文件大小。</p></li><li><p><strong>使用 React Profiler 进行性能分析：</strong> React DevTools 提供了一个 Profiler 插件，可以帮助你找出应用中的性能瓶颈。</p></li></ol><p>以上就是一些 React 性能优化的方法，当然这只是一部分。你可能还需要根据具体的应用场景，结合多种方法进行优化。</p><h3 id="为什么多个-JSX-标签需要被一个父元素包裹？"><a href="#为什么多个-JSX-标签需要被一个父元素包裹？" class="headerlink" title="为什么多个 JSX 标签需要被一个父元素包裹？"></a>为什么多个 JSX 标签需要被一个父元素包裹？</h3><p>JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你<strong>不能在一个函数中返回多个对象</strong>，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。</p><h3 id="请描述一下-React-中的-Virtual-DOM-是如何工作的？"><a href="#请描述一下-React-中的-Virtual-DOM-是如何工作的？" class="headerlink" title="请描述一下 React 中的 Virtual DOM 是如何工作的？"></a>请描述一下 React 中的 Virtual DOM 是如何工作的？</h3><p>React 使用一种名为”Virtual DOM”的技术来帮助提高应用程序的性能。Virtual DOM（虚拟 DOM）实际上是一个或多个 JS 对象的树形结构，它表示了真实 DOM 的结构。当数据变化时，React 使用虚拟 DOM 来优化和最小化真实 DOM 的更新。以下是虚拟 DOM 工作原理的简单描述：</p><ol><li><p><strong>创建虚拟 DOM：</strong> 当你编写 React 组件并使用 JSX 时，React 会为每个组件和元素创建一个虚拟 DOM 节点。这些虚拟节点构成了一个虚拟 DOM 树。</p></li><li><p><strong>更新虚拟 DOM：</strong> 当应用程序的状态变化时，React 会创建一个新的虚拟 DOM 树。这个过程非常快，因为它发生在内存中，不涉及浏览器的布局、样式计算或绘制阶段。</p></li><li><p><strong>差异化（Diffing）：</strong> 接下来，React 会比较新旧两个虚拟 DOM 树，找出需要更新的最小修改。这个过程称为”差异化”。</p></li><li><p><strong>重新渲染：</strong> 最后，React 将这些变化应用到真实的 DOM 树上。React 尽可能地减少 DOM 操作，这有助于保持应用程序的性能，因为真实的 DOM 操作通常比虚拟 DOM 操作要昂贵得多。</p></li></ol><p>这就是虚拟 DOM 的基本工作原理。其主要优点是，通过减少直接操作 DOM 的次数，避免了昂贵的 DOM 操作，从而提高了性能。它也使得 React 可以在非浏览器环境（如服务器端渲染或者 React Native）中运行。</p><h3 id="为什么我们在构造函数中绑定this？"><a href="#为什么我们在构造函数中绑定this？" class="headerlink" title="为什么我们在构造函数中绑定this？"></a>为什么我们在构造函数中绑定<code>this</code>？</h3><p>在 JavaScript 中，<code>this</code>的上下文依赖于函数的调用方式。当我们在类的方法中使用<code>this</code>时，我们期望<code>this</code>引用的是类的实例。但是，由于事件处理程序等可能更改上下文，<code>this</code>可能不会按照我们预期的方式工作。</p><p>React 类组件的方法不会自动绑定<code>this</code>到实例。这意味着，当我们将一个方法作为回调传递（例如作为一个事件处理函数）时，<code>this</code>不会指向当前组件的实例。如果在该方法中我们尝试访问<code>this.props</code>或<code>this.state</code>，会导致错误，因为<code>this</code>的上下文已经丢失。</p><p>考虑下面的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">message</span>: <span class="string">&quot;Hello, world!&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showMessage&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们点击按钮时，<code>showMessage</code>方法会被调用，但<code>this</code>的上下文并不是<code>ExampleComponent</code>的实例，所以<code>this.state</code>是<code>undefined</code>，这将导致运行时错误。</p><p>为了解决这个问题，我们需要在构造函数中绑定<code>this</code>到我们的方法上。这可以确保无论方法在哪里被调用，<code>this</code>都将始终引用组件实例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">message</span>: <span class="string">&quot;Hello, world!&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind &#x27;this&#x27; to our method</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">showMessage</span> = <span class="variable language_">this</span>.<span class="property">showMessage</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showMessage&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，无论<code>showMessage</code>方法在何处被调用，<code>this</code>都将正确地引用<code>ExampleComponent</code>实例，我们就可以在该方法中安全地访问<code>this.state</code>和<code>this.props</code>。</p><p>此外，也可以使用箭头函数来自动绑定<code>this</code>，因为箭头函数不会创建自己的<code>this</code>上下文，而是继承它们被定义时的上下文。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">message</span>: <span class="string">&quot;Hello, world!&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  showMessage = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showMessage&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，箭头函数可能会引入一些其它问题（例如优化问题），所以在构造函数中显式地绑定<code>this</code>仍然是推荐的方式。</p><h3 id="怎样在-React-中阻止组件重新渲染？"><a href="#怎样在-React-中阻止组件重新渲染？" class="headerlink" title="怎样在 React 中阻止组件重新渲染？"></a>怎样在 React 中阻止组件重新渲染？</h3><p>在 React 中，如果希望阻止一个组件在某些情况下重新渲染，可以使用 <code>shouldComponentUpdate</code> 生命周期方法或者 <code>React.memo</code> 函数。</p><ol><li><strong>shouldComponentUpdate:</strong> 该方法只在类组件中有效。该方法接收两个参数，即新的 props 和新的 state，它默认返回 <code>true</code>。如果返回 <code>false</code>，那么 React 将跳过这次的渲染及之后的整个更新过程。</li><li><strong>React.memo:</strong> 对于函数组件，我们没有 <code>shouldComponentUpdate</code> 这个生命周期方法。不过，我们可以使用 <code>React.memo</code> 来实现类似的效果。<code>React.memo</code> 是一个高阶组件，它与 <code>shouldComponentUpdate</code> 有相似的作用，它“记住”了你的组件并且只有当 props 发生变化时才会重新渲染。</li></ol><h3 id="描述下-React-中不可变性的重要性"><a href="#描述下-React-中不可变性的重要性" class="headerlink" title="描述下 React 中不可变性的重要性"></a>描述下 React 中不可变性的重要性</h3><p>在 React 中，不可变性（Immutability）是一种重要的编程技巧，它有助于提高应用程序的性能并简化程序的复杂性。以下是不可变性在 React 中的重要性：</p><ol><li><p><strong>性能优化：</strong> 在 React 中，当组件的状态或属性更改时，组件会重新渲染。为了防止不必要的渲染，React 提供了<code>shouldComponentUpdate</code>生命周期方法（或者在 PureComponent 和 React.memo 中的自动浅比较）。通过比较新旧状态或属性，我们可以决定组件是否需要重新渲染。如果我们使用不可变数据，那么这个比较过程就变得非常简单和快速，因为我们只需要进行身份比较（<code>===</code>），而不是深度比较。如果引用没有变，那么数据就没有变。</p></li><li><p><strong>简化编程模型：</strong> 不可变性使得复杂的特性，如撤销&#x2F;重做，更容易实现。如果我们不直接修改数据，而是生成新的数据版本，那么我们可以保留旧的数据版本，以便稍后使用。</p></li><li><p><strong>更容易跟踪变化：</strong> 当我们使用不可变数据时，任何数据的变化都将导致新的对象的产生。这使得我们可以利用 React Dev Tools 或 Redux Dev Tools 等开发工具，更容易地追踪状态的变化。</p></li></ol><p>总的来说，不可变性在 React 中的重要性在于它可以帮助我们写出更清晰、更易维护的代码，并且提高应用程序的性能。因此，在 React 和使用 React 的库（如 Redux）中，都强烈推荐使用不可变数据。</p><h3 id="React-的纯组件-PureComponent-是什么？在什么情况下你会使用它？"><a href="#React-的纯组件-PureComponent-是什么？在什么情况下你会使用它？" class="headerlink" title="React 的纯组件(PureComponent)是什么？在什么情况下你会使用它？"></a>React 的纯组件(PureComponent)是什么？在什么情况下你会使用它？</h3><p>React.PureComponent 和 React.Component 非常类似，不同之处在于 React.PureComponent 实现了 <code>shouldComponentUpdate()</code> 方法，这个方法对 props 和 state 进行了浅对比。这意味着，如果你的组件的 props 或 state 变化了（即引用变化，不是内部属性变化），那么组件将会重新渲染；否则，它就不会重新渲染。</p><p>使用 PureComponent 的主要情况包括：</p><ol><li><p><strong>组件的重新渲染依赖于 props 和 state：</strong> 如果你的组件完全依赖于 props 和 state，而且你可以保证 props 和 state 的引用在需要重新渲染时才会改变，那么使用 PureComponent 可以帮助你避免不必要的渲染，从而提高性能。</p></li><li><p><strong>组件的 props 和 state 结构较为简单：</strong> PureComponent 通过浅对比来检查 props 和 state 是否变化。这意味着，如果你的 props 或 state 是嵌套的对象，那么即使对象的深层属性没有变，只要顶层对象的引用变了，PureComponent 也会触发重新渲染。因此，如果你的 props 和 state 结构较为简单，或者你能保证嵌套对象在需要重新渲染时引用才会改变，那么使用 PureComponent 可以帮助你提高性能。</p></li></ol><p>然而，也要注意 PureComponent 并不是万能的，它并不适合所有场景。在一些情况下，使用 PureComponent 反而可能带来性能问题。例如，如果你的 props 或 state 经常改变，那么 PureComponent 在每次渲染前都会进行浅对比，这可能会带来额外的性能开销。同时，由于 PureComponent 只做浅对比，如果 props 或 state 中包含复杂的嵌套数据结构，可能会导致误判，无法准确地识别出 props 或 state 是否真正变化。</p><p>在使用 PureComponent 时，你需要了解它的工作原理，以及何时使用它才能真正提高应用的性能。</p><h3 id="解释-React-的同步和异步-setState"><a href="#解释-React-的同步和异步-setState" class="headerlink" title="解释 React 的同步和异步 setState"></a>解释 React 的同步和异步 setState</h3><p>React 的<code>setState</code>方法在某些情况下是异步的，而在其他情况下是同步的。理解这一点很重要，因为它可以帮助我们理解和预测 React 的行为。</p><p><strong>异步的 setState:</strong></p><p>在大多数情况下，<code>setState</code>的行为是异步的。当我们在 React 的事件处理程序（例如 onClick、onSubmit 等）中调用<code>setState</code>时，React 会将更新排入队列，然后在稍后的时间以最有效的方式批量应用这些更新。这种方法可以增加应用的性能，因为它避免了不必要的重新渲染。</p><p><strong>同步的 setState:</strong></p><p>然而，在某些特定情况下，<code>setState</code>的行为是同步的。如果我们在 React 的生命周期方法（如<code>componentDidMount</code>或<code>componentDidUpdate</code>）或者在<code>setTimeout</code>或<code>setInterval</code>的回调函数中调用<code>setState</code>，那么它就会立即触发组件的重新渲染。</p><p>了解<code>setState</code>的这种行为对于编写预测性和可调试性的 React 代码非常重要。</p><h3 id="在-React-中使用-Portals-的场景是什么？"><a href="#在-React-中使用-Portals-的场景是什么？" class="headerlink" title="在 React 中使用 Portals 的场景是什么？"></a>在 React 中使用 Portals 的场景是什么？</h3><p>React Portals 提供了一种将子节点渲染到存在于父组件 DOM 层次结构之外的 DOM 节点的方式。</p><p>以下是一些使用 Portals 的典型场景：</p><ol><li><p><strong>模态对话框（Modals）和弹出窗口（Popovers）：</strong> 当你创建一个模态对话框或弹出窗口时，你可能希望它能覆盖整个页面，而不是仅仅覆盖父组件的范围。你也可能希望模态对话框或弹出窗口能够独立于其父组件的 Z-index。通过使用 Portals，你可以将模态对话框或弹出窗口渲染到 DOM 树的顶层，使其可以覆盖整个页面。</p></li><li><p><strong>全局通知和提示：</strong> 类似于模态对话框，你可能希望全局通知或提示能够显示在页面的顶层，并且不受任何父组件的影响。通过使用 Portals，你可以将这些元素渲染到任何你想要的位置。</p></li><li><p><strong>避免某些 CSS 问题：</strong> 在某些情况下，父组件的 CSS（例如，overflow 或 z-index）可能会影响或限制子组件的显示。在这种情况下，你可以使用 Portals 将子组件渲染到父组件的 DOM 结构之外，以避免这些 CSS 问题。</p></li></ol><p>总的来说，React Portals 是一种强大的工具，它可以帮助你在需要在 DOM 结构上“跳出”父组件边界的时候进行渲染。然而，使用 Portals 也需要注意一些问题，例如，你需要确保正确地管理和清理在 Portals 中渲染的元素，以避免内存泄漏等问题。</p><h3 id="在-React-中使用-Redux-和-MobX-的主要区别是什么？"><a href="#在-React-中使用-Redux-和-MobX-的主要区别是什么？" class="headerlink" title="在 React 中使用 Redux 和 MobX 的主要区别是什么？"></a>在 React 中使用 Redux 和 MobX 的主要区别是什么？</h3><p>Redux 和 MobX 都是用于管理 React 应用状态的流行库，但他们的方法和概念差异较大。</p><p><strong>Redux</strong>:</p><p>Redux 基于 Flux 架构，使用单向数据流，并且维护一个不可变的全局状态树。在 Redux 中，所有的状态改变都通过分发（dispatching）预定义的操作（actions）来触发，并由纯函数（reducer）处理。</p><p>Redux 的主要特点：</p><ul><li><strong>单一的状态树</strong>：所有的应用状态都存储在一个大的对象中。</li><li><strong>不可变状态</strong>：状态不能直接修改，只能通过分发操作并处理 reducer 函数来改变。</li><li><strong>纯函数和可预测性</strong>：reducer 函数必须是纯函数，给定相同的输入，总是返回相同的输出。</li></ul><p><strong>MobX</strong>:</p><p>相比之下，MobX 采用更加直观和灵活的方式管理状态。它通过<strong>反应性系统自动跟踪状态改变</strong>，并更新相关的组件。</p><p>MobX 的主要特点：</p><ul><li><strong>可观察的状态</strong>：你可以声明应用状态为可观察的（observable），并将 React 组件转化为观察者（observer）。</li><li><strong>自动的派生</strong>：当状态改变时，MobX 会自动更新依赖这些状态的函数、计算值和组件。</li><li><strong>直接修改状态</strong>：你可以直接修改状态，而不需要分发操作或使用 reducer 函数。</li></ul><p><strong>Redux 和 MobX 的选择</strong>:</p><p>选择使用 Redux 或 MobX 主要取决于你的团队和项目的需求。</p><p>如果你想要一个严格的、可预测的数据流和状态管理，那么 Redux 可能是更好的选择。Redux 的严格性使得它非常适合于大型的、复杂的项目，或者需要处理一致性问题的项目。</p><p>相反，如果你需要更快的开发速度和更高的灵活性，或者你的项目并不需要处理复杂的状态管理问题，那么 MobX 可能是更好的选择。MobX 的简洁和直观使得它更易于理解和使用，尤其是对于那些不熟悉 Flux 架构或者函数式编程的开发者。</p><h3 id="谈谈你对-Flux-的理解"><a href="#谈谈你对-Flux-的理解" class="headerlink" title="谈谈你对 Flux 的理解"></a>谈谈你对 Flux 的理解</h3><p>Flux 是 Facebook 为其 React 视图库创建的应用架构模式，用于处理数据流动。</p><p>Flux 架构的核心是一个单向数据流，其中包含四个主要部分：Dispatcher、Stores、Views（React 组件）和 Actions。</p><ol><li><p><strong>Actions</strong>：Actions 是一个简单的 JavaScript 对象，它描述了应用中发生的事件，但不指定应用状态如何更新。Action 对象可以由用户交互、网络响应等产生，然后被分发（dispatched）给 Store。</p></li><li><p><strong>Dispatcher</strong>：Dispatcher 是 Flux 应用中的中央枢纽。当 Action 被触发时，Dispatcher 会将 Action 分发到所有注册在其上的 Store。</p></li><li><p><strong>Stores</strong>：Stores 负责存储应用的状态和逻辑。每个 Store 都维护一个特定领域内的状态，例如用户的登录状态或购物车的内容。当 Store 接收到 Dispatcher 分发来的 Action 时，会根据 Action 的类型更新其状态。Store 状态的更新通常通过 switch-case 语句或者 if-else 逻辑来实现。</p></li><li><p><strong>Views</strong>：Views（通常是 React 组件）从 Store 中读取状态并显示。当 Store 的状态发生变化时，会通知 Views，然后 Views 重新渲染。</p></li></ol><p>这四个部分构成了 Flux 的单向数据流：Actions 被分发到 Store，Store 处理 Action 并更新状态，然后通知 Views 重新渲染。</p><p>Flux 架构的主要优点是其数据流动的明确性和可预测性。因为数据总是按照一个固定的方向流动，所以在调试和理解应用的行为时更容易追踪数据。这特别对于构建大型、复杂的前端应用非常有用。</p><h3 id="vue-和-react-框架之间有什么不同？"><a href="#vue-和-react-框架之间有什么不同？" class="headerlink" title="vue 和 react 框架之间有什么不同？"></a>vue 和 react 框架之间有什么不同？</h3><p>Vue 和 React 都是现代前端框架，分别由 Evan You 和 Facebook 团队开发。它们旨在帮助开发者构建高效、可维护的用户界面。尽管它们有许多相似之处，但在一些关键方面存在一些不同。以下是 Vue 和 React 之间的一些主要差异：</p><ol><li>模板语法和 JSX：</li></ol><p>Vue 使用模板语法，将 HTML、CSS 和 JavaScript 集成在一起。Vue 的模板是基于 HTML 的，这使得它们对于前端开发者来说非常熟悉。Vue 提供了一些特殊的属性和指令（如 v-for、v-if 等），以便于操作 DOM 和组件。</p><p>React 使用 JSX（JavaScript XML），它是一种 JavaScript 语法扩展，允许在 JavaScript 代码中编写类似 HTML 的结构。与 Vue 的模板语法不同，JSX 更接近于 JavaScript，需要熟悉 JavaScript 语法的开发者。</p><ol start="2"><li>数据绑定：</li></ol><p>Vue 提供了双向数据绑定，通过 v-model 指令可以轻松实现。这使得在表单元素和数据之间建立双向绑定变得非常简单。</p><p>React 默认使用单向数据流，父组件通过属性（props）将数据传递给子组件。实现双向数据绑定需要编写更多的代码，通常需要使用回调函数或状态管理库（如 Redux）。</p><ol start="3"><li>组件通信：</li></ol><p>Vue 为组件通信提供了内置的事件系统（通过 $emit 和 $on），以及 props。这使得在 Vue 应用中实现组件间通信相对简单。</p><p>React 使用 props 和回调函数进行组件间通信。虽然它没有内置的事件系统，但可以使用第三方库（如 Redux 或 MobX）来实现更复杂的通信。</p><ol start="4"><li>生态系统：</li></ol><p>Vue 拥有一个相对更小但紧密的生态系统。Vue 的官方库（如 Vuex、Vue Router 等）为开发者提供了许多功能。Vue 社区也积极维护了许多插件和库。</p><p>React 拥有一个庞大的生态系统，可以为开发者提供各种各样的解决方案。React 社区很大，拥有大量的库和插件，可以满足不同的需求。但是，这也意味着在选择最佳实践和工具时可能需要进行更多的研究。</p><ol start="5"><li>学习曲线：</li></ol><p>Vue 通常被认为具有较低的学习曲线，尤其是对于那些熟悉 HTML、CSS 和 JavaScript 的前端开发者。Vue 的文档易于理解，模板语法直观，使得初学者更容易上手。</p><p>React 的学习曲线可能会略高一些，因为 JSX 和函数式编程概念需要一些时间适应。然而，React 的文档也相当详细，并有大量的社区资源可供参考。</p><ol start="6"><li>可扩展性：</li></ol><p>Vue 为开发者提供了灵活的选项，可以根据项目的需求进行配置。Vue 提供了许多内置功能和官方库，有助于保持一致性和实现快速开发。</p><p>React 本身非常灵活，可以很好地与各种库和工具集成。这使得 React 更容易适应不同类型的项目。然而，这种灵活性也意味着开发者需要在选择最佳实践和工具时进行更多的研究。</p><ol start="7"><li>性能：</li></ol><p>Vue 和 React 都具有出色的性能。它们都使用虚拟 DOM 技术，通过高效地比较新旧虚拟 DOM 来实现最小化的真实 DOM 更新。尽管在大多数情况下性能差异不大，但根据应用程序的具体需求和实现方式，两者之间可能存在一些差异。</p><ol start="8"><li>企业和社区支持：</li></ol><p>React 由 Facebook 开发和维护，拥有大量的企业和社区支持。这使得 React 成为一个非常稳定和可靠的选择，特别是对于大型企业级应用程序。</p><p>Vue 是一个独立的开源项目，由 Evan You 和一个活跃的社区维护。Vue 在亚洲市场尤其受欢迎，但在全球范围内也越来越受到认可。虽然它可能没有 React 那样庞大的支持，但 Vue 仍然是一个非常可靠和稳定的框架。</p><p>总结：</p><p>Vue 和 React 分别有各自的优势和特点。Vue 的模板语法和双向数据绑定使其易于上手和快速开发，而 React 提供了高度灵活的架构和庞大的生态系统。在选择框架时，需要根据项目需求、团队经验和个人偏好来决定使用哪一个。</p><h3 id="vue-的-diff-算法，遍历-Vdom-使用的是深度优先遍历还是广度优先遍历？"><a href="#vue-的-diff-算法，遍历-Vdom-使用的是深度优先遍历还是广度优先遍历？" class="headerlink" title="vue 的 diff 算法，遍历 Vdom 使用的是深度优先遍历还是广度优先遍历？"></a>vue 的 diff 算法，遍历 Vdom 使用的是深度优先遍历还是广度优先遍历？</h3><p>Vue 3 使用了虚拟 DOM (Vdom)，并采用深度优先遍历 (Depth-First Traversal) 来进行比较和更新。这种遍历方式沿着每个分支尽可能深地遍历节点树，然后回溯。</p><p>当渲染一个新的视图时，Vue 3 会创建一颗新的虚拟 DOM 树并将其与旧的虚拟 DOM 树进行比较。这一比较过程通过深度优先遍历实现，从而找出两棵树之间的差异，然后将这些差异应用到实际的 DOM 树上，从而有效地更新视图。</p><p>深度优先遍历可以更容易地检测具体子树的更改，这对于在更新过程中维护组件的状态和生命周期很重要。这也与 React 的 diff 算法相似，都是倾向于采用深度优先遍历。</p><h3 id="MVC-和-MVVM-框架的区别？"><a href="#MVC-和-MVVM-框架的区别？" class="headerlink" title="MVC 和 MVVM 框架的区别？"></a>MVC 和 MVVM 框架的区别？</h3><p>MVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）都是软件架构设计模式，用于分离应用程序的关注点，以提高可维护性和可扩展性。尽管它们有相似之处，但它们的实现方式和组件之间的交互有所不同。</p><ol><li>MVC（Model-View-Controller）：</li></ol><ul><li>Model：代表应用程序的数据模型和业务逻辑。它负责处理数据存储和检索。</li><li>View：代表用户界面，展示数据给用户，并接收用户输入。</li><li>Controller：处理用户输入，将用户操作转换为 Model 更新，并通知 View 更新。</li></ul><p>在 MVC 架构中，View 和 Controller 之间存在较强的依赖关系。用户输入由 Controller 处理，Controller 更新 Model，然后 Model 通知 View 更新。这样的双向通信使得 View 和 Controller 的耦合度较高。</p><ol><li>MVVM（Model-View-ViewModel）：</li></ol><ul><li>Model：与 MVC 中的 Model 相同，代表应用程序的数据模型和业务逻辑。</li><li>View：代表用户界面，负责展示数据和接收用户输入。但在 MVVM 架构中，View 不直接与 Model 交互。</li><li>ViewModel：扮演 View 和 Model 之间的中介，负责将 Model 中的数据转换为 View 可以显示的数据，同时将 View 的用户输入转换为 Model 可以理解的操作。</li></ul><p>MVVM 架构的关键特点是数据绑定（Data Binding），它允许 View 和 ViewModel 之间自动同步数据。这样，当 Model 数据发生变化时，View 会自动更新；当用户在 View 中进行操作时，ViewModel 会自动更新 Model。这种自动同步减少了 View 和 ViewModel 之间的直接交互，降低了它们之间的耦合度。</p><p>总结：MVC 和 MVVM 都是用于分离关注点的架构设计模式。MVC 通过 Controller 来处理用户输入并更新 Model 和 View，而 MVVM 利用 ViewModel 作为 Model 和 View 之间的中介，实现数据绑定。MVVM 架构相较于 MVC，降低了组件之间的耦合度，使得代码更易于维护和扩展。许多现代前端框架（如 Vue 和 React）采用了类似 MVVM 的设计模式。</p><hr /><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="对-Webpack-做过哪些优化？"><a href="#对-Webpack-做过哪些优化？" class="headerlink" title="对 Webpack 做过哪些优化？"></a>对 Webpack 做过哪些优化？</h3><p>Webpack 是一个非常强大的模块打包器，它可以帮助开发者处理代码依赖、打包、压缩等任务。在使用 Webpack 的过程中，我们可以通过一些方法优化项目，提高性能和用户体验。以下是一些常见的 Webpack 优化方法：</p><ol><li>Tree shaking：通过此技术，Webpack 可以消除未使用的代码，从而减少最终包的大小。为了实现这一点，确保在 package.json 文件中设置 “sideEffects” 选项。</li><li>代码分割（Code Splitting）：将代码分割成不同的 chunks，从而实现按需加载和并行加载。这可以减少首次加载时间和浏览器解析时间。可以使用 SplitChunksPlugin 和动态 import() 实现代码分割。</li><li>懒加载（Lazy Loading）：懒加载是一种按需加载策略，只有在实际需要时才加载某些代码。这可以显著减少首屏加载时间。</li><li>使用缓存：通过设置 cache-loader、HardSourceWebpackPlugin 或其他缓存插件，可以利用缓存加快构建速度。</li><li>压缩代码：使用插件如 TerserPlugin（用于 JavaScript）和 MiniCssExtractPlugin（用于 CSS）对代码进行压缩，减少代码体积，提高加载速度。</li><li>使用 DLL：通过使用 DllPlugin 和 DllReferencePlugin，可以将第三方库与应用程序代码分离，从而减少构建时间。</li><li>配置 resolve.alias：通过配置 resolve.alias，可以缩短查找模块的路径，从而提高构建速度。</li><li>使用 Web Workers 或 Service Workers：通过将一些任务放在后台线程中处理，可以提高应用程序的性能。</li><li>提取 CSS：通过使用 MiniCssExtractPlugin，可以将 CSS 从 JS 中分离出来，提高加载性能。</li><li>使用 Loaders 和 Babel：通过配置不同的 loaders 和 Babel 插件，可以在构建过程中优化代码，例如转换 ES6 语法、移除 console.log 等。</li><li>配置性能提示：通过配置 performance.hints 和 performance.assetFilter，可以监控和优化构建产物的大小。</li><li>使用 Webpack Bundle Analyzer：通过这个插件，可以分析和可视化 Webpack 输出的文件，从而帮助发现潜在的优化点。</li></ol><p>这些是在使用 Webpack 时可以采取的一些优化方法。针对具体项目，可能还需要结合实际情况进行更多优化。</p><h3 id="Wepback-的生命周期有哪些？"><a href="#Wepback-的生命周期有哪些？" class="headerlink" title="Wepback 的生命周期有哪些？"></a>Wepback 的生命周期有哪些？</h3><p>Webpack 的生命周期主要由以下几个阶段组成：</p><ol><li>初始化（Initialization）：在这个阶段，Webpack 会读取配置文件（如：webpack.config.js）和命令行参数，然后创建一个新的 Compiler 实例。这个实例包含了整个构建过程中的配置、插件、Loaders 等相关信息。</li><li>解析（Resolution）：Webpack 根据入口文件（entry）开始逐层解析依赖关系。对于每个解析到的模块文件，Webpack 都会检查是否需要使用对应的 Loaders 进行转换和处理。此阶段的主要目的是创建一个依赖图（Dependency Graph），其中包含了项目中所有模块及其相互依赖关系。</li><li>编译（Compilation）：在这个阶段，Webpack 开始根据依赖图逐个编译模块。对于每个模块，Webpack 会首先执行预编译任务（如使用 Babel 转换 ES6 语法），然后调用相应的 Loaders 处理模块内容。编译完成后，Webpack 会生成一个中间表示（Intermediate Representation，简称 IR），这是一个包含所有模块及其处理结果的对象。</li><li>输出（Emit）：Webpack 将 IR 转换为最终的输出文件（如：bundle.js）。在这个阶段，Webpack 会执行优化任务（如代码压缩、文件名哈希化），并将处理后的文件写入磁盘。输出完成后，Webpack 会触发相应的钩子（如：onEmit、afterEmit），以便插件可以执行自定义操作。</li><li>完成（Done）：构建流程完成后，Webpack 会触发一系列完成钩子（如：onDone、afterDone），以便插件可以执行清理和统计任务。此时，Webpack 会输出构建结果，包括处理后的文件、错误、警告等信息。</li></ol><p>这些阶段概述了 Webpack 的生命周期。在这个过程中，Webpack 会调用许多内置的插件和钩子函数来处理文件和资源。开发者还可以通过自定义插件和钩子来扩展和控制 Webpack 的行为。</p><h3 id="Webpack-有哪些常见的-Loader？"><a href="#Webpack-有哪些常见的-Loader？" class="headerlink" title="Webpack 有哪些常见的 Loader？"></a>Webpack 有哪些常见的 Loader？</h3><ol><li>babel-loader：用于将 ES6&#x2F;ES7 语法转换为浏览器兼容的 ES5 语法。</li><li>css-loader：解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code>，将 CSS 转换为 JavaScript 模块。</li><li>style-loader：将 CSS 作为样式标签插入到 HTML 文档中。</li><li>less-loader：将 Less 代码转换为 CSS 代码。</li><li>sass-loader：将 Sass&#x2F;SCSS 代码转换为 CSS 代码。</li><li>postcss-loader：使用 PostCSS 对 CSS 进行处理，如自动添加浏览器前缀、压缩 CSS 等。</li><li>file-loader：处理文件引用，将文件复制到输出目录，并返回文件的 URL。</li><li>url-loader：将文件以 base64 编码的形式内联到代码中，可以减少 HTTP 请求次数。</li><li>image-webpack-loader：压缩和优化图像文件。</li><li>ts-loader：将 TypeScript 转换为 JavaScript。</li></ol><h3 id="Webpack-有哪些常见的-Plugin？"><a href="#Webpack-有哪些常见的-Plugin？" class="headerlink" title="Webpack 有哪些常见的 Plugin？"></a>Webpack 有哪些常见的 Plugin？</h3><ol><li>HtmlWebpackPlugin：生成一个 HTML 文件，并自动引入所有生成的脚本和样式。</li><li>MiniCssExtractPlugin：将 CSS 提取为单独的文件，而不是将其内联到 JavaScript 中。</li><li>CleanWebpackPlugin：在每次构建前清理输出目录。</li><li>DefinePlugin：允许在编译时创建全局常量，用于在开发和生产环境中区分不同的行为。</li><li>TerserPlugin：压缩和优化 JavaScript 代码。</li><li>OptimizeCSSAssetsPlugin：压缩和优化 CSS 文件。</li><li>HotModuleReplacementPlugin：实现模块热替换，用于开发环境。</li><li>CopyWebpackPlugin：将静态资源复制到输出目录。</li><li>SplitChunksPlugin：实现代码分割，提高加载性能。</li><li>CompressionWebpackPlugin：使用 Gzip 或 Brotli 压缩生成的资源文件。</li></ol><h3 id="Webpack-中-Loader-和-Plugin-的区别？"><a href="#Webpack-中-Loader-和-Plugin-的区别？" class="headerlink" title="Webpack 中 Loader 和 Plugin 的区别？"></a>Webpack 中 Loader 和 Plugin 的区别？</h3><ol><li>Loader 用于转换和处理模块。它是一个函数，接收源文件作为输入，并输出处理后的结果。Loader 的作用是对源代码进行处理，例如编译、压缩、转换等。常见的 Loader 任务包括：将 Sass&#x2F;SCSS 转换为 CSS、将 ES6 代码转换为浏览器兼容的代码等。</li><li>Plugin 是用于扩展 Webpack 功能的插件。它可以在构建流程中的不同阶段执行不同的任务，如清理输出目录、生成 HTML 文件等。Plugin 的作用范围更广泛，它可以访问 Webpack 的整个编译过程，从而实现各种复杂的功能。</li></ol><p>Loader 主要负责对模块的转换和处理，而 Plugin 负责完成更广泛的任务，包括编译过程中的各种钩子和自定义功能。</p><h3 id="Wepback5-有哪些新特性？"><a href="#Wepback5-有哪些新特性？" class="headerlink" title="Wepback5 有哪些新特性？"></a>Wepback5 有哪些新特性？</h3><ol><li>持久缓存：Webpack 5 引入了文件系统缓存，可以在多次构建之间持久存储中间结果。这可以显著提高重复构建的速度。</li><li>模块联邦（Module Federation）：这是一个允许多个独立构建共享代码的新特性。模块联邦可以在不牺牲性能的情况下实现微前端架构。</li><li>更好的 Tree Shaking：Webpack 5 改进了 Tree Shaking，可以更有效地移除无用代码。</li><li>默认支持 Content Hash：现在默认为输出文件名添加内容哈希，以实现长期缓存优化。</li><li>更小的运行时代码：Webpack 5 的运行时代码更小，有助于减小最终生成的包的大小。</li><li>改进的代码分割策略：Webpack 5 对 SplitChunksPlugin 的默认配置进行了优化，以更好地支持公共代码的提取。</li><li>移除了一些过时的特性：Webpack 5 移除了一些不推荐使用的特性，如 Node.js 的 polyfill。</li></ol><h3 id="谈谈你对-Source-map-的理解，生产环境如何使用？"><a href="#谈谈你对-Source-map-的理解，生产环境如何使用？" class="headerlink" title="谈谈你对 Source map 的理解，生产环境如何使用？"></a>谈谈你对 Source map 的理解，生产环境如何使用？</h3><p>Source Map 是一种映射文件，用于将压缩、转换后的代码映射回原始源代码。这可以帮助开发者在浏览器中调试压缩、转换后的代码。Source Map 文件通常具有 <code>.map</code> 扩展名，与生成的代码文件一起分发。浏览器可以解析这些 Source Map 文件，从而在调试时显示原始代码。</p><p>在生产环境中，你可能希望隐藏源代码或者避免额外的 HTTP 请求。一种方法是将 Source Map 上传到错误跟踪服务（如 Sentry），这样只有当出现错误时，错误跟踪服务才会下载并使用 Source Map。另一种方法是将 Source Map 内联到生成的代码文件中，这样可以避免额外的 HTTP 请求。然而，这会增加生成的文件大小，可能会影响性能。</p><h3 id="谈谈你对热更新的理解"><a href="#谈谈你对热更新的理解" class="headerlink" title="谈谈你对热更新的理解"></a>谈谈你对热更新的理解</h3><p>热更新（Hot Module Replacement，简称 HMR）是一种用于提高开发效率的技术。在应用程序运行过程中，HMR 可以实时替换、添加或删除模块，而无需刷新整个页面。这样，开发者可以立即看到更改的效果，而不会丢失应用程序的状态。Webpack 的 HotModuleReplacementPlugin 插件可以实现 HMR 功能。</p><h3 id="谈谈你对-Babel-的理解，并说下它的原理"><a href="#谈谈你对-Babel-的理解，并说下它的原理" class="headerlink" title="谈谈你对 Babel 的理解，并说下它的原理"></a>谈谈你对 Babel 的理解，并说下它的原理</h3><p>Babel 是一个 JavaScript 编译器，用于将最新的 JavaScript 语法（如 ES6、ES7）转换为浏览器兼容的 ES5 语法。Babel 的主要功能是确保你编写的代码在所有浏览器中都能正常运行，不受浏览器对新特性支持程度的影响。</p><p>Babel 的原理：</p><ol><li>解析（Parsing）：Babel 首先将源代码解析为一个抽象语法树（Abstract Syntax Tree，简称 AST）。解析过程中，Babel 将源代码分解成词素（Tokens），然后根据语法规则将词素组合成 AST。AST 是一种树状结构，用于表示源代码的语法结构。</li><li>转换（Transforming）：在 AST 的基础上，Babel 使用插件（plugins）和预设（presets）进行转换。插件是用于实现具体语法转换或优化的功能模块，例如将箭头函数转换为普通函数。预设是一组插件的集合，用于处理一组相关的语法特性，如 ES2015+ 的新特性。</li><li>生成（Generating）：在转换阶段完成后，Babel 将修改后的 AST 转换回 JavaScript 代码。生成阶段可以保留原始代码中的格式和注释，或者使用压缩插件对代码进行优化。</li></ol><p>Babel 允许开发者使用最新的 JavaScript 语法和特性，同时确保代码在各种浏览器中兼容。通过对代码进行转换和优化，Babel 可以提高代码的可维护性和性能。</p><h3 id="谈谈你对-Vite-的理解"><a href="#谈谈你对-Vite-的理解" class="headerlink" title="谈谈你对 Vite 的理解"></a>谈谈你对 Vite 的理解</h3><p>Vite（法语单词，意为“快速”的意思）是一种现代化的前端构建工具，由 Vue.js 作者尤雨溪（Evan You）创建。Vite 的目标是为现代浏览器提供一个更轻量级、快速的开发和构建工具。它主要解决了一些传统构建工具（如 Webpack）在开发过程中的瓶颈问题，从而提高了开发者的效率。</p><p>Vite 的主要特点和优势包括：</p><ol><li>基于浏览器原生 ES modules：Vite 利用浏览器原生支持的 ES modules 功能，实现了按需加载和快速的开发服务器。这消除了开发环境中构建和热更新的瓶颈，从而大幅提高了开发速度。</li><li>快速冷启动：与 Webpack 等传统构建工具相比，Vite 具有更快的冷启动速度。这是因为 Vite 在开发环境下无需进行整体构建，而是直接为请求的模块提供服务。</li><li>轻量级：Vite 的核心功能非常轻量，使得它在下载、安装和运行时更加高效。</li><li>热模块替换（HMR）：Vite 支持 HMR，这使得开发者在开发过程中可以在不刷新页面的情况下看到更改的结果，从而提高开发效率。</li><li>构建性能优化：虽然 Vite 旨在提供快速的开发环境，但它也支持高效的生产环境构建。Vite 使用 Rollup 进行生产环境构建，可以实现 Tree Shaking、代码分割等优化功能。</li><li>插件系统：Vite 提供了一个简单易用的插件系统，可以方便地扩展和定制 Vite 的功能。许多社区插件可以满足不同需求，如 CSS 处理、图片优化等。</li><li>框架支持：Vite 不仅支持 Vue.js，还支持 React、Preact、Svelte 等其他流行的前端框架。</li><li>开箱即用的特性：Vite 集成了一些常用的开发工具和特性，如 CSS 预处理器支持（Sass、Less 等）、TypeScript 支持等，无需额外配置即可使用。</li></ol><p>总之，Vite 是一种新型的前端构建工具，它提供了快速的开发环境、高效的构建性能和易用的插件系统。尤其对于开发现代前端应用程序，Vite 可以大大提高开发效率。</p><h3 id="谈谈你对-Gulp-的理解"><a href="#谈谈你对-Gulp-的理解" class="headerlink" title="谈谈你对 Gulp 的理解"></a>谈谈你对 Gulp 的理解</h3><p>Gulp 是一个流行的前端自动化构建工具，通过它可以自动执行各种重复性、繁琐的任务，从而提高开发效率。Gulp 使用流（stream）来处理文件，这样可以减少磁盘 I&#x2F;O，提高任务执行速度。</p><p>以下是关于 Gulp 的一些主要理解：</p><ol><li>简单易用：Gulp 的 API 非常简单直观，只需要几个主要的方法（如 src、dest、watch、task 和 series&#x2F;parallel）就可以编写自动化任务。Gulpfile.js（Gulp 配置文件）通常是易于阅读和维护的。</li><li>插件生态：Gulp 拥有丰富的插件生态系统，可以通过安装和配置插件来实现各种任务，如编译 SASS、压缩 JavaScript、优化图片等。</li><li>基于流（Stream）：Gulp 的核心特点是使用 Node.js 流来处理文件，这使得 Gulp 可以在内存中处理文件，避免了不必要的磁盘读写。这种处理方式使得 Gulp 任务执行速度更快。</li><li>代码即配置：与基于配置文件的构建工具（如 Webpack、Grunt）不同，Gulp 使用代码来定义任务。这使得 Gulpfile.js 更加灵活和可定制，可以根据项目需求编写特定的任务。</li><li>自动化任务管理：Gulp 可以监视文件变化，当检测到变化时自动执行相关任务。这可以确保开发过程中，项目始终处于最新状态，提高开发效率。</li><li>并行和串行任务执行：Gulp 提供了 series() 和 parallel() 方法，可以方便地组合任务，实现串行或并行执行。这可以最大程度地利用多核 CPU 的性能，提高任务执行速度。</li></ol><p>尽管现在前端构建工具有很多选择，如 Webpack、Parcel 和 Vite 等，但 Gulp 仍然在一些特定场景下具有优势。例如，对于一些简单的前端项目，或者需要灵活、定制化的构建流程，Gulp 是一个很好的选择。</p><h3 id="谈谈-Webpack、Vite-和-Gulp-三者之间的区别"><a href="#谈谈-Webpack、Vite-和-Gulp-三者之间的区别" class="headerlink" title="谈谈 Webpack、Vite 和 Gulp 三者之间的区别"></a>谈谈 Webpack、Vite 和 Gulp 三者之间的区别</h3><p>Webpack、Vite 和 Gulp 是三种流行的前端构建工具，它们之间有一些显著的区别：</p><ol><li>Webpack：<ul><li>Webpack 是一个模块打包器，主要用于 JavaScript 应用程序的打包和优化。</li><li>它支持各种资源（如 JS、CSS、图片、字体等）的加载和处理。</li><li>Webpack 支持代码分割、懒加载、Tree Shaking 等优化策略，有助于提高应用程序的性能。</li><li>通过插件系统，Webpack 可以进行高度定制，满足各种项目需求。</li><li>缺点是配置相对复杂，构建速度在某些情况下较慢。</li></ul></li><li>Vite：<ul><li>Vite 是一个基于 ES modules 的开发服务器和构建工具，由 Vue.js 作者尤雨溪创建。</li><li>Vite 利用原生 ES 模块（ESM）特性，实现快速开发服务器和按需编译。</li><li>Vite 支持 HMR（热模块替换），提高开发效率。</li><li>Vite 使用 Rollup 进行生产环境构建，具有出色的 Tree Shaking 能力。</li><li>Vite 配置相对简单，易于上手，但某些场景下可能没有 Webpack 那么灵活。</li></ul></li><li>Gulp：<ul><li>Gulp 是一个基于流（stream）的任务运行器，主要用于自动化处理前端资源。</li><li>Gulp 通过编写任务，可以实现各种复杂的构建流程，如编译 SASS、压缩 JS 等。</li><li>Gulp 的核心优势在于其流式处理，减少磁盘 I&#x2F;O，提高任务执行速度。</li><li>Gulp 使用代码定义任务，具有很好的灵活性，适用于简单项目或高度定制化的构建需求。</li><li>缺点是 Gulp 不支持模块打包，需要与其他工具（如 Webpack、Rollup）结合使用以实现完整的构建流程。</li></ul></li></ol><p>总结：</p><p>Webpack、Vite 和 Gulp 之间的主要区别在于它们的使用场景、核心功能和处理方式。Webpack 是一个功能丰富的模块打包器，适用于各种类型的项目。Vite 是一个轻量级、高性能的开发服务器和构建工具，尤其适用于现代框架项目。Gulp 是一个灵活的任务运行器，用于处理前端资源和自动化工作流。在实际项目中，开发者可以根据需求选择合适的工具，甚至将它们组合使用以实现最佳的构建流程。</p><hr /><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h3 id="前端常见的性能优化有哪些？"><a href="#前端常见的性能优化有哪些？" class="headerlink" title="前端常见的性能优化有哪些？"></a>前端常见的性能优化有哪些？</h3><p>前端性能优化是为了提高用户体验和页面响应速度的一种手段。以下是一些常见的前端性能优化方法：</p><ol><li>优化图片：对图片进行压缩、使用合适的格式（例如，WebP）和尺寸，以及利用图片懒加载技术。</li><li>使用 CDN（内容分发网络）：将静态资源分发到全球各地的服务器，减少用户加载资源的延迟。</li><li>缓存策略：利用浏览器缓存策略，如 Cache-Control 和 ETag，减少重复请求。</li><li>代码压缩与优化：通过压缩和移除不必要的代码，减小文件大小。同时优化代码逻辑，提高代码执行效率。</li><li>异步加载：使用异步加载技术（如，async 和 defer 属性）减少阻塞渲染的脚本。</li><li>利用浏览器渲染优化：避免强制同步布局，减少重排和重绘。</li><li>使用 CSS3 硬件加速：利用 GPU 加速，提高动画和页面渲染性能。</li><li>优化 CSS 选择器：使用简洁、高效的 CSS 选择器，提高渲染速度。</li><li>代码分割与按需加载：通过代码分割和按需加载技术，降低首次页面加载时间。</li><li>使用 Web Workers：利用 Web Workers 进行后台处理，避免阻塞主线程。</li><li>服务端渲染（SSR）与预渲染：利用服务端渲染和预渲染技术，加快首屏渲染速度。</li><li>优化字体加载：减少字体文件大小，使用字体加载策略避免阻塞渲染。</li><li>使用 HTTP&#x2F;2：使用 HTTP&#x2F;2 协议，实现多路复用，降低网络延迟。</li><li>优化资源优先级：利用<code>&lt;link rel=&quot;preload&quot;&gt;</code> 和 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 标签，优化资源加载顺序。</li><li>使用事件委托，利用冒泡机制处理事件。</li><li>使用防抖、节流处理频繁触发的事件。</li></ol><p>以上只是一部分常见的前端性能优化方法，实际应用时还需要根据项目具体需求和场景来选择合适的优化策略。</p><h3 id="讲下虚拟列表的原理"><a href="#讲下虚拟列表的原理" class="headerlink" title="讲下虚拟列表的原理"></a>讲下虚拟列表的原理</h3><p>虚拟列表（Virtual List）又称无限滚动列表或者长列表优化，是一种前端性能优化技术。其主要目的是在处理大量数据列表时，提高用户体验和页面性能。以下是虚拟列表的基本原理：</p><ol><li>渲染可视区域的列表项：虚拟列表的核心思想是仅渲染可见部分的列表项。当用户滚动列表时，根据可视区域的大小，计算需要显示的列表项，然后只渲染这些列表项。</li><li>列表项的位置计算：虚拟列表需要计算每个列表项的位置信息，以便在滚动过程中正确地显示列表项。这通常通过索引和固定高度（或者预估高度）来实现。</li><li>复用列表项 DOM 元素：为了减少创建和销毁 DOM 元素的性能开销，虚拟列表通常会复用列表项的 DOM 元素。当一个列表项滚出可视区域时，它的 DOM 元素会被重新利用，用于显示新的列表项。</li><li>占位元素：虚拟列表通常会使用一个占位元素（如一个空的 div）来模拟整个列表的高度。这样可以使滚动条保持正确的位置和大小，使用户能够像正常列表一样进行滚动操作。</li><li>事件监听与更新：虚拟列表需要监听滚动事件，以便在用户滚动时实时更新可视区域的列表项。此外，如果列表数据发生变化，虚拟列表还需要重新计算位置信息并更新可视区域的列表项。</li></ol><p>通过上述原理，虚拟列表能够显著减少大量列表项的渲染成本，从而提高页面的性能和用户体验。在实际应用中，根据项目的具体需求和场景，可能还需要对虚拟列表进行一定的定制和优化。</p><h3 id="讲讲常见的性能指标有哪些？它们分别对应的作用是什么？"><a href="#讲讲常见的性能指标有哪些？它们分别对应的作用是什么？" class="headerlink" title="讲讲常见的性能指标有哪些？它们分别对应的作用是什么？"></a>讲讲常见的性能指标有哪些？它们分别对应的作用是什么？</h3><p>Web 前端性能指标是衡量一个网站或 Web 应用程序加载速度、交互性和用户体验的关键因素。以下是一些常见的 Web 前端性能指标及其解释：</p><ol><li><p>首次绘制（FP，First Paint）：页面在用户设备上开始渲染的时间点。这个指标可以用来衡量页面加载速度的初步感知。</p></li><li><p>首次内容绘制（FCP，First Contentful Paint）：页面上的任何内容（如文字、图片等）首次渲染的时间点。这个指标可以用来衡量用户看到页面内容的速度。</p></li><li><p>首次有效绘制（FMP，First Meaningful Paint）：页面主要内容呈现给用户的时间点。这个指标可以用来衡量页面的视觉完整度。</p></li><li><p>首次输入延迟（FID，First Input Delay）：用户首次与页面交互（如点击按钮、输入等）所需时间。这个指标可以用来衡量页面的交互性。</p></li><li><p>速度指数（SI，Speed Index）：描述页面加载过程中的视觉体验的一个指标。速度指数越低，用户体验越好。</p></li><li><p>大致加载时间（TTFB，Time To First Byte）：从用户发出请求到接收到服务器响应的第一个字节所需的时间。这个指标可以用来衡量网络延迟和服务器处理速度。</p></li><li><p>页面完全加载时间（Load Time）：从用户发出请求到页面完全加载所需的时间。这个指标可以用来衡量页面加载速度的综合体验。</p></li><li><p>页面体积：页面的所有资源（HTML、CSS、JavaScript 等）的总大小。页面体积越小，加载速度越快。</p></li><li><p>请求次数：加载页面所需的网络请求次数。请求次数越少，加载速度越快。</p></li><li><p>首次 CPU 空闲时间（First CPU Idle）：页面首次达到 CPU 空闲状态的时间点。这个指标可以用来衡量页面在何时可以响应用户输入。</p></li><li><p>最大潜在首次输入延迟（Max Potential FID）：一个预测性指标，衡量在页面首次可交互之前可能发生的最大输入延迟。</p></li><li><p>累计布局偏移（CLS，Cumulative Layout Shift）：页面在加载过程中元素位置变化的总和。这个指标可以用来衡量页面的视觉稳定性。</p></li></ol><hr /><h2 id="前端监控"><a href="#前端监控" class="headerlink" title="前端监控"></a>前端监控</h2><h3 id="前端如何做性能监控？"><a href="#前端如何做性能监控？" class="headerlink" title="前端如何做性能监控？"></a>前端如何做性能监控？</h3><p>前端性能监控是指收集、分析和报告前端性能数据的过程。在前端开发中，性能监控可以帮助我们了解用户在实际使用过程中的体验，发现和解决性能瓶颈。以下是一些前端性能监控的方法：</p><ol><li>利用浏览器提供的性能 API，例如 Navigation Timing API、Resource Timing API、User Timing API 等，收集页面加载、资源加载和自定义性能指标的数据。</li><li>使用 PerformanceObserver API 来监听性能数据的变化，实时收集性能指标。</li><li>监控页面的错误信息，包括 JavaScript 错误、资源加载失败等。可以使用 window.onerror 和 window.addEventListener(‘error’)进行捕获。</li><li>监控用户的交互事件，如点击、滚动、输入等，以了解用户在使用过程中可能遇到的性能问题。</li><li>使用 Long Tasks API 来检测可能导致页面卡顿的长时间任务，例如运行时间较长的 JavaScript 代码。</li><li>利用 Web Vitals 库来监控核心性能指标，如 Largest Contentful Paint（LCP）、First Input Delay（FID）和 Cumulative Layout Shift（CLS）等。</li><li>将收集到的性能数据发送到服务器端进行存储和分析。可以使用 XMLHttpRequest 或 Fetch API 进行数据上报。</li><li>使用开源或商业的应用性能监控（APM）工具，如 Google Analytics、Sentry、New Relic 等，进行性能数据的收集、分析和可视化展示。</li><li>对收集到的性能数据进行定期分析，找出性能瓶颈，优化前端代码和架构，提高用户体验。</li></ol><p>性能监控是前端优化的重要环节，通过不断地监控、分析和优化，我们可以确保用户在使用过程中获得良好的体验。</p><h3 id="前端如何做错误监控？"><a href="#前端如何做错误监控？" class="headerlink" title="前端如何做错误监控？"></a>前端如何做错误监控？</h3><p>前端错误监控是指捕获、记录和上报用户在实际使用过程中遇到的错误。错误监控有助于开发者发现和修复潜在的问题，提高应用的稳定性。以下是前端错误监控的一些建议：</p><ol><li><p>监控 JavaScript 运行时错误：可以使用<code>window.onerror</code> 或 <code>window.addEventListener(&#39;error&#39;)</code>来捕获 JavaScript 运行时错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理错误信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理错误信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>捕获 Promise 异常：使用<code>window.addEventListener(&#39;unhandledrejection&#39;)</code>来捕获未处理的 Promise 异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理错误信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>捕获资源加载错误：通过监听<code>error</code>事件，捕获例如图片、样式表、脚本等资源加载失败的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;error&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&quot;IMG&quot;</span> ||</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&quot;LINK&quot;</span> ||</span><br><span class="line">      event.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&quot;SCRIPT&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 处理错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>AJAX 请求错误：当使用 XMLHttpRequest 或 Fetch API 进行 AJAX 请求时，可能会遇到网络错误或服务器错误。可以在请求的错误回调或 catch 方法中捕获：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://example.com/data&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Network response was not ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误信息</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h3 id="谈一谈你对-XSS-攻击理解"><a href="#谈一谈你对-XSS-攻击理解" class="headerlink" title="谈一谈你对 XSS 攻击理解"></a>谈一谈你对 XSS 攻击理解</h3><p>跨站脚本攻击（XSS，Cross-site Scripting）是一种常见的网络安全漏洞，它允许攻击者将恶意代码注入到受害者访问的网站中。这种攻击通常通过 JavaScript 来实现，但也可能涉及到其他脚本语言。在 XSS 攻击中，攻击者的目标是利用用户对网站的信任，进而窃取用户的数据、破坏网站的功能或者进行其他恶意行为。</p><p>XSS 攻击可以分为三种类型：</p><ol><li>存储型 XSS 攻击（Stored XSS）：攻击者将恶意代码提交到目标网站的数据库中，当其他用户访问受影响的页面时，恶意代码将被加载并执行。这种类型的 XSS 攻击是最危险的，因为攻击者可以长期控制受害者的浏览器。</li><li>反射型 XSS 攻击（Reflected XSS）：攻击者通过创建一个包含恶意代码的 URL，诱使受害者点击这个链接。当受害者访问这个 URL 时，恶意代码会在其浏览器中执行。这种类型的 XSS 攻击需要用户的互动，因此相对存储型 XSS 攻击来说，风险较低。</li><li>DOM 型 XSS 攻击（DOM-based XSS）：这种类型的 XSS 攻击是通过操作网页的 Document Object Model（DOM）来实现的。攻击者会寻找可以用来插入恶意代码的 DOM 节点，当用户访问受影响的页面时，恶意代码将被执行。这种类型的攻击与反射型 XSS 相似，但更难以检测和防御。</li></ol><p>为了防范 XSS 攻击，网站开发者和运维人员可以采取以下措施：</p><ol><li>对用户输入进行过滤和验证：确保所有的用户输入都经过适当的验证和过滤，以防止恶意代码的注入。</li><li>使用安全的编码方法：对用户输入的数据进行编码，将特殊字符转换为 HTML 实体，以防止代码在浏览器中被解析和执行。</li><li>设置 Content Security Policy（CSP）：使用 CSP 可以限制浏览器加载和执行外部资源，降低 XSS 攻击的风险。</li><li>使用 HttpOnly Cookies：将敏感信息（如会话 ID）存储在 HttpOnly Cookies 中，以防止恶意脚本通过浏览器窃取这些信息。</li><li>保持软件和库的更新：确保使用的开发工具、库和框架是最新的，并修复已知的安全漏洞。</li></ol><h3 id="谈一谈你对-CSRF-攻击理解"><a href="#谈一谈你对-CSRF-攻击理解" class="headerlink" title="谈一谈你对 CSRF 攻击理解"></a>谈一谈你对 CSRF 攻击理解</h3><p>跨站请求伪造（CSRF，Cross-Site Request Forgery）是一种常见的网络安全漏洞，攻击者通过诱使受害者执行不知情的操作来利用受害者在网站上的身份。这种攻击是基于用户在其他网站上的登录状态和网站的信任机制。</p><p>在 CSRF 攻击中，攻击者创建一个恶意网站或发送一个包含恶意代码的电子邮件。当受害者访问恶意网站或查看电子邮件时，浏览器会在后台向目标网站发送伪造的请求。由于受害者已经在目标网站上登录，因此这些请求将带有有效的凭据（如 cookies），使攻击者能够以受害者的身份执行操作。</p><p>为了防范 CSRF 攻击，网站开发者和运维人员可以采取以下措施：</p><ol><li>使用 CSRF 令牌：在用户提交表单或执行敏感操作时，为每个请求生成一个随机的、唯一的 CSRF 令牌。将这个令牌与用户的会话关联，并在请求中包含该令牌。服务器端需要验证每个请求的令牌，确保它与用户会话的令牌匹配。这样可以防止攻击者伪造有效的请求。</li><li>验证请求来源：检查请求的来源，例如 HTTP 的 Referer 头或 Origin 头，确保请求来自于合法的域名。这有助于防止跨域的 CSRF 攻击。</li><li>使用 SameSite Cookies 属性：设置 SameSite 属性为“Strict”或“Lax”，可以防止浏览器在跨站请求时发送 cookies。这可以降低 CSRF 攻击的风险，但可能不适用于所有场景。</li><li>要求用户重新验证身份：在执行敏感操作（如修改密码或执行交易）时，要求用户重新输入密码或进行二次验证。这可以降低 CSRF 攻击的成功率。</li><li>提高安全意识：教育用户识别和避免钓鱼网站、恶意邮件等，以降低 CSRF 攻击的成功率。</li></ol><h3 id="谈谈你对-SQL-注入的理解"><a href="#谈谈你对-SQL-注入的理解" class="headerlink" title="谈谈你对 SQL 注入的理解"></a>谈谈你对 SQL 注入的理解</h3><p>SQL 注入（SQL Injection）是一种网络安全漏洞，它允许攻击者通过在输入数据中插入恶意 SQL 代码，来控制或操纵应用程序与数据库之间的交互。这种攻击通常发生在应用程序未对用户输入进行充分验证和过滤的情况下。攻击者可以利用 SQL 注入漏洞来窃取、篡改或删除数据，甚至可能获得对整个数据库系统的控制权。</p><p>SQL 注入攻击的常见类型包括：</p><ol><li>联合查询注入（Union-based SQL Injection）：攻击者通过构造包含 UNION 语句的恶意 SQL 查询，使其与原始查询合并，从而获取额外的数据。</li><li>基于错误的 SQL 注入（Error-based SQL Injection）：攻击者利用数据库在执行恶意查询时产生的错误信息，获取有关数据库结构和数据的信息。</li><li>盲注 SQL 注入（Blind SQL Injection）：攻击者通过逐步尝试不同的输入值，并根据应用程序的响应来推断数据库结构和数据。这种攻击方式较为缓慢，但在目标系统没有显示具体错误信息的情况下仍然有效。</li></ol><p>为了防止 SQL 注入攻击，开发者和运维人员可以采取以下措施：</p><ol><li>使用预编译语句和参数化查询：预编译语句和参数化查询可以将 SQL 代码与数据分离，从而避免恶意代码的注入。这是防止 SQL 注入的最有效方法。</li><li>对用户输入进行验证和过滤：确保所有用户输入都经过适当的验证和过滤，以防止恶意代码的注入。使用白名单验证策略，仅允许已知安全的输入值。</li><li>最小权限原则：为应用程序的数据库账户分配最小必要权限，以减少潜在的损害。例如，如果应用程序仅需要读取数据，不应给予其写入和删除权限。</li><li>数据库错误信息处理：避免在应用程序中显示详细的数据库错误信息，以防攻击者利用这些信息进行攻击。可以使用自定义错误页面或者错误日志来记录错误信息，以便进行调试。</li><li>定期进行安全审计和更新：定期检查应用程序和数据库的安全设置，修复已知的漏洞，确保使用的软件和库是最新的。进行代码审查和安全测试，以发现潜在的安全漏洞。</li></ol><h2 id="跨端开发"><a href="#跨端开发" class="headerlink" title="跨端开发"></a>跨端开发</h2><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><h4 id="简述下-wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别"><a href="#简述下-wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别" class="headerlink" title="简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?"></a>简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?</h4><p>微信小程序中，这些 API 用于页面跳转和导航，它们之间的主要区别如下：</p><ol><li>wx.navigateTo(): 这个方法用于跳转到一个新页面，保留当前页面，新页面会被添加到页面栈中。用户可以点击返回按钮回到原页面。适用于多级页面的跳转。</li><li>wx.redirectTo(): 此方法用于跳转到一个新页面，但不保留当前页面，即不允许用户返回。适用于无需返回上一页面的场景。</li><li>wx.switchTab(): 这个方法用于切换到 tabBar 页面，并关闭其他非 tabBar 页面。tabBar 页面是小程序底部导航栏的页面，可以方便用户在不同页面之间切换。</li><li>wx.navigateBack(): 此方法用于返回上一页面或多级页面。可以指定返回的层数，默认为 1，即返回上一页面。这个方法是从页面栈中删除相应页面实现返回功能的。</li><li>wx.reLaunch(): 这个方法用于关闭所有页面，打开到应用内的某个页面。适用于需要清空页面栈，重新启动小程序的场景。</li></ol><h4 id="谈谈微信小程序的架构以及为什么要用到双线程？"><a href="#谈谈微信小程序的架构以及为什么要用到双线程？" class="headerlink" title="谈谈微信小程序的架构以及为什么要用到双线程？"></a>谈谈微信小程序的架构以及为什么要用到双线程？</h4><p>微信小程序的架构主要分为两部分：逻辑层（App Service）和渲染层（Webview）。这两个部分运行在不同的线程中，形成了双线程架构。</p><ol><li>逻辑层（App Service）： 逻辑层主要负责处理数据、业务逻辑和页面事件等。在这一层中，开发者编写 JavaScript 代码来实现小程序的功能。逻辑层运行在一个独立的线程中，通常称为 JSCore 线程。微信客户端提供了一些基础库，使得开发者可以调用相关 API 来实现小程序的各种功能。</li><li>渲染层（Webview）： 渲染层主要负责展示小程序的界面。在这一层中，开发者使用 WXML（类似于 HTML）和 WXSS（类似于 CSS）来定义页面结构和样式。每一个页面对应一个 Webview，每个 Webview 独立运行在各自的线程中。</li></ol><p>双线程架构的主要原因是为了实现逻辑层和渲染层的分离，提高小程序的性能。</p><ol><li>性能优化：通过将业务逻辑和页面渲染分离到不同的线程中，可以有效避免渲染线程的阻塞，提高小程序的运行性能。当逻辑层进行计算或处理数据时，渲染层不会受到影响，能够保持流畅的用户体验。</li><li>安全性：双线程架构可以隔离 DOM 操作和 JavaScript 代码的执行，增强了小程序的安全性。由于小程序不允许直接操作 DOM，开发者只能通过官方提供的 API 来实现页面的交互和数据绑定。这样可以避免一些潜在的安全问题，例如跨站脚本攻击（XSS）。</li><li>简化开发：双线程架构使得开发者可以专注于业务逻辑和页面渲染，而无需关心它们之间的通信。微信小程序提供了丰富的 API 和组件，帮助开发者快速搭建高性能的应用。</li></ol><p>综上所述，双线程架构有助于提高微信小程序的性能、安全性和易用性。</p><h4 id="微信小程序体积压缩的方案？"><a href="#微信小程序体积压缩的方案？" class="headerlink" title="微信小程序体积压缩的方案？"></a>微信小程序体积压缩的方案？</h4><p>为了提高微信小程序的加载速度和运行性能，开发者可以采取一些压缩和优化措施。以下是一些常见的微信小程序体积压缩方案：</p><ol><li>代码压缩与混淆：对小程序的 JavaScript 代码进行压缩和混淆，可以有效地减小文件体积。使用诸如 UglifyJS、Terser 等工具可以实现这一目标。</li><li>压缩 WXML 和 WXSS：对 WXML（类似于 HTML）和 WXSS（类似于 CSS）文件进行压缩，移除不必要的空格、换行和注释，以减小文件大小。可以使用一些构建工具，如 Gulp、Webpack 等，结合相应的插件实现自动化压缩。</li><li>优化图片资源：对图片资源进行压缩和优化，以减少图片文件的大小。可以使用一些在线工具或构建工具插件，如 TinyPNG、ImageOptim、imagemin 等，对图片进行有损或无损压缩。此外，尽量使用小程序支持的 WebP 格式，以获得更好的压缩效果。</li><li>按需加载：对于不是首次渲染必须的资源，可以采用按需加载的策略，以减小初始加载的文件体积。例如，可以使用小程序的分包加载功能，将不同页面或功能的代码和资源拆分成多个子包，实现按需加载。</li><li>减少不必要的资源：审查小程序中的资源文件，移除不必要的图片、字体、图标等资源。同时，尽量避免使用大型的第三方库，只引入所需的模块。</li><li>使用云开发：利用微信提供的云开发功能，将一些资源放在云端，而不是打包到小程序中。例如，将图片、音频和视频等资源存储在云存储中，按需获取。</li><li>代码拆分：避免在同一个文件中编写过多的代码，可以将功能模块化，拆分成多个文件。这样不仅可以提高代码的可维护性，还能避免加载过多不必要的代码。</li><li>优化数据请求：减少数据请求的频率和数据量，尽量在后端完成数据处理和筛选。此外，可以使用缓存策略，减少不必要的数据请求。</li></ol><p>通过这些方案，可以有效地减小微信小程序的体积，提高加载速度和运行性能。在开发过程中，结合具体的项目需求，灵活采用这些优化措施。</p><h4 id="微信小程序的生命周期函数"><a href="#微信小程序的生命周期函数" class="headerlink" title="微信小程序的生命周期函数"></a>微信小程序的生命周期函数</h4><p>微信小程序的生命周期函数是指在小程序运行过程中，框架自动执行的一些函数。这些函数主要用于监听页面或应用的生命周期事件，如页面的加载、显示、隐藏等。以下是微信小程序中的主要生命周期函数：</p><ol><li>应用生命周期函数（App 对象）：<ul><li>onLaunch：当小程序启动时触发，全局只触发一次。可用于初始化全局数据、检查用户登录状态等。</li><li>onShow：当小程序从后台进入前台显示时触发。可以在此函数中获取用户数据、更新页面数据等。</li><li>onHide：当小程序从前台进入后台时触发。可以在此函数中暂停计时器、保存数据等。</li></ul></li><li>页面生命周期函数（Page 对象）：<ul><li>onLoad：页面加载时触发。一个页面只会调用一次，可在此函数中获取页面参数、请求数据等。</li><li>onShow：页面显示时触发。每次打开页面都会调用一次。可以在此函数中更新页面数据、开启计时器等。</li><li>onReady：页面初次渲染完成时触发。一个页面只会调用一次。可以在此函数中获取已渲染的 DOM 节点等。</li><li>onHide：页面隐藏时触发。当页面离开前台或被其他页面覆盖时触发。可以在此函数中暂停计时器、保存数据等。</li><li>onUnload：页面卸载时触发。当页面被关闭时触发。可以在此函数中清理页面数据、监听器等。</li></ul></li><li>组件生命周期函数（Component 对象）：<ul><li>created：组件实例刚刚被创建时触发。可以在此函数中初始化组件数据。</li><li>attached：组件实例被插入页面节点树时触发。可以在此函数中进行数据绑定等操作。</li><li>ready：组件布局完成后触发。可以在此函数中操作子组件、获取组件节点信息等。</li><li>moved：组件实例被移动到另一个节点树时触发。可以在此函数中处理组件的移动。</li><li>detached：组件实例被从页面节点树移除时触发。可以在此函数中进行清理工作，如移除事件监听器、销毁对象等。</li></ul></li></ol><p>根据不同的场景，开发者可以在这些生命周期函数中执行相应的操作。注意，部分生命周期函数的执行顺序是固定的，例如页面的 onLoad 一定在 onShow 之前执行。在编写代码时，需要注意生命周期函数的执行顺序和相应的作用。</p><h4 id="微信小程序的优劣势"><a href="#微信小程序的优劣势" class="headerlink" title="微信小程序的优劣势"></a>微信小程序的优劣势</h4><p>微信小程序作为一种轻量级的应用形式，具有一定的优势和劣势。下面是一些主要的优劣势：</p><p>优势：</p><ol><li>低成本：与传统的原生应用相比，小程序的开发成本较低，开发周期较短，可以快速实现产品上线。</li><li>无需安装：用户无需下载安装即可使用，节省了用户的时间和设备存储空间。</li><li>跨平台：微信小程序基于微信客户端，可以在 Android 和 iOS 平台上运行，实现了一定程度的跨平台兼容性。</li><li>更新迅速：小程序的更新不需要用户进行手动操作，每次打开都会获取最新版本，方便开发者快速迭代和修复问题。</li><li>流量入口多样：微信小程序可以通过微信内搜索、公众号、朋友圈、小程序码等多种渠道进行推广，便于吸引用户。</li><li>安全性：微信小程序不允许直接操作 DOM，限制了一些潜在的安全风险，如跨站脚本攻击（XSS）。</li><li>丰富的 API 和组件：微信提供了丰富的 API 和组件，方便开发者快速实现功能和界面，提高开发效率。</li></ol><p>劣势：</p><ol><li>功能受限：相较于原生应用，小程序的功能和权限受到限制，某些复杂的功能可能无法实现。</li><li>性能：由于小程序运行在微信客户端内，性能可能不如原生应用。尤其是在低端设备上，性能问题可能更加明显。</li><li>用户粘性较低：用户使用小程序的门槛较低，但与此同时，用户流失的风险也相对较高。</li><li>依赖微信生态：微信小程序完全依赖于微信生态，受制于微信的政策和规则。一旦微信生态发生变化，小程序可能受到影响。</li><li>跨平台局限性：虽然小程序具有一定的跨平台特性，但在不同平台上可能仍存在兼容性和性能差异。同时，小程序无法在非微信环境下运行。</li></ol><p>根据具体的业务需求和场景，开发者可以权衡微信小程序的优劣势，选择是否采用小程序作为应用开发的方式。</p><h4 id="bindtap-和-catchtap-的区别是什么"><a href="#bindtap-和-catchtap-的区别是什么" class="headerlink" title="bindtap 和 catchtap 的区别是什么?"></a>bindtap 和 catchtap 的区别是什么?</h4><p>bindtap 是普通的点击事件绑定，而 catchtap 是阻止事件冒泡的点击事件绑定。简单来说，如果有多个嵌套的组件都绑定了 tap 事件，使用 catchtap 可以只触发当前组件的 tap 事件，而不会触发其父级组件的 tap 事件。而使用 bindtap 则可能会触发其父级组件、祖先级组件的 tap 事件。</p><hr /><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="深度优先遍历和广度优先遍历的区别是什么？"><a href="#深度优先遍历和广度优先遍历的区别是什么？" class="headerlink" title="深度优先遍历和广度优先遍历的区别是什么？"></a>深度优先遍历和广度优先遍历的区别是什么？</h3><p>深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）都是用于遍历或搜索树或图的算法。这两种方法各有其优缺点：</p><h3 id="深度优先遍历-DFS-："><a href="#深度优先遍历-DFS-：" class="headerlink" title="深度优先遍历 (DFS)："></a>深度优先遍历 (DFS)：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>空间效率</strong>：在树的深度远小于广度时，DFS 通常更加空间效率。因为它只需要存储一个路径的信息，而不是存储整个层的信息。</li><li><strong>寻找深度解</strong>：当问题需要找到深度解（例如求解迷宫的一条路径）时，DFS 是一个很好的选择。</li><li><strong>实现相对简单</strong>：使用递归或堆栈，DFS 相对容易实现。</li><li><strong>可以找到连通分量</strong>：对于图的分析，DFS 可以被用来识别图的连通分量。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>可能不完整</strong>：在无限或非常大的搜索空间中，DFS 可能永远不会结束，或者可能会错过更优解。</li><li><strong>可能找到非最优解</strong>：不同于 BFS，DFS 可能找到一个解，但并不是最优解。</li><li><strong>使用递归可能导致栈溢出</strong>：如果搜索树非常深，递归实现可能会导致栈溢出。</li></ol><h3 id="广度优先遍历-BFS-："><a href="#广度优先遍历-BFS-：" class="headerlink" title="广度优先遍历 (BFS)："></a>广度优先遍历 (BFS)：</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>找到最优解</strong>：如果存在多个解，BFS 会找到最少步骤的解，因为它首先检查所有的近邻节点。</li><li><strong>完整性</strong>：即使在无限或非常大的搜索空间中，BFS 也可以保证找到解（如果存在）。</li><li><strong>适用于广度大于深度的情况</strong>：如果树或图的广度远小于深度，BFS 可能更加高效。</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>空间消耗</strong>：因为 BFS 需要存储所有扩展节点的信息，所以空间消耗可能非常大，特别是当广度远大于深度时。</li><li><strong>可能较慢找到深度解</strong>：如果解在较深的层，BFS 可能需要更多时间来找到它，因为它需要逐层搜索。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>选择 DFS 还是 BFS 主要取决于问题的具体要求和搜索空间的结构。如果你需要找到最优解并且广度相对较小，BFS 可能是更好的选择。如果你只需要找到一个解，或者如果深度相对较小，DFS 可能更加适合。在实际应用中，深度优先搜索和广度优先搜索的选择可能还取决于其他许多因素，如问题的特殊性质和可用资源。</p><hr /><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="你觉得编写测试的好处是什么？"><a href="#你觉得编写测试的好处是什么？" class="headerlink" title="你觉得编写测试的好处是什么？"></a>你觉得编写测试的好处是什么？</h3><p>编写测试的好处有很多，以下是其中的一些关键优势：</p><ol><li>保证代码质量：编写测试可以帮助确保代码的质量，因为它会检查代码的正确性和功能性。通过发现潜在的错误和问题，我们可以更快地修复它们，确保代码的稳定性和可靠性。</li><li>防止回归：当对现有代码进行修改或扩展时，测试可以确保这些更改不会导致之前解决的问题再次出现。这称为“防止回归”，有助于维护代码的长期稳定性。</li><li>提高开发效率：测试可以帮助开发者更快地识别和解决问题，从而提高开发效率。自动化测试还可以在开发过程中减轻人工测试的负担，使开发者可以集中精力编写更多的功能代码。</li><li>易于重构和优化：测试可以让开发者在重构或优化代码时更有信心，因为他们知道任何潜在的问题都会被测试捕捉到。这使得代码更具可维护性，可以更轻松地进行优化和改进。</li><li>提升团队协作：编写测试有助于确保代码对其他团队成员更具可读性和可理解性。测试可以作为代码的文档，帮助其他开发者了解代码的预期行为和功能。这在团队合作中尤为重要，可以提高整个团队的生产力。</li><li>客户信任：具有全面测试的软件项目更容易赢得客户的信任，因为它们展示了开发团队对质量的关注和承诺。这有助于提高客户满意度并为未来的项目创造良好的声誉。</li><li>减少错误成本：及时发现和解决问题可以降低错误的长期成本。在项目后期发现问题的成本通常比在开发过程中早期发现和修复的成本要高得多。通过编写测试，我们可以在项目早期发现和解决问题，降低整体成本。</li></ol><p>总之，编写测试对于确保软件质量、提高开发效率、优化代码、增强团队协作和赢得客户信任等方面具有重要作用。</p><h3 id="ATDD、TDD-和-BDD-的区别？"><a href="#ATDD、TDD-和-BDD-的区别？" class="headerlink" title="ATDD、TDD 和 BDD 的区别？"></a>ATDD、TDD 和 BDD 的区别？</h3><p>ATDD（接受测试驱动开发）、TDD（测试驱动开发）和 BDD（行为驱动开发）都是软件开发的实践方法，它们之间有一定的关联，但各有侧重点和特点。</p><ol><li>TDD（测试驱动开发）： TDD 是一种敏捷开发实践，它要求开发者在编写功能代码之前先编写测试用例。开发者首先编写一个失败的测试，然后编写实现功能的最少量代码以使测试通过，最后重构代码以提高质量。TDD 的核心原则是“红-绿-重构”（红色表示失败的测试，绿色表示通过的测试，重构表示改进代码质量）。TDD 的主要目的是通过编写简洁、可维护的代码来提高软件质量。</li><li>ATDD（接受测试驱动开发）： ATDD 与 TDD 类似，但关注的是从用户的角度编写测试。开发者在实现功能之前，先与客户、产品经理和测试人员合作，共同确定功能的验收标准和测试用例。这些测试用例描述了应用程序应该如何满足用户需求和期望。然后，开发者使用 TDD 的方法来实现功能，确保满足这些验收标准。ATDD 的主要目的是确保软件满足用户需求和业务目标。</li><li>BDD（行为驱动开发）： BDD 是一种介于 TDD 和 ATDD 之间的开发实践，它关注于使用通用的、自然语言描述的行为规范来编写测试。BDD 强调与非技术人员（如产品经理、业务分析师等）的沟通和协作，确保团队对软件行为有共同的理解。BDD 测试用例描述了给定特定情境下，软件应该如何响应。这些用例通常遵循“给定-当-那么”（Given-When-Then）的格式。BDD 的主要目的是提高团队间的沟通和协作，确保软件满足业务需求。</li></ol><p>总结一下，TDD 主要关注代码质量和功能的正确性，ATDD 关注软件满足用户需求和业务目标，而 BDD 关注团队间的沟通和协作，以及确保软件符合业务需求。在实际项目中，这三种方法可以相互结合使用，以达到更好的软件开发效果。</p><hr /><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="什么是正向代理和反向代理？"><a href="#什么是正向代理和反向代理？" class="headerlink" title="什么是正向代理和反向代理？"></a>什么是正向代理和反向代理？</h3><p>正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种不同类型的代理服务器。它们在网络架构中发挥着重要的作用，具体来说：</p><ol><li>正向代理： 正向代理位于客户端与目标服务器之间，充当客户端与目标服务器之间的中间人。客户端发起请求时，请求首先到达正向代理服务器，然后代理服务器将请求转发到目标服务器。正向代理的主要作用包括：</li></ol><ul><li>为内部网络客户端提供对外部资源的访问能力</li><li>提供缓存功能，加速对常用资源的访问</li><li>对客户端身份进行匿名化</li><li>实现负载均衡</li><li>实施安全策略和访问控制</li></ul><ol><li>反向代理： 反向代理位于客户端与目标服务器之间，充当目标服务器与客户端之间的中间人。客户端发起请求时，请求首先到达反向代理服务器，然后代理服务器将请求转发到后端服务器。反向代理的主要作用包括：</li></ol><ul><li>提供负载均衡，将客户端请求分发到多个后端服务器</li><li>提供 SSL 加密和解密功能，实现安全通信</li><li>提供缓存功能，加速对常用资源的访问</li><li>实现应用服务器的隔离，保护后端服务器免受恶意攻击</li><li>集中处理和监控客户端请求，实现统一的访问控制和安全策略</li></ul><p>简言之，正向代理主要面向客户端，帮助客户端访问互联网上的资源；反向代理主要面向服务器，帮助服务器处理来自客户端的请求。</p><h3 id="为什么-Nginx-性能这么高？"><a href="#为什么-Nginx-性能这么高？" class="headerlink" title="为什么 Nginx 性能这么高？"></a>为什么 Nginx 性能这么高？</h3><p>Nginx 的高性能可以归因于其独特的设计和架构。以下是 Nginx 高性能的关键因素：</p><ol><li>事件驱动、异步非阻塞架构：Nginx 使用了事件驱动的异步非阻塞 I&#x2F;O 模型。这种模型允许 Nginx 在单个进程中处理大量并发连接，而无需为每个连接创建一个新的线程或进程。这大大降低了上下文切换和内存分配的开销，提高了性能。</li><li>轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。这使得 Nginx 在处理请求时能够更高效地利用系统资源。</li><li>高效的静态文件处理：Nginx 对静态文件的处理能力非常出色，它可以利用 sendfile 系统调用、TCP_CORK 和 TCP_NOPUSH 套接字选项等高级 I&#x2F;O 功能，以高效地为静态资源提供服务。</li><li>Keep-Alive 连接：Nginx 支持 HTTP Keep-Alive 连接，这意味着多个请求可以在同一连接上进行，减少了连接建立和关闭的开销。</li><li>内建的负载均衡和反向代理：Nginx 提供了功能强大的反向代理和负载均衡功能，可以在多个后端服务器之间分发请求，提高整体性能。</li><li>缓存功能：Nginx 提供了缓存功能，可以将后端服务器的响应进行缓存，加速对常用资源的访问，减轻后端服务器的负担。</li><li>可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块，定制 Nginx 以满足特定需求。</li><li>稳定性：Nginx 的稳定性非常高，即使在高负载情况下也能保持稳定运行。这使得 Nginx 能够在生产环境中提供可靠的服务。</li></ol><p>这些因素共同使得 Nginx 成为一个高性能的 Web 服务器和反向代理服务器。其优异的性能表现吸引了许多大型网站和互联网公司将 Nginx 作为首选的 Web 服务器和反向代理服务器。</p><h3 id="Nginx-的优缺点？Nginx-应用场景？"><a href="#Nginx-的优缺点？Nginx-应用场景？" class="headerlink" title="Nginx 的优缺点？Nginx 应用场景？"></a>Nginx 的优缺点？Nginx 应用场景？</h3><p>Nginx 是一个高性能、轻量级的 Web 服务器和反向代理服务器。它广泛用于网站和网络应用的开发，其优缺点如下：</p><p>优点：</p><ol><li>高性能：Nginx 使用事件驱动的异步非阻塞架构，可以支持大量并发连接。相较于其他传统服务器，例如 Apache，Nginx 在并发场景下具有更低的资源消耗和更高的性能。</li><li>轻量级：Nginx 的代码量较小，安装和配置简单，占用资源较少。</li><li>反向代理：Nginx 提供了功能强大的反向代理功能，可以实现负载均衡、缓存、SSL 加密解密等。</li><li>静态文件处理：Nginx 对静态文件的处理能力非常出色，能高效地为静态资源提供服务。</li><li>可扩展性：Nginx 支持模块化扩展，用户可以根据需要添加功能模块。</li><li>稳定性高：Nginx 有着很高的稳定性，被广泛应用于生产环境。</li></ol><p>缺点：</p><ol><li>动态语言支持较弱：与 Apache 相比，Nginx 对动态语言的支持不够完善，通常需要与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用。</li><li>模块更新和扩展：Nginx 模块需要在编译时集成，无法像 Apache 那样通过动态加载模块。当需要更新或添加模块时，通常需要重新编译 Nginx。</li><li>社区支持：虽然 Nginx 社区不断发展，但与 Apache 等老牌 Web 服务器相比，其社区支持相对较弱。</li></ol><p>Nginx 应用场景：</p><ol><li>静态资源服务器：Nginx 非常擅长处理静态文件，如图片、CSS、JavaScript 等。在很多场景下，Nginx 作为静态资源服务器可以减轻应用服务器的负担，提高响应速度。</li><li>反向代理和负载均衡：Nginx 提供了强大的反向代理和负载均衡功能，可以将客户端请求分发到多个后端服务器，提高服务的可用性和扩展性。</li><li>SSL 终端：Nginx 支持 SSL&#x2F;TLS 加密和解密，可作为 HTTPS 服务的终端，保证数据的安全传输。</li><li>缓存服务器：Nginx 可以作为缓存服务器，对后端服务器的响应进行缓存，加速对常用资源的访问，提高用户体验。</li><li>Web 应用服务器：虽然 Nginx 对动态语言支持的不足，但它仍然可以与其他应用服务器（如 PHP-FPM、uWSGI 等）配合使用，共同组成 Web 应用的整体架构。例如，Nginx 可以作为反向代理服务器，将动态请求转发给 PHP-FPM 处理，同时负责静态文件的处理。</li></ol><p>总之，Nginx 的高性能、轻量级和稳定性使其在众多应用场景中得到广泛应用，特别是在处理静态文件、反向代理和负载均衡等方面表现出色。然而，对于动态语言支持和模块扩展方面，Nginx 仍然需要与其他应用服务器配合使用以获得更好的效果。</p><h3 id="如何用-Nginx-解决前端跨域问题？"><a href="#如何用-Nginx-解决前端跨域问题？" class="headerlink" title="如何用 Nginx 解决前端跨域问题？"></a>如何用 Nginx 解决前端跨域问题？</h3><p>要使用 Nginx 解决前端跨域问题，您可以通过配置 Nginx 为您的 Web 服务添加 CORS（跨域资源共享）相关的响应头。以下是一个简单的示例，展示如何在 Nginx 配置文件中实现 CORS 配置：</p><ol><li><p>打开 Nginx 配置文件，通常位于 <code>/etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/sites-available/your_site_config</code>。</p></li><li><p>在配置文件中找到您想要添加 CORS 支持的 <code>location</code> 块。如果没有，您可以创建一个。</p></li><li><p>在 <code>location</code> 块中添加以下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment"># ...原有配置...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加CORS相关的响应头</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="string">&#x27;Content-Length,Content-Range&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们为 <code>OPTIONS</code> 请求和 <code>GET</code> 请求添加了 CORS 相关的响应头。您可以根据实际需求调整允许的请求方法和其他配置。</p></li><li><p>保存配置文件并重新加载 Nginx 以使更改生效：</p></li></ol><p>现在，Nginx 已经为您的 Web 服务添加了 CORS 支持，应该可以解决前端跨域问题。请注意，上面的示例中使用了通配符 <code>*</code> 作为 <code>Access-Control-Allow-Origin</code> 的值，这意味着允许所有域进行跨域访问。在实际生产环境中，您可能需要将其替换为特定的域名以提高安全性。</p><h3 id="谈谈你对-Docker-的理解"><a href="#谈谈你对-Docker-的理解" class="headerlink" title="谈谈你对 Docker 的理解"></a>谈谈你对 Docker 的理解</h3><p>Docker 是一个开源的容器平台，它可以帮助开发者和运维人员轻松地打包、分发和运行应用。它基于容器化技术，让应用程序和其依赖环境作为一个整体打包在一起，实现了环境与应用程序的隔离。Docker 的核心思想是将应用程序与底层基础设施分离，从而使开发和部署过程更加简单、高效和可靠。</p><p>Docker 的主要特点包括：</p><ol><li>轻量级：Docker 使用容器来运行应用，这些容器共享宿主机的操作系统内核，因此容器的开销小于虚拟机。它们启动快速，占用的资源更少。</li><li>易于打包和分发：Docker 可以将应用程序及其依赖项一起打包成一个镜像，这使得应用程序可以在不同的环境中轻松移植和复制。Docker Hub 等仓库提供了便利的镜像分发和管理。</li><li>隔离性：每个容器运行在自己的命名空间中，拥有独立的文件系统、网络和进程空间，这意味着容器之间相互隔离，可以在同一台机器上运行多个互不干扰的应用。</li><li>可扩展性：Docker 支持容器的水平扩展和垂直扩展，可以根据需要快速添加或删除容器实例，以应对不同的负载需求。</li><li>DevOps 友好：Docker 支持持续集成与持续部署（CI&#x2F;CD），使得开发、测试和生产环境更加统一，有助于提高开发和运维团队的协作效率。</li><li>生态系统丰富：Docker 拥有庞大的社区和丰富的插件生态系统，包括 Docker Compose、Docker Swarm、Kubernetes 等，这些工具可以帮助用户更好地管理和协调多个容器。</li></ol><p>总之，Docker 是一个强大的容器化技术平台，它使应用程序的开发、部署和运维更加简单、高效和可靠。</p><h3 id="Docker-如何批量清理临时镜像文件？"><a href="#Docker-如何批量清理临时镜像文件？" class="headerlink" title="Docker 如何批量清理临时镜像文件？"></a>Docker 如何批量清理临时镜像文件？</h3><p>在 Docker 中，可以使用以下命令批量清理临时镜像文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><p>该命令将删除所有未被使用的镜像和标签。如果你只想删除未被使用的镜像，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h3 id="Docker-本地的镜像文件都存放在哪里？"><a href="#Docker-本地的镜像文件都存放在哪里？" class="headerlink" title="Docker 本地的镜像文件都存放在哪里？"></a>Docker 本地的镜像文件都存放在哪里？</h3><p>在 Docker 中，本地的镜像文件存储在 Docker 的文件系统中，一般位于宿主机的<code>/var/lib/docker</code>目录下。在该目录下有多个子目录和文件，其中比较重要的有：</p><ul><li><code>containers/</code>：存储容器的文件系统和元数据。</li><li><code>image/</code>：存储镜像文件和元数据。</li><li><code>volumes/</code>：存储 Docker 卷的数据。</li><li><code>networks/</code>：存储 Docker 网络的配置和状态。</li></ul><p>在<code>image/</code>目录下，有一个子目录<code>overlay2/</code>（在使用 overlay2 存储驱动的情况下），它包含了所有的镜像文件和元数据，每个镜像对应一个目录。例如，如果有一个名为<code>nginx:latest</code>的镜像，则它的文件存储路径为<code>/var/lib/docker/image/overlay2/&lt;hash&gt;/merged/</code>，其中<code>&lt;hash&gt;</code>是镜像的 SHA256 哈希值。</p><p>请注意，这些路径可能因为 Docker 版本、存储驱动等因素而有所不同。如果想要确定本地 Docker 存储的路径，可以使用以下命令查看 Docker 的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>其中会列出 Docker 存储的根目录和数据子目录。</p><h3 id="Docker-如何停止所有正在运行的容器？"><a href="#Docker-如何停止所有正在运行的容器？" class="headerlink" title="Docker 如何停止所有正在运行的容器？"></a>Docker 如何停止所有正在运行的容器？</h3><p>要停止所有正在运行的容器，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure><p>该命令使用<code>docker ps -q</code>命令列出所有正在运行的容器的 ID，然后将其传递给<code>docker stop</code>命令以停止这些容器。这样就可以一次性停止所有正在运行的容器。</p><p>如果你希望删除所有停止的容器，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><p>该命令将删除所有已经停止的容器。请注意，这些命令将永久删除容器，因此在使用之前请确保你确实想要删除这些容器。</p><h3 id="构建-Docker-镜像应该遵循哪些原则？"><a href="#构建-Docker-镜像应该遵循哪些原则？" class="headerlink" title="构建 Docker 镜像应该遵循哪些原则？"></a>构建 Docker 镜像应该遵循哪些原则？</h3><p>构建 Docker 镜像时，应遵循一些原则以保证镜像的高质量、安全性和可维护性。以下是一些建议：</p><ol><li>使用官方基础镜像：尽可能使用官方提供的基础镜像，因为它们经过了广泛测试且得到了良好的支持。</li><li>保持镜像轻量化：减少镜像大小，只包含运行应用程序所需的最小依赖。这将提高镜像的传输速度和部署时间。</li><li>使用多阶段构建：通过多阶段构建，可以在一个 Dockerfile 中使用多个构建阶段，以便更有效地处理构建过程。这有助于减少镜像大小和优化构建时间。</li><li>缩小镜像攻击面：确保镜像中只包含必要的组件，避免安装不必要的软件包，以降低安全风险。</li><li>使用.dockerignore 文件：使用.dockerignore 文件排除不需要的文件和目录，以减小镜像大小并加快构建速度。</li><li>标签和版本控制：为镜像使用清晰、有意义的标签，并进行版本控制。这有助于跟踪和管理不同版本的镜像。</li><li>缓存和层次化：充分利用 Docker 构建缓存，并将 Dockerfile 中的指令合理分层。这有助于加速构建过程并提高可维护性。</li><li>设置适当的用户权限：避免使用 root 用户运行容器，以降低潜在的安全风险。</li><li>指定资源限制：设置适当的资源限制，如 CPU 和内存，以防止容器消耗过多宿主机资源。</li><li>文档化：为 Dockerfile 和镜像提供清晰的文档，以便其他人了解如何使用和维护它们。</li></ol><p>遵循这些原则有助于创建高质量、安全且易于维护的 Docker 镜像。</p><h3 id="谈谈你对-Docker-Compose-的理解"><a href="#谈谈你对-Docker-Compose-的理解" class="headerlink" title="谈谈你对 Docker-Compose 的理解"></a>谈谈你对 Docker-Compose 的理解</h3><p>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它允许用户使用 YAML 文件（通常命名为<code>docker-compose.yml</code>）来描述一个完整的应用程序环境，包括服务、网络和卷等配置。通过 Docker Compose，开发者可以轻松地管理复杂的多容器应用，实现一键式启动、停止和重新部署。</p><p>以下是 Docker Compose 的一些主要特点：</p><ol><li>服务定义：使用 YAML 语法定义应用程序的各个服务。每个服务都基于一个 Docker 镜像，并且可以配置其端口映射、环境变量、依赖关系等。</li><li>网络管理：Docker Compose 允许用户定义应用程序内部的网络，以便实现服务之间的隔离和通信。默认情况下，Docker Compose 会创建一个网络，并将所有服务连接到该网络。</li><li>卷管理：Docker Compose 支持定义和管理持久化存储卷，以便在容器之间共享数据。这对于数据库等需要持久化存储的应用非常有用。</li><li>依赖管理：Docker Compose 可以管理服务之间的依赖关系，确保服务按照正确的顺序启动和关闭。这可以通过<code>depends_on</code>关键字来实现。</li><li>一键操作：使用<code>docker-compose up</code>命令，可以一次性启动定义在 YAML 文件中的所有服务。同样地，<code>docker-compose down</code>命令可以一次性停止所有服务。</li><li>开发和生产环境配置：Docker Compose 支持使用多个 YAML 文件来覆盖和扩展配置，这使得开发者可以针对开发、测试和生产环境使用不同的配置。</li></ol><p>Docker Compose 大大简化了多容器应用程序的管理，使开发者可以专注于编写应用程序代码，而无需关心底层的容器管理和编排。然而，需要注意的是，虽然 Docker Compose 适用于开发和测试环境，但在生产环境中，可能需要更强大的容器编排工具，如 Kubernetes。</p><h3 id="谈谈你对-K8S-的理解"><a href="#谈谈你对-K8S-的理解" class="headerlink" title="谈谈你对 K8S 的理解"></a>谈谈你对 K8S 的理解</h3><p>Kubernetes（简称 K8s）是一个开源的容器编排平台，旨在自动化部署、扩展和管理容器化应用程序。它最初由 Google 开发，后来成为 Cloud Native Computing Foundation（CNCF）的一部分。Kubernetes 提供了一种声明式的方式来描述应用程序的部署和运行状态，使得复杂的容器化应用程序可以在多个主机上进行分布式部署和管理。</p><p>以下是 Kubernetes 的一些主要特点：</p><ol><li>高可用性：Kubernetes 支持容器在集群的不同节点上进行分布式部署，以实现负载均衡和故障转移。这有助于提高应用程序的可用性和性能。</li><li>水平可扩展：Kubernetes 可以根据负载需求自动扩展或缩减容器实例数量。这可以通过 Deployment 资源中的副本数（Replicas）进行配置。</li><li>自我修复：Kubernetes 监控容器状态，当容器出现故障时，它可以自动重新启动容器、替换容器或重新调度容器到其他节点上，从而确保应用程序始终处于健康状态。</li><li>声明式配置：Kubernetes 使用 YAML 或 JSON 文件描述应用程序的部署和运行状态，这些配置文件可以与源代码一起存储和管理，从而实现基础设施即代码（Infrastructure as Code）。</li><li>服务发现和负载均衡：Kubernetes 提供了内置的服务发现和负载均衡机制，可以将流量自动分发到不同的容器实例上，以实现高可用性和性能。</li><li>存储管理：Kubernetes 支持多种持久化存储解决方案，如 NFS、iSCSI、GlusterFS 等。它允许用户为容器动态配置和管理持久化存储卷。</li><li>密钥和配置管理：Kubernetes 可以管理应用程序的敏感信息（如密码、密钥等）和配置文件，使得这些信息可以在不同的容器实例之间安全地共享。</li><li>强大的生态系统：Kubernetes 拥有丰富的插件和扩展生态系统，例如 Helm（用于包管理）、Prometheus（用于监控）等，这些工具可以帮助用户更好地管理和监控 Kubernetes 集群。</li></ol><p>总之，Kubernetes 是一个功能强大的容器编排平台，它提供了一种高度自动化和可扩展的方式来管理容器化应用程序。尽管 Kubernetes 的学习曲线较陡峭，但对于大型、复杂的应用程序，它是一个非常有价值的工具。</p><hr /><h2 id="数据结构与算法-1"><a href="#数据结构与算法-1" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr: <span class="built_in">number</span>[], low: <span class="built_in">number</span>, high: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="comment">// 获取分区索引</span></span><br><span class="line">    <span class="keyword">const</span> partitionIndex = <span class="title function_">partition</span>(arr, low, high);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="title function_">quickSort</span>(arr, low, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">quickSort</span>(arr, partitionIndex + <span class="number">1</span>, high);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">arr: <span class="built_in">number</span>[], low: <span class="built_in">number</span>, high: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 选择基准值</span></span><br><span class="line">  <span class="keyword">const</span> pivot = arr[high];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化分区索引</span></span><br><span class="line">  <span class="keyword">let</span> i = low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将小于等于基准值的元素放到基准值的左侧</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换基准值和分区索引+1位置的元素</span></span><br><span class="line">  [arr[i + <span class="number">1</span>], arr[high]] = [arr[high], arr[i + <span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回分区索引+1作为新的基准值索引</span></span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分割数组</span></span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用并合并结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left: <span class="built_in">number</span>[], right: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并两个已排序的数组</span></span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span> &amp;&amp; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>()!);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>()!);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将剩余的元素添加到结果数组</span></span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">concat</span>(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mergeSort</span>(arr)); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">heapify</span>(arr, n, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐个提取元素并调整堆结构</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    [arr[<span class="number">0</span>], arr[i]] = [arr[i], arr[<span class="number">0</span>]];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="title function_">heapify</span>(arr, n, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapify</span>(<span class="params">arr: <span class="built_in">number</span>[], n: <span class="built_in">number</span>, i: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> largest = i;</span><br><span class="line">  <span class="keyword">const</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">    [arr[i], arr[largest]] = [arr[largest], arr[i]];</span><br><span class="line">    <span class="title function_">heapify</span>(arr, n, largest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">heapSort</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> swapped;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    swapped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">        swapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有发生交换，说明数组已经有序</span></span><br><span class="line">    <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">bubbleSort</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找最小元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换最小元素与当前元素</span></span><br><span class="line">    <span class="keyword">if</span> (minIndex !== i) &#123;</span><br><span class="line">      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">selectionSort</span>(arr1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将大于 key 的元素向后移动</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 key 到正确位置</span></span><br><span class="line">    arr[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">insertionSort</span>(arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j] = arr[j - gap];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">shellSort</span>(arr3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countingSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr);</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line">  <span class="keyword">const</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">count</span>: <span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="title class_">Array</span>(range).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">output</span>: <span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="title class_">Array</span>(arr.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计元素出现次数</span></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    count[value - min]++;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 累加计数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; range; i++) &#123;</span><br><span class="line">    count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    output[count[arr[i] - min] - <span class="number">1</span>] = arr[i];</span><br><span class="line">    count[arr[i] - min]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr4 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">countingSort</span>(arr4)); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">radixSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line">  <span class="keyword">let</span> exp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Math</span>.<span class="title function_">floor</span>(max / exp) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">countingSortForRadix</span>(arr, exp);</span><br><span class="line">    exp *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countingSortForRadix</span>(<span class="params">arr: <span class="built_in">number</span>[], exp: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">output</span>: <span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">count</span>: <span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计个位数字出现的次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    count[<span class="title class_">Math</span>.<span class="title function_">floor</span>(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 累加计数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    output[count[<span class="title class_">Math</span>.<span class="title function_">floor</span>(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">    count[<span class="title class_">Math</span>.<span class="title function_">floor</span>(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果复制回原数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    arr[i] = output[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr5 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">radixSort</span>(arr5);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr5); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bucketSort</span>(<span class="params">arr: <span class="built_in">number</span>[], bucketSize = <span class="number">5</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr);</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line">  <span class="keyword">const</span> bucketCount = <span class="title class_">Math</span>.<span class="title function_">floor</span>((max - min) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">buckets</span>: <span class="built_in">number</span>[][] = <span class="keyword">new</span> <span class="title class_">Array</span>(bucketCount).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>((arr[i] - min) / bucketSize);</span><br><span class="line">    buckets[index].<span class="title function_">push</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    buckets[i].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将桶中的元素合并到结果数组</span></span><br><span class="line">  <span class="keyword">return</span> ([] <span class="keyword">as</span> <span class="built_in">number</span>[]).<span class="title function_">concat</span>(...buckets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr6 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bucketSort</span>(arr6)); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="二叉树排序（Binary-Tree-Sort）"><a href="#二叉树排序（Binary-Tree-Sort）" class="headerlink" title="二叉树排序（Binary Tree Sort）"></a>二叉树排序（Binary Tree Sort）</h4><p>二叉树排序是指利用二叉搜索树（Binary Search Tree，BST）的特性进行排序的算法。二叉搜索树是一种特殊的二叉树，对于树中的每个节点，其左子树中的所有节点值均小于该节点值，其右子树中的所有节点值均大于该节点值。通过中序遍历二叉搜索树，可以得到一个有序的序列。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个二叉搜索树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个二叉搜索树类，包含插入和中序遍历方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_insertNode</span>(<span class="attr">node</span>: <span class="title class_">TreeNode</span>, <span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inOrderTraversal</span>(): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_inOrderTraversalNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_inOrderTraversalNode</span>(<span class="attr">node</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>, <span class="attr">result</span>: <span class="built_in">number</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_inOrderTraversalNode</span>(node.<span class="property">left</span>, result);</span><br><span class="line">      result.<span class="title function_">push</span>(node.<span class="property">value</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_inOrderTraversalNode</span>(node.<span class="property">right</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binaryTreeSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> bst = <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数组中的值插入二叉搜索树</span></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    bst.<span class="title function_">insert</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中序遍历二叉搜索树，得到排序后的数组</span></span><br><span class="line">  <span class="keyword">return</span> bst.<span class="title function_">inOrderTraversal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr8 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binaryTreeSort</span>(arr8)); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><p>注意，二叉搜索树在极端情况下可能导致不平衡，这会影响排序性能。为了解决这个问题，可以使用平衡二叉搜索树（如 AVL 树或红黑树）进行排序。</p><h4 id="鸽巢排序（Pigeonhole-Sort）"><a href="#鸽巢排序（Pigeonhole-Sort）" class="headerlink" title="鸽巢排序（Pigeonhole Sort）"></a>鸽巢排序（Pigeonhole Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pigeonholeSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr);</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line">  <span class="keyword">const</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">pigeonholes</span>: <span class="built_in">number</span>[][] = <span class="keyword">new</span> <span class="title class_">Array</span>(range).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素放入对应的鸽巢</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    pigeonholes[value - min].<span class="title function_">push</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从鸽巢中取出元素，拼接成排序后的数组</span></span><br><span class="line">  <span class="keyword">return</span> ([] <span class="keyword">as</span> <span class="built_in">number</span>[]).<span class="title function_">concat</span>(...pigeonholes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr7 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pigeonholeSort</span>(arr7)); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="侏儒排序（Gnome-Sort）"><a href="#侏儒排序（Gnome-Sort）" class="headerlink" title="侏儒排序（Gnome Sort）"></a>侏儒排序（Gnome Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gnomeSort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt;= arr[i]) &#123;</span><br><span class="line">      i = j;</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [arr[i - <span class="number">1</span>], arr[i]] = [arr[i], arr[i - <span class="number">1</span>]];</span><br><span class="line">      i -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr9 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">gnomeSort</span>(arr9);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr9); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h4 id="猴子排序（Bogo-Sort）"><a href="#猴子排序（Bogo-Sort）" class="headerlink" title="猴子排序（Bogo Sort）"></a>猴子排序（Bogo Sort）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isSorted</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shuffle</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bogosort</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="title function_">isSorted</span>(arr)) &#123;</span><br><span class="line">    <span class="title function_">shuffle</span>(arr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> arr11 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"><span class="title function_">bogosort</span>(arr11);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr11); <span class="comment">// 输出：[2, 3, 5, 6, 7, 9, 10, 11, 12, 14]</span></span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> sortedArr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>(sortedArr, <span class="number">10</span>)); <span class="comment">// 输出：6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>(sortedArr, <span class="number">4</span>)); <span class="comment">// 输出：-1</span></span><br></pre></td></tr></table></figure><h4 id="插值查找（Interpolation-Search）"><a href="#插值查找（Interpolation-Search）" class="headerlink" title="插值查找（Interpolation Search）"></a>插值查找（Interpolation Search）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">interpolationSearch</span>(<span class="params">arr: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right &amp;&amp; target &gt;= arr[left] &amp;&amp; target &lt;= arr[right]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === right) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[left] === target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> position =</span><br><span class="line">      left +</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">floor</span>(</span><br><span class="line">        ((target - arr[left]) * (right - left)) / (arr[right] - arr[left])</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[position] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[position] &lt; target) &#123;</span><br><span class="line">      left = position + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = position - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> sortedArr3 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">interpolationSearch</span>(sortedArr3, <span class="number">10</span>)); <span class="comment">// 输出：6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">interpolationSearch</span>(sortedArr3, <span class="number">4</span>)); <span class="comment">// 输出：-1</span></span><br></pre></td></tr></table></figure><h4 id="斐波那契查找（Fibonacci-Search）"><a href="#斐波那契查找（Fibonacci-Search）" class="headerlink" title="斐波那契查找（Fibonacci Search）"></a>斐波那契查找（Fibonacci Search）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacciSearch</span>(<span class="params">arr: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fib = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (fib[fib.<span class="property">length</span> - <span class="number">1</span>] &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">    fib.<span class="title function_">push</span>(fib[fib.<span class="property">length</span> - <span class="number">1</span>] + fib[fib.<span class="property">length</span> - <span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> offset = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fib[fib.<span class="property">length</span> - <span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">min</span>(offset + fib[fib.<span class="property">length</span> - <span class="number">2</span>], arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; arr[index]) &#123;</span><br><span class="line">      fib.<span class="title function_">pop</span>();</span><br><span class="line">      offset = index;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[index]) &#123;</span><br><span class="line">      fib.<span class="title function_">pop</span>();</span><br><span class="line">      fib.<span class="title function_">pop</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fib[fib.<span class="property">length</span> - <span class="number">1</span>] &amp;&amp; arr[offset + <span class="number">1</span>] === target) &#123;</span><br><span class="line">    <span class="keyword">return</span> offset + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> sortedArr4 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacciSearch</span>(sortedArr4, <span class="number">10</span>)); <span class="comment">// 输出：6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacciSearch</span>(sortedArr4, <span class="number">4</span>)); <span class="comment">// 输出：-1</span></span><br></pre></td></tr></table></figure><h4 id="指数查找（Exponential-Search）"><a href="#指数查找（Exponential-Search）" class="headerlink" title="指数查找（Exponential Search）"></a>指数查找（Exponential Search）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">exponentialSearch</span>(<span class="params">arr: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[<span class="number">0</span>] === target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr.<span class="property">length</span> &amp;&amp; arr[i] &lt;= target) &#123;</span><br><span class="line">    i *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr.<span class="title function_">slice</span>(i / <span class="number">2</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(i, arr.<span class="property">length</span>)), target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> sortedArr5 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">exponentialSearch</span>(sortedArr5, <span class="number">10</span>)); <span class="comment">// 输出：6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">exponentialSearch</span>(sortedArr5, <span class="number">4</span>)); <span class="comment">// 输出：-1</span></span><br></pre></td></tr></table></figure><h4 id="哈希查找（Hashing）"><a href="#哈希查找（Hashing）" class="headerlink" title="哈希查找（Hashing）"></a>哈希查找（Hashing）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line">  <span class="attr">storage</span>: <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span> = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">has</span>(key) ? <span class="variable language_">this</span>.<span class="property">storage</span>.<span class="title function_">get</span>(key) : <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hashTable = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line"><span class="keyword">const</span> arr6 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组中的值作为键，索引作为值存储到哈希表中</span></span><br><span class="line">arr6.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">  hashTable.<span class="title function_">insert</span>(value, index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashTable.<span class="title function_">search</span>(<span class="number">10</span>)); <span class="comment">// 输出：8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hashTable.<span class="title function_">search</span>(<span class="number">4</span>)); <span class="comment">// 输出：null</span></span><br></pre></td></tr></table></figure><h4 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_insertNode</span>(<span class="attr">node</span>: <span class="title class_">TreeNode</span>, <span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">search</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_searchNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_searchNode</span>(<span class="attr">node</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>, <span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_searchNode</span>(node.<span class="property">left</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_searchNode</span>(node.<span class="property">right</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line"><span class="keyword">const</span> arr7 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向二叉查找树中插入数组中的值</span></span><br><span class="line">arr7.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  bst.<span class="title function_">insert</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bst.<span class="title function_">search</span>(<span class="number">10</span>)); <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bst.<span class="title function_">search</span>(<span class="number">4</span>)); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure><h4 id="平衡二叉查找树（Balanced-Binary-Search-Tree），如-AVL-树、红黑树"><a href="#平衡二叉查找树（Balanced-Binary-Search-Tree），如-AVL-树、红黑树" class="headerlink" title="平衡二叉查找树（Balanced Binary Search Tree），如 AVL 树、红黑树"></a>平衡二叉查找树（Balanced Binary Search Tree），如 AVL 树、红黑树</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTreeNode</span> <span class="keyword">extends</span> <span class="title class_ inherited__">TreeNode</span> &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_insertNode</span>(<span class="attr">node</span>: <span class="title class_">AVLTreeNode</span> | <span class="literal">null</span>, <span class="attr">value</span>: <span class="built_in">number</span>): <span class="title class_">AVLTreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLTreeNode</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(node.<span class="property">left</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.<span class="property">value</span>) &#123;</span><br><span class="line">      node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_insertNode</span>(node.<span class="property">right</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.<span class="property">height</span> =</span><br><span class="line">      <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_height</span>(node.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_height</span>(node.<span class="property">right</span>));</span><br><span class="line">    <span class="keyword">const</span> balance = <span class="variable language_">this</span>.<span class="title function_">_getBalance</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value &lt; (node.<span class="property">left</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>).<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_rotateRight</span>(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_rotateLeft</span>(node.<span class="property">left</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_rotateRight</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; (node.<span class="property">right</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>).<span class="property">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_rotateLeft</span>(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_rotateRight</span>(node.<span class="property">right</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_rotateLeft</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_height</span>(<span class="attr">node</span>: <span class="title class_">TreeNode</span> | <span class="literal">null</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (node <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>).<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_getBalance</span>(<span class="attr">node</span>: <span class="title class_">AVLTreeNode</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_height</span>(node.<span class="property">left</span>) - <span class="variable language_">this</span>.<span class="title function_">_height</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_rotateLeft</span>(<span class="attr">z</span>: <span class="title class_">AVLTreeNode</span>): <span class="title class_">AVLTreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> y = z.<span class="property">right</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">T2</span> = y.<span class="property">left</span>;</span><br><span class="line"></span><br><span class="line">    y.<span class="property">left</span> = z;</span><br><span class="line">    z.<span class="property">right</span> = <span class="variable constant_">T2</span>;</span><br><span class="line"></span><br><span class="line">    z.<span class="property">height</span> = <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_height</span>(z.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_height</span>(z.<span class="property">right</span>));</span><br><span class="line">    y.<span class="property">height</span> = <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_height</span>(y.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_height</span>(y.<span class="property">right</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">_rotateRight</span>(<span class="attr">y</span>: <span class="title class_">AVLTreeNode</span>): <span class="title class_">AVLTreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = y.<span class="property">left</span> <span class="keyword">as</span> <span class="title class_">AVLTreeNode</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">T2</span> = x.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">    x.<span class="property">right</span> = y;</span><br><span class="line">    y.<span class="property">left</span> = <span class="variable constant_">T2</span>;</span><br><span class="line"></span><br><span class="line">    y.<span class="property">height</span> = <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_height</span>(y.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_height</span>(y.<span class="property">right</span>));</span><br><span class="line">    x.<span class="property">height</span> = <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">this</span>.<span class="title function_">_height</span>(x.<span class="property">left</span>), <span class="variable language_">this</span>.<span class="title function_">_height</span>(x.<span class="property">right</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> avl = <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line"><span class="keyword">const</span> arr8 = [<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向平衡二叉查找树中插入数组中的值</span></span><br><span class="line">arr8.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  avl.<span class="title function_">insert</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(avl.<span class="title function_">search</span>(<span class="number">10</span>)); <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(avl.<span class="title function_">search</span>(<span class="number">4</span>)); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure><hr /><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="谈谈你对设计模式的理解，为什么需要设计模式？"><a href="#谈谈你对设计模式的理解，为什么需要设计模式？" class="headerlink" title="谈谈你对设计模式的理解，为什么需要设计模式？"></a>谈谈你对设计模式的理解，为什么需要设计模式？</h3><p>设计模式是针对软件设计中反复出现的问题所提出的通用解决方案。它们是在大量实际软件开发经验中总结出的优秀设计实践，描述了在特定场景下解决问题的方法和思路。设计模式旨在提高代码的可复用性、可扩展性和可维护性，使软件具有更好的灵活性和稳定性。</p><p>设计模式的重要性主要体现在以下几个方面：</p><ol><li>高效解决问题：设计模式为软件设计中常见问题提供了成熟、可靠的解决方案，使开发者能够更高效地解决问题，避免重复发明轮子。</li><li>促进代码复用：设计模式是通用的设计结构，可以在不同的场景和项目中复用，提高了代码的可复用性，减少了开发时间和成本。</li><li>提高代码质量：设计模式强调模块间的低耦合、高内聚，有助于提高代码的可读性、可维护性和稳定性，降低了软件的错误率。</li><li>促进团队协作：设计模式提供了一套通用的设计语言，使得团队成员在交流和理解代码时能够更加顺畅，提高了团队协作效率。</li><li>有益于个人成长：学习和熟练运用设计模式有助于提高开发者的设计能力和编程水平，使得开发者能够在面对复杂问题时更加从容应对。</li></ol><p>设计模式主要分为三大类：</p><ol><li>创建型模式（Creational Patterns）：关注对象的创建过程，如工厂模式、单例模式、原型模式和建造者模式。</li><li>结构型模式（Structural Patterns）：关注类和对象的组合，如适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式和代理模式。</li><li>行为型模式（Behavioral Patterns）：关注对象间的通信，如责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。</li></ol><p>需要注意的是，设计模式并非万能的，它们只是解决特定问题的方法和思路。在实际开发中，应根据具体需求和场景选择合适的设计模式，并且不要过度追求设计模式，以免引入不必要的复杂性。</p><h3 id="谈谈你对工厂模式的理解"><a href="#谈谈你对工厂模式的理解" class="headerlink" title="谈谈你对工厂模式的理解"></a>谈谈你对工厂模式的理解</h3><p>工厂模式（Factory Pattern）是一种创建型设计模式，它的核心思想是将对象的创建过程封装起来，让客户端不直接与具体类进行交互，而是通过一个统一的接口来创建所需的对象。这样，当需要修改或者扩展对象的创建逻辑时，我们只需要修改工厂类，而不需要修改客户端的代码，从而达到降低耦合度和提高代码可维护性的目的。</p><p>工厂模式主要分为以下几种类型：</p><ol><li>简单工厂模式（Simple Factory Pattern）：一个工厂类根据传入的参数创建对应的对象。这种模式的缺点是，当需要添加新的产品时，需要修改工厂类的代码，违反了开放封闭原则。</li><li>工厂方法模式（Factory Method Pattern）：定义一个工厂接口，让各个具体工厂类实现这个接口，负责创建对应的产品。客户端只需要与工厂接口进行交互，而不关心具体的工厂和产品类。这种模式遵循了开放封闭原则，当需要添加新的产品时，只需添加相应的具体工厂类，不需要修改其他代码。</li><li>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式可以应对更复杂的场景，比如创建多个产品族的产品。客户端同样只需与抽象工厂接口进行交互，实现了对象创建过程的解耦。</li></ol><p>工厂模式的优点：</p><ol><li>降低了客户端与具体产品类之间的耦合度，提高了代码可维护性。</li><li>代码结构清晰，易于扩展和修改。</li><li>可以实现对象的复用，节省资源。</li></ol><p>工厂模式的缺点：</p><ol><li>工厂类职责过重，当产品种类繁多时，代码可能变得复杂。</li><li>增加了系统的抽象性和理解难度。</li></ol><p>总之，工厂模式通过封装对象的创建过程，降低了客户端与具体产品类之间的耦合度，提高了代码的可维护性和扩展性。在实际开发中，可以根据项目的具体需求来选择适用的工厂模式类型。</p><h3 id="谈谈你对单例模式的理解"><a href="#谈谈你对单例模式的理解" class="headerlink" title="谈谈你对单例模式的理解"></a>谈谈你对单例模式的理解</h3><p>单例模式（Singleton Pattern）是一种创建型设计模式，其核心思想是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。这种模式适用于那些在整个系统中需要唯一实例的场景，如数据库连接池、配置管理器、日志记录器等。单例模式可以确保系统中该类的实例具有全局唯一性，避免了多次创建和销毁实例带来的资源浪费和潜在的错误。</p><p>实现单例模式的关键点包括：</p><ol><li>将构造方法私有化，以防止客户端通过 new 关键字创建实例。</li><li>在类内部创建一个静态私有实例变量。</li><li>提供一个公共的静态方法（通常命名为 getInstance()）来获取该实例。</li></ol><p>单例模式有多种实现方式，主要包括以下几种：</p><ol><li>懒汉式：实例在第一次调用 getInstance() 方法时创建。这种方式的优点是实现了延迟加载，缺点是在多线程环境下可能出现线程安全问题，需要通过加锁等手段解决。</li><li>饿汉式：实例在类加载时创建。这种方式的优点是线程安全，缺点是没有实现延迟加载，如果实例的创建过程比较耗时或资源消耗较大，可能会导致性能问题。</li><li>双重检查锁定（Double-Checked Locking）：结合懒汉式和同步锁，在 getInstance() 方法内部进行双重判断，确保线程安全且避免了不必要的同步开销。</li><li>静态内部类：利用 Java 的静态内部类特性，在静态内部类中创建单例实例，实现了延迟加载且线程安全。</li><li>枚举：使用枚举类型实现单例，这种方式是线程安全的，而且代码简洁易懂。这也是《Effective Java》一书推荐的实现方式。</li></ol><p>单例模式的优点：</p><ol><li>保证了实例的全局唯一性，避免了资源浪费和潜在的错误。</li><li>可以实现全局访问，方便使用。</li></ol><p>单例模式的缺点：</p><ol><li>单例类的职责过重，可能违反单一职责原则。</li><li>若实例需要扩展，可能会引入修改困难。</li></ol><p>总之，单例模式通过确保一个类只有一个实例，并提供一个全局访问点来获取该实例，可以在一定程度上提高系统的性能和资源利用率。在实际开发中，应根据具体需求选择合适的单例模式实现方式。</p><h3 id="谈谈你对策略模式的理解"><a href="#谈谈你对策略模式的理解" class="headerlink" title="谈谈你对策略模式的理解"></a>谈谈你对策略模式的理解</h3><p>策略模式（Strategy Pattern）是一种行为型设计模式，其核心思想是定义一系列算法，将它们封装成策略类，并使它们可以相互替换。策略模式使得算法可以独立于使用它的客户端而变化，这样可以实现在不修改客户端代码的情况下，灵活地改变和扩展算法。策略模式将算法的定义和使用分离，降低了算法之间的耦合，提高了代码的可扩展性和可维护性。</p><p>策略模式通常包含以下几个部分：</p><ol><li>策略接口（Strategy Interface）：定义一个公共接口，用于声明所有策略类需要实现的方法。</li><li>具体策略类（Concrete Strategy）：实现策略接口，封装具体的算法和行为。</li><li>上下文类（Context）：持有一个策略接口的引用，用于调用具体策略类的方法。客户端可以通过修改上下文类持有的策略引用来改变算法。</li></ol><p>策略模式的优点：</p><ol><li>算法和客户端解耦：策略模式将算法的定义和使用分离，使得客户端与具体算法解耦，降低了模块间的耦合度。</li><li>易于扩展和替换：策略模式将每个算法封装成独立的策略类，可以方便地添加新的策略或替换现有策略，而无需修改客户端代码。</li><li>提高代码可读性：策略模式将不同的算法和行为封装到具体策略类中，使得代码结构更加清晰，提高了代码的可读性和可维护性。</li><li>遵循开放封闭原则：通过策略模式，可以在不修改客户端代码的前提下，灵活地改变和扩展算法，符合开放封闭原则。</li></ol><p>策略模式的缺点：</p><ol><li>增加了代码数量：每个策略都需要定义一个具体策略类，当策略较多时，会导致类数量的增加。</li><li>客户端需要了解策略的区别：虽然策略模式将算法的使用与实现分离，但客户端仍需要了解不同策略之间的区别，以便选择合适的策略。</li></ol><p>总之，策略模式通过将算法封装成策略类并定义一个统一的策略接口，实现了算法和客户端的解耦，提高了代码的复用性。</p><h3 id="谈谈你对观察者模式的理解"><a href="#谈谈你对观察者模式的理解" class="headerlink" title="谈谈你对观察者模式的理解"></a>谈谈你对观察者模式的理解</h3><p>观察者模式（Observer Pattern），又称发布-订阅模式（Publish-Subscribe Pattern），是一种行为型设计模式。它定义了对象之间的一对多依赖关系，当一个对象（被观察者）的状态发生改变时，所有依赖于它的对象（观察者）都会得到通知并自动更新。观察者模式用于实现事件驱动的架构，降低了对象之间的耦合，提高了代码的灵活性和可扩展性。</p><p>观察者模式主要包含以下几个部分：</p><ol><li>抽象被观察者（Subject）：定义了添加、删除和通知观察者的方法。被观察者维护一个观察者列表，用于存储所有注册的观察者。</li><li>具体被观察者（Concrete Subject）：实现抽象被观察者的接口，具有一些状态，当这些状态发生变化时，通知所有注册的观察者。</li><li>抽象观察者（Observer）：定义一个更新方法，用于接收被观察者状态变化的通知。</li><li>具体观察者（Concrete Observer）：实现抽象观察者的接口，当接收到被观察者状态变化的通知时，执行相应的更新操作。</li></ol><p>观察者模式的优点：</p><ol><li>降低耦合度：观察者模式使得被观察者与观察者之间的依赖关系变得松散，它们可以独立地变化和复用，提高了代码的灵活性。</li><li>支持事件驱动：观察者模式可以实现基于事件的通知机制，使得对象之间可以相互通知和响应，有助于实现复杂的事件驱动架构。</li><li>易于扩展：通过添加新的观察者，可以方便地扩展系统的功能，而无需修改被观察者的代码。</li></ol><p>观察者模式的缺点：</p><ol><li>可能引发循环调用：在实际应用中，如果观察者与被观察者之间存在循环依赖关系，可能会引发循环调用，导致系统崩溃。</li><li>通知顺序不可控：被观察者通知观察者的顺序是不可控的，这可能导致一些依赖于通知顺序的问题。</li></ol><p>总之，观察者模式通过定义对象之间的一对多依赖关系，实现了事件驱动的架构，降低了对象间的耦合，提高了代码的灵活性和可扩展性。在实际开发中，观察者模式广泛应用于实现各种事件监听和通知机制，如用户界面的事件处理、消息推送、日志记录等。</p><p>在使用观察者模式时，还需要注意以下几点：</p><ol><li>避免循环调用：确保被观察者和观察者之间不存在循环依赖关系，以防止循环调用导致的问题。</li><li>考虑性能问题：观察者模式的通知机制可能会导致大量的观察者被通知，从而影响系统性能。在设计时，应合理选择观察者的数量和通知策略，以减轻性能压力。</li><li>封装通知逻辑：为了让被观察者更加通用，可以考虑将通知观察者的逻辑封装到一个单独的类中，使得被观察者聚焦于自身业务逻辑。</li><li>使用现有框架：许多现代编程语言和框架都提供了对观察者模式的支持，如 Java 中的 <code>java.util.Observable</code> 和 <code>java.util.Observer</code> 类，C# 中的事件和委托机制等。在实际开发中，可以充分利用这些现有功能，避免重复造轮子。</li></ol><p>综上所述，观察者模式是一种实用且灵活的设计模式，它提供了一种有效的方式来解决对象间的通信和依赖问题。在实际开发中，应根据具体需求和场景选择合适的观察者模式实现方式，并注意避免可能存在的问题。</p><h3 id="谈谈你对命令模式的理解"><a href="#谈谈你对命令模式的理解" class="headerlink" title="谈谈你对命令模式的理解"></a>谈谈你对命令模式的理解</h3><p>命令模式（Command Pattern）是一种行为型设计模式，它将请求封装为一个对象，从而使客户端可以用不同的请求对接收者进行参数化。命令模式还支持可撤销的操作，可以将请求的发送者与接收者解耦，使得请求的发送者不需要知道接收者的具体实现。命令模式可以提高代码的灵活性和可扩展性，广泛应用于实现任务队列、事务处理、日志记录等功能。</p><p>命令模式主要包含以下几个部分：</p><ol><li>抽象命令类（Command）：定义一个抽象的接口，用于声明执行操作的方法。通常包含一个或多个抽象方法，如 <code>execute()</code>、<code>undo()</code> 等。</li><li>具体命令类（Concrete Command）：实现抽象命令类的接口，封装接收者和一组行为。具体命令类通常包含一个接收者（Receiver）的引用，并在 <code>execute()</code> 方法中调用接收者的相应方法。</li><li>接收者（Receiver）：实现具体的业务逻辑，提供命令类需要执行的方法。</li><li>调用者（Invoker）：持有一个命令对象的引用，负责调用命令对象的 <code>execute()</code> 方法。调用者可以是客户端代码，也可以是一个中间类，负责接收客户端的请求并调用命令对象。</li></ol><p>命令模式的优点：</p><ol><li>解耦请求发送者与接收者：命令模式将请求封装成命令对象，使得发送者与接收者之间的依赖关系变得松散，提高了代码的灵活性。</li><li>易于扩展：通过添加新的具体命令类，可以方便地扩展系统功能，而无需修改现有代码。</li><li>支持撤销操作：命令模式可以通过实现 <code>undo()</code> 方法来支持撤销操作，使得客户端可以撤销已执行的命令。</li><li>方便实现任务队列、事务和日志记录：命令模式可以将命令对象存储在队列中，实现任务调度和事务处理；同时，可以将命令对象序列化到日志文件中，实现日志记录和恢复功能。</li></ol><p>命令模式的缺点：</p><ol><li>增加了类的数量：每个具体命令都需要定义一个类，当命令较多时，会导致类数量的增加，增加了系统的复杂性。</li><li>可能增加系统开销：由于命令对象的创建和调用，命令模式可能会导致额外的开销，尤其是在高性能要求的场景下。</li></ol><p>总之，命令模式通过将请求封装为命令对象，实现了请求的发送者与接收者之间的解耦，提高了代码的灵活性和可扩展性。在实际开发中，命令模式可以应用于以下场景：</p><ol><li>需要将请求发送者与接收者解耦的场景：当请求发送者不需要知道接收者的具体实现时，可以使用命令模式将请求封装为命令对象，从而实现解耦。</li><li>需要支持撤销操作的场景：命令模式可以通过实现 <code>undo()</code> 方法来支持撤销操作，使客户端可以方便地撤销已执行的命令。</li><li>需要实现任务队列、事务处理或日志记录的场景：命令模式可以将命令对象存储在队列中，实现任务调度和事务处理；同时，可以将命令对象序列化到日志文件中，实现日志记录和恢复功能。</li></ol><p>在使用命令模式时，需要注意以下几点：</p><ol><li>合理划分命令类：为了降低系统的复杂性，应该合理地划分命令类，避免创建过多的具体命令类。</li><li>注意性能开销：由于命令对象的创建和调用可能导致额外的开销，因此在高性能要求的场景下，应考虑是否适合使用命令模式。</li><li>使用现有框架：许多现代编程语言和框架都提供了对命令模式的支持，如 C# 中的委托和命令绑定等。在实际开发中，可以充分利用这些现有功能，避免重复造轮子。</li></ol><p>总之，命令模式是一种实用且灵活的设计模式，它提供了一种有效的方式来解决请求发送者与接收者之间的解耦问题。在实际开发中，应根据具体需求和场景选择合适的命令模式实现方式，并注意避免可能存在的问题。</p><h3 id="谈谈你模板方法模式的理解"><a href="#谈谈你模板方法模式的理解" class="headerlink" title="谈谈你模板方法模式的理解"></a>谈谈你模板方法模式的理解</h3><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，将算法的具体步骤延迟到子类中实现。模板方法模式允许子类在不改变算法结构的情况下，重新定义算法的某些步骤。这种模式可以帮助我们提高代码的复用性和封装性，降低了系统的复杂性。</p><p>模板方法模式主要包含以下几个部分：</p><ol><li>抽象类（Abstract Class）：定义了一个模板方法，它包含了算法的骨架。模板方法由一系列具体方法和抽象方法组成，具体方法由抽象类实现，抽象方法由子类实现。抽象类可以定义一些钩子方法（Hook Methods），用于在特定情况下让子类改变算法的行为。</li><li>具体子类（Concrete Class）：实现抽象类中的抽象方法，提供算法的具体实现。子类可以根据需求，覆盖或扩展抽象类中的钩子方法。</li></ol><p>模板方法模式的优点：</p><ol><li>代码复用：通过将通用的算法骨架定义在抽象类中，子类可以复用这些代码，降低了代码的重复度。</li><li>封装性：模板方法模式将具体实现细节封装在子类中，使得客户端只需要关注抽象类的接口，提高了系统的封装性。</li><li>扩展性：子类可以覆盖或扩展抽象类中的钩子方法，从而实现对算法的灵活扩展。</li><li>易于维护：将算法骨架和具体实现分离，有利于维护和修改。</li></ol><p>模板方法模式的缺点：</p><ol><li>类数量增加：对于每个实现不同的算法，都需要定义一个具体子类，这可能导致类数量的增加。</li><li>需要继承：模板方法模式依赖于继承关系，可能会导致子类过于庞大，影响代码的可读性和维护性。</li></ol><p>总之，模板方法模式是一种实用且灵活的设计模式，它通过定义算法的骨架，将具体实现延迟到子类中，实现了代码复用和封装性。在实际开发中，模板方法模式适用于以下场景：</p><ol><li><p>算法骨架固定，但具体实现可能不同的场景。</p></li><li><p>当需要在不改变算法结构的情况下，重新定义算法的某些步骤。</p></li><li><p>当子类需要复用父类的某些通用行为，但又希望保留扩展和覆盖的能力时。</p></li></ol><p>在使用模板方法模式时，需要注意以下几点：</p><ol><li>合理划分抽象方法和具体方法：为了保持代码的清晰和易于维护，应合理地划分抽象方法和具体方法，将可复用的代码放入抽象类中，将具体实现放入子类中。</li><li>合理使用钩子方法：钩子方法可以让子类有机会改变算法的行为，但不要过度使用，以免导致系统的复杂性增加。</li><li>避免过度继承：模板方法模式依赖于继承关系，因此在设计时要避免过度继承，可以考虑使用组合和聚合等方式来减轻子类的负担。</li><li>保持抽象类的稳定性：抽象类定义了算法的骨架，对其的修改可能会影响到所有子类。因此，在设计时要确保抽象类的稳定性，尽量避免对其进行修改。</li></ol><p>总之，模板方法模式通过定义算法的骨架，将具体实现延迟到子类中，提高了代码的复用性和封装性。在实际开发中，应根据具体需求和场景选择合适的模板方法模式实现方式，并注意避免可能存在的问题。</p><h3 id="谈谈你对迭代器模式的理解"><a href="#谈谈你对迭代器模式的理解" class="headerlink" title="谈谈你对迭代器模式的理解"></a>谈谈你对迭代器模式的理解</h3><h3 id="谈谈你对状态模式的理解"><a href="#谈谈你对状态模式的理解" class="headerlink" title="谈谈你对状态模式的理解"></a>谈谈你对状态模式的理解</h3><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变其行为。状态模式将对象的状态封装为独立的类，使得状态转换和行为的实现变得更加清晰。状态模式可以消除大量的条件判断语句，提高代码的可读性和可维护性。</p><p>状态模式主要包含以下几个部分：</p><ol><li>抽象状态类（State）：定义了一个接口，用于封装与特定状态相关的行为。通常包含一个或多个抽象方法，如 <code>handle()</code>。</li><li>具体状态类（Concrete State）：实现抽象状态类的接口，提供具体状态对应的行为实现。每个具体状态类通常只表示对象的一种状态。</li><li>上下文类（Context）：维护一个当前状态的引用，并提供一个接口来改变当前状态。上下文类通常会将行为委托给当前状态对象来执行。</li></ol><p>状态模式的优点：</p><ol><li>封装性：将状态和与状态相关的行为封装在一起，使得代码结构更加清晰。</li><li>易于扩展：通过添加新的状态类，可以方便地扩展系统的功能，而无需修改现有代码。</li><li>消除条件判断：状态模式通过委托给状态对象来执行行为，避免了大量的条件判断语句，提高了代码的可读性和可维护性。</li><li>符合开闭原则：状态模式对扩展开放，对修改封闭，增加新的状态类不会影响现有代码。</li></ol><p>状态模式的缺点：</p><ol><li>类数量增加：对于每个具体状态，都需要定义一个状态类，这可能导致类数量的增加，增加了系统的复杂性。</li><li>状态切换逻辑分散：状态切换的逻辑可能分散在状态类和上下文类中，这可能导致状态切换逻辑的复杂性增加。</li></ol><p>总之，状态模式是一种实用且灵活的设计模式，它通过将对象的状态封装为独立的类，实现了状态转换和行为的清晰表示。在实际开发中，状态模式适用于以下场景：</p><ol><li>当一个对象的行为依赖于其状态，且状态数量较多时。</li><li>当需要在运行时改变对象的行为，且这些行为依赖于对象的状态时。</li><li>当系统中存在大量的与状态相关的条件判断语句，导致代码难以维护和扩展时。</li></ol><p>在使用状态模式时，需要注意合理划分状态类，并关注状态切换逻辑的实现。</p><h3 id="谈谈你对装饰者模式的理解"><a href="#谈谈你对装饰者模式的理解" class="headerlink" title="谈谈你对装饰者模式的理解"></a>谈谈你对装饰者模式的理解</h3><p>装饰者模式（Decorator Pattern）是一种结构型设计模式，它允许在不修改原始类代码的情况下，动态地为对象添加新的功能。装饰者模式使用一种组合的方式，将新功能附加到原始对象上，从而遵循了开闭原则，使得系统具有较好的可扩展性。</p><p>装饰者模式主要包含以下几个部分：</p><ol><li>抽象组件类（Component）：定义一个抽象接口，用于规范需要被装饰的对象的行为。</li><li>具体组件类（Concrete Component）：实现抽象组件类的接口，表示需要被装饰的对象。</li><li>抽象装饰者类（Decorator）：继承自抽象组件类，并持有一个抽象组件类的引用。抽象装饰者类的主要作用是为子类提供统一的接口，并将请求转发给持有的抽象组件对象。</li><li>具体装饰者类（Concrete Decorator）：继承自抽象装饰者类，实现具体的装饰功能。具体装饰者类可以在原有功能的基础上，添加新的功能。</li></ol><p>装饰者模式的优点：</p><ol><li>灵活性：装饰者模式可以动态地为对象添加新功能，而不需要修改原始类的代码，使得系统更具灵活性。</li><li>可扩展性：通过添加新的具体装饰者类，可以方便地扩展系统的功能，符合开闭原则。</li><li>组合灵活：装饰者模式可以通过组合不同的装饰者类，实现多种不同的功能组合。</li><li>易于维护：装饰者模式将不同的功能分离到不同的装饰者类中，有利于代码的维护和修改。</li></ol><p>装饰者模式的缺点：</p><ol><li>类数量增加：对于每个装饰功能，都需要定义一个具体装饰者类，这可能导致类数量的增加，增加了系统的复杂性。</li><li>增加了系统的复杂性：由于装饰者模式使用了组合关系，这可能导致系统的结构变得更加复杂。</li></ol><p>总之，装饰者模式是一种实用且灵活的设计模式，它允许在不修改原始类代码的情况下，动态地为对象添加新功能。在实际开发中，装饰者模式适用于以下场景：</p><ol><li>当需要为一个现有类添加新功能，但又不想修改原始类的代码时。</li><li>当需要通过组合多个功能，实现不同的功能组合时。</li><li>当需要在运行时动态地为对象添加功能，且这些功能可以相互独立地叠加时。</li></ol><p>在使用装饰者模式时，需要注意以下几点：</p><ol><li>合理设计抽象组件类和抽象装饰者类：为了保持代码的清晰和易于维护，应合理地设计抽象组件类和抽象装饰者类，确保它们具有清晰的职责和良好的封装性。</li><li>注意装饰者类的创建和组合：装饰者模式依赖于装饰者类的创建和组合，因此在设计时要关注这些方面，确保装饰者类可以灵活地创建和组合。</li><li>避免过度使用装饰者模式：虽然装饰者模式具有很好的灵活性和可扩展性，但是过度使用可能导致系统变得过于复杂。在实际开发中，应根据具体需求和场景选择合适的设计模式。</li><li>考虑性能影响：由于装饰者模式使用了多层的组合关系，这可能导致性能损失。在设计和实现时，应关注性能影响，避免因为过多的嵌套而导致性能下降。</li></ol><p>总之，装饰者模式是一种实用且灵活的设计模式，它允许在不修改原始类代码的情况下，动态地为对象添加新功能。在实际开发中，应根据具体需求和场景选择合适的装饰者模式实现方式，并注意避免可能存在的问题。</p><h3 id="谈谈你对适配器模式的理解"><a href="#谈谈你对适配器模式的理解" class="headerlink" title="谈谈你对适配器模式的理解"></a>谈谈你对适配器模式的理解</h3><p>适配器模式是一种结构型设计模式，它的主要目标是使得那些原本不兼容的接口能够一起工作。简单来说，适配器可以作为两个不同对象之间的桥梁，这两个对象可能由于接口不同而无法直接进行交互。</p><p>在软件设计中，适配器模式常用于以下场景：</p><ol><li><p>旧代码与新代码交互：如果你在开发过程中引入了新的类，这个新的类的接口与现有代码不兼容，但你又不希望更改现有代码，那么你可以创建一个适配器。这个适配器能够同时与新的类和现有代码进行交互，确保它们能够顺利地协同工作。</p></li><li><p>外部系统或库：当你的应用需要与外部系统或者第三方库进行交互，而这些系统或者库的接口并不符合你的预期，这个时候适配器模式也能发挥作用。</p></li><li><p>统一接口：如果你的系统中有多个类，它们执行相似的功能但接口不同，使用适配器可以使得这些类有统一的接口，这将使你的代码更加易于管理和维护。</p></li></ol><p>在适配器模式中，通常会有以下几个角色：</p><ol><li><p>目标（Target）：这是你期望得到的接口，你的系统需要通过这个接口与服务进行交互。</p></li><li><p>适配器（Adapter）：这是实现了目标接口的类。适配器会把调用请求转发给适配者。</p></li><li><p>适配者（Adaptee）：这是需要被适配的类或系统。它的接口与目标接口不同，因此不能直接与你的系统交互。</p></li><li><p>客户（Client）：这是使用目标接口的类。客户通过目标接口与适配器进行交互，而无需知道适配器和适配者的存在。</p></li></ol><p>适配器模式是一种非常实用的设计模式，它提供了一种灵活的方式来创建、组合和复用对象，特别是那些不直接兼容的对象。</p><h3 id="谈谈你对外观模式的理解"><a href="#谈谈你对外观模式的理解" class="headerlink" title="谈谈你对外观模式的理解"></a>谈谈你对外观模式的理解</h3><p>外观模式（Facade Pattern）是一种结构型设计模式，它为一组复杂的子系统提供一个统一的接口，使得这些子系统更容易被客户端使用。外观模式通过定义一个高层接口，将复杂的子系统实现隐藏起来，从而简化了客户端与子系统之间的交互。</p><p>外观模式主要包含以下几个部分：</p><ol><li>外观类（Facade）：提供一个简单的接口，用于与客户端进行交互。外观类将客户端的请求委托给相应的子系统，处理子系统间的依赖关系，使得客户端与子系统之间的交互变得更加简单。</li><li>子系统类（Subsystem）：表示系统内部的各个子系统，实现具体的业务逻辑。子系统类可以独立工作，且不依赖于外观类。子系统类通常具有复杂的接口和实现。</li></ol><p>外观模式的优点：</p><ol><li>简化接口：外观模式为复杂的子系统提供了一个简化的接口，使得客户端与子系统的交互变得更加简单。</li><li>降低耦合：外观模式将客户端与子系统之间的依赖关系降低到最小，有利于系统的解耦和维护。</li><li>提高可维护性：外观模式将子系统的实现细节隐藏起来，使得客户端无需关心这些细节，有利于提高系统的可维护性。</li><li>符合迪米特原则：外观模式使得客户端只需要与外观类进行交互，而无需直接与子系统类交互，从而遵循了迪米特原则。</li></ol><p>外观模式的缺点：</p><ol><li>有限的封装：外观模式可能无法完全封装所有子系统的功能，有时客户端可能需要直接访问子系统类，以实现一些特定的功能。</li><li>过多的依赖：如果系统中的外观类数量过多，可能导致客户端与外观类之间的依赖过多，从而影响系统的解耦。</li></ol><p>总之，外观模式是一种实用且简单的设计模式，它通过定义一个统一的接口，简化了客户端与复杂子系统之间的交互。在实际开发中，外观模式适用于以下场景：</p><ol><li>当需要为一个复杂的子系统提供一个简化的接口时。</li><li>当需要将客户端与子系统之间的依赖降低到最小时。</li><li>当需要将多个子系统组合使用，以实现更复杂的功能时。</li></ol><p>在使用外观模式时，需要注意以下几点：</p><ol><li>合理划分子系统：为了保持代码的清晰和易于维护，应合理地划分子系统，确保子系统具有清晰的职责和良好的封装性。</li><li>设计简单易用的外观接口：外观类的主要目的是简化客户端与子系统的交互，因此在设计外观类时，应该关注接口的简单性和易用性。</li><li>不要过度封装：虽然外观模式可以将子系统的实现细节隐藏起来，但在实际开发中，有时客户端可能需要直接访问子系统类。因此，在设计外观模式时，应避免过度封装。</li><li>注意外观类与子系统的解耦：外观类应尽量减少对子系统的直接依赖，以保持系统的解耦。如果子系统需要进行修改或升级，应尽量避免影响到外观类和客户端。</li></ol><p>通过合理地使用外观模式，可以简化复杂子系统与客户端之间的交互，降低系统的耦合度，提高系统的可维护性。在实际开发中，应根据具体需求和场景选择合适的外观模式实现方式，并注意避免可能存在的问题。</p><h3 id="谈谈你对代理模式的理解"><a href="#谈谈你对代理模式的理解" class="headerlink" title="谈谈你对代理模式的理解"></a>谈谈你对代理模式的理解</h3><p>代理模式是一种常用的结构型设计模式，其主要目标是通过引入一个新的对象（即代理对象）来控制对原对象的访问。代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>代理模式主要有三种常见的形式：</p><ol><li><p>虚拟代理：如果一个对象的加载或初始化非常消耗资源，虚拟代理可以延迟这个对象的创建直到真正需要的时候。例如，网页中的图片加载就可以使用虚拟代理，只有当图片在屏幕上滚动到可视范围内时，才开始加载真正的图片。</p></li><li><p>保护代理：如果一个对象有权限控制需求，保护代理可以决定哪些客户端可以访问该对象。例如，一些对象可能只允许管理员角色进行访问和操作。</p></li><li><p>远程代理：如果一个对象在不同的地址空间（例如，另一台机器上），远程代理可以隐藏这个对象存在于不同地址空间的事实。例如，在分布式系统或网络通信中，客户端对象通常会与一个本地的代理对象通信，这个代理对象负责通过网络与远程对象通信。</p></li></ol><p>在代理模式中，通常涉及以下几个角色：</p><ol><li><p>抽象主题（Subject）：定义了 RealSubject 和 Proxy 的公共接口，这样在任何使用 RealSubject 的地方都可以使用 Proxy。</p></li><li><p>真实主题（RealSubject）：定义了 Proxy 所代表的真实实体。</p></li><li><p>代理（Proxy）：保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口。</p></li><li><p>客户（Client）：通过 Proxy 访问 RealSubject。</p></li></ol><p>使用代理模式的好处在于，客户端可以透明地使用代理，而不需要知道代理背后的复杂机制。这种设计模式特别适用于那些需要分离关注点的情况，从而使得我们可以聚焦于我们真正关心的业务逻辑，而不是其他辅助性的工作，比如访问控制、负载、网络通信等。</p><h3 id="谈谈你对组合模式的理解"><a href="#谈谈你对组合模式的理解" class="headerlink" title="谈谈你对组合模式的理解"></a>谈谈你对组合模式的理解</h3><p>组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示“部分-整体”的层次关系，使得客户端可以以一致的方式处理单个对象和组合对象。组合模式适用于处理具有层次结构的数据，例如文件系统、组织结构等。</p><p>组合模式主要包含以下几个部分：</p><ol><li>抽象组件（Component）：定义一个接口，用于规范组合对象和叶子对象的公共行为。抽象组件通常包含一些基本操作，如添加子组件、删除子组件、获取子组件等。</li><li>叶子组件（Leaf）：表示树形结构中的叶子节点，实现抽象组件接口。叶子组件没有子组件，它负责实现具体的业务逻辑。</li><li>组合组件（Composite）：表示树形结构中的非叶子节点，实现抽象组件接口。组合组件包含一个子组件列表，用于存储其子组件。组合组件负责实现基本操作，如添加子组件、删除子组件、获取子组件等。同时，组合组件还可以实现其他与业务逻辑相关的操作。</li></ol><p>组合模式的优点：</p><ol><li>统一操作：组合模式使得客户端可以以一致的方式处理单个对象和组合对象，简化了客户端的操作。</li><li>易于扩展：组合模式允许添加新的组件类型，只需实现抽象组件接口即可，不需要修改现有的代码。</li><li>更好地表示层次结构：组合模式可以很好地表示具有层次关系的数据结构，如文件系统、组织结构等。</li></ol><p>组合模式的缺点：</p><ol><li>过度泛化：由于抽象组件接口定义了所有可能的操作，这可能导致叶子组件和组合组件之间的界限变得模糊，增加了实现的复杂性。</li><li>违反接口隔离原则：抽象组件接口可能包含一些对叶子组件和组合组件来说并不适用的方法，这违反了接口隔离原则。</li></ol><p>总之，组合模式是一种实用且简单的设计模式，它通过定义一个统一的抽象组件接口，使得客户端可以以一致的方式处理单个对象和组合对象。在实际开发中，组合模式适用于处理具有层次结构的数据，如文件系统、组织结构等。在使用组合模式时，应注意避免过度泛化和违反接口隔离原则的问题。</p><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>操作系统（Operating System，简称 OS）是计算机硬件与用户之间的接口，负责管理和协调计算机硬件资源，为应用程序和用户提供一个友好的运行环境。操作系统具有多种功能，包括进程管理、内存管理、文件系统管理和设备管理等。</p><p>操作系统使得程序员和用户不必关心底层硬件的具体细节，可以更高效地开发和使用计算机。常见的操作系统有 Microsoft Windows、macOS、Linux 等。</p><h3 id="软链接和硬链接的区别是什么？"><a href="#软链接和硬链接的区别是什么？" class="headerlink" title="软链接和硬链接的区别是什么？"></a>软链接和硬链接的区别是什么？</h3><p>软链接（符号链接，Symbolic Link）和硬链接（Hard Link）是两种不同类型的文件链接，通常用于在 Unix 和类 Unix 的文件系统中创建文件或目录的引用。它们之间的主要区别如下：</p><ol><li>存储方式：硬链接是在文件系统中创建一个与原始文件具有相同的 i-node（索引节点）号的新条目。这意味着硬链接与原始文件共享相同的数据块和属性。因此，它们是同一个文件的不同引用。相反，软链接则是一个独立的文件，它的 i-node 不同于原始文件。软链接包含了指向原始文件的路径信息。</li><li>删除操作：当删除原始文件时，硬链接仍然可以访问文件的内容，因为它们共享相同的数据块。然而，当删除原始文件时，软链接将失效，因为它仅包含指向原始文件的路径信息。这时，软链接就成了一个悬空的（或者说失效的）链接。</li><li>跨文件系统：硬链接只能在同一个文件系统中创建，因为它们共享相同的 i-node。而软链接可以跨文件系统创建，因为它们只是指向原始文件的路径，而不是具体的数据块。</li><li>链接类型：硬链接只能针对文件创建，不能针对目录。软链接则可以针对文件和目录创建。</li></ol><p>总之，硬链接是对原始文件内容的直接引用，而软链接是对原始文件路径的引用。硬链接共享与原始文件相同的 i-node 和数据块，而软链接具有独立的 i-node。</p><h3 id="并发和并行有什么区别？"><a href="#并发和并行有什么区别？" class="headerlink" title="并发和并行有什么区别？"></a>并发和并行有什么区别？</h3><p>并发（Concurrency）和并行（Parallelism）是计算机科学中两个相关但不同的概念。它们都涉及到多任务处理，但执行方式和目标有所不同。</p><ol><li>并发（Concurrency）：并发是指多个任务在同一时间段内交替执行，但在某个特定时刻，仅有一个任务在运行。这通常是通过任务之间快速切换来实现的，以便在一个任务等待资源（如 I&#x2F;O 操作）时执行另一个任务。并发主要出现在单核处理器或者多核处理器但核心数量少于任务数量的情况下。并发的目标是充分利用处理器资源，提高资源的使用效率。</li><li>并行（Parallelism）：并行是指多个任务在同一时刻同时执行。这通常是通过多核处理器或多处理器系统来实现的，每个处理器或核心负责处理一个或多个任务。并行的目标是利用多个处理器或核心加速任务的完成，提高性能。</li></ol><p>总之，区别在于执行方式和目标：并发关注在同一时间段内多任务的交替执行，以提高资源利用率；而并行关注在同一时刻同时执行多个任务，以提高处理速度。在现实场景中，这两个概念可能同时存在，例如在多核处理器系统中执行多个并发任务。</p><h3 id="协程与线程的区别"><a href="#协程与线程的区别" class="headerlink" title="协程与线程的区别"></a>协程与线程的区别</h3><p>协程（Coroutine）和线程（Thread）都是用于实现并发执行的概念，但它们之间存在一些关键区别：</p><ol><li>调度方式：线程的调度由操作系统内核管理，通常是抢占式调度。操作系统根据线程优先级和运行时间等因素在不同线程之间进行切换。相比之下，协程的调度是由程序自身控制的，通常采用协作式调度。协程之间的切换由协程自身决定，例如在某个协程遇到 I&#x2F;O 操作或显式让出执行权时切换到另一个协程。</li><li>并发模型：线程是基于多任务并发执行的，每个线程在单独的执行上下文中运行。协程是基于单任务或多任务的并发执行，可以看作是轻量级的线程。在协程模型中，多个协程在同一个线程内共享执行上下文，通过协作式调度来实现并发。</li><li>资源消耗：线程通常比协程消耗更多的系统资源，因为每个线程都有自己的栈和内核资源。协程由于在用户态运行并共享同一个线程的执行上下文，通常具有更低的内存和系统资源消耗。</li><li>上下文切换开销：线程间的上下文切换涉及到内核态和用户态的切换，通常具有较大的开销。而协程间的上下文切换仅发生在用户态，不需要内核参与，因此开销较小。</li></ol><p>总之，协程和线程都是实现并发执行的方法，但它们在调度方式、并发模型、资源消耗和上下文切换开销等方面存在区别。协程是一种轻量级的并发机制，适用于 I&#x2F;O 密集型任务和需要大量并发执行的场景。线程则适用于 CPU 密集型任务和多核处理器系统。</p><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程（Process）和线程（Thread）是计算机科学中与并发和并行执行相关的两个基本概念。它们之间的主要区别如下：</p><ol><li>定义和独立性：进程是一个独立的运行环境，包含了一个程序在运行过程中所需要的所有资源，如代码、数据、内存空间和系统资源等。每个进程在操作系统中都有独立的内存空间和地址空间。线程是进程内的一个执行单元，可以共享进程的资源。一个进程可以包含多个线程，它们共享进程的内存空间和系统资源，但每个线程都有自己独立的运行栈和局部变量。</li><li>上下文切换开销：线程间的上下文切换通常比进程间的上下文切换要快得多。因为线程共享进程的内存空间，所以在切换时不需要切换整个内存空间，只需要切换线程运行栈和寄存器状态等少量信息。而进程间的上下文切换需要更多的开销，因为它们具有独立的地址空间。</li><li>通信和同步：线程之间的通信和同步通常比进程之间的通信和同步更简单，因为线程共享进程的内存空间，可以直接访问其他线程的数据。进程之间的通信需要通过操作系统提供的进程间通信（IPC）机制，如管道、信号量、共享内存等。</li><li>容错性：由于进程具有独立的地址空间，一个进程的崩溃不太可能影响到其他进程。然而，线程共享进程的内存空间，一个线程的崩溃可能导致整个进程的崩溃，从而影响到进程中的其他线程。</li></ol><p>总之，进程是一个独立的执行环境，拥有独立的内存空间，而线程是进程内的执行单元，共享进程的资源。线程之间的上下文切换和通信开销相对较小，但容错性较差。</p><h3 id="什么是死锁？死锁产生的条件？"><a href="#什么是死锁？死锁产生的条件？" class="headerlink" title="什么是死锁？死锁产生的条件？"></a>什么是死锁？死锁产生的条件？</h3><p>死锁（Deadlock）是指在多任务环境中，一组或多组任务相互等待对方释放资源的一种状态。在这种情况下，任务之间互相阻塞，无法继续执行。死锁可能导致系统性能下降或完全停止工作。</p><p>产生死锁的四个必要条件如下：</p><ol><li>互斥条件（Mutual Exclusion）：资源不能被多个任务同时占用。也就是说，一旦一个任务获得某资源，其他任务必须等待该资源被释放。</li><li>占有并等待条件（Hold and Wait）：任务持有至少一个资源，同时等待其他任务释放的资源。这意味着任务既占有资源，又在等待其他资源。</li><li>非抢占条件（No Preemption）：资源不能被强制从任务中抢占。换句话说，在任务完成之前，它持有的资源不能被其他任务抢占。</li><li>循环等待条件（Circular Wait）：存在一组任务，它们构成了一个循环等待资源的链，即每个任务都在等待下一个任务持有的资源。</li></ol><p>要避免死锁，必须破坏产生死锁的这四个条件中的至少一个。常见的死锁预防和解决方法包括资源分配策略（如银行家算法）、资源有序分配、死锁检测与恢复等。</p><h3 id="进程调度策略有哪几种？"><a href="#进程调度策略有哪几种？" class="headerlink" title="进程调度策略有哪几种？"></a>进程调度策略有哪几种？</h3><p>进程调度策略是操作系统用于管理进程执行顺序和分配 CPU 时间的方法。以下是一些常见的进程调度策略：</p><ol><li>先来先服务（First-Come, First-Served，FCFS）：按照进程到达的顺序进行调度。一旦一个进程开始执行，它将一直占用 CPU，直到完成。这种策略简单易实现，但可能导致较长的平均等待时间。</li><li>短作业优先（Shortest Job First，SJF）：根据进程的预计运行时间进行调度。具有较短运行时间的进程优先执行。这种策略可以降低平均等待时间，但需要预先知道进程的运行时间，实际中很难实现。</li><li>优先级调度（Priority Scheduling）：根据进程的优先级进行调度。优先级高的进程先执行。这种策略允许更重要的进程优先执行，但可能导致低优先级进程长时间得不到调度（饥饿现象）。</li><li>时间片轮转（Round Robin，RR）：为每个进程分配一个固定长度的时间片（或称为时间量子），然后按顺序执行。当一个进程的时间片用完时，调度器将其放到就绪队列的末尾，然后开始执行下一个进程。这种策略实现简单，公平性较好，适用于交互式系统。</li><li>多级反馈队列（Multilevel Feedback Queue）：将进程分配到不同优先级的队列中，并根据队列优先级和时间片轮转策略进行调度。这种策略可以在保证系统响应性的同时兼顾 CPU 利用率。</li></ol><p>这些进程调度策略各有优缺点，适用于不同的场景。在实际操作系统中，可能会采用混合或改进的调度策略，以满足不同需求。</p><h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>虚拟内存（Virtual Memory）是一种内存管理技术，它使得计算机能够为程序提供比实际物理内存更大的地址空间。通过虚拟内存技术，操作系统能够将程序和数据分割成多个独立的内存块（称为页面或页），并将这些内存块在需要时分别加载到物理内存中。同时，操作系统可以将不常用的内存块交换到磁盘上的一个专门区域（称为交换区或页面文件），从而腾出物理内存空间。</p><p>虚拟内存的主要优点如下：</p><ol><li>内存抽象：虚拟内存为每个进程提供了独立的地址空间，使进程可以在隔离的环境中运行，不需要关心其他进程的内存分配情况。</li><li>内存保护：由于每个进程拥有独立的地址空间，因此一个进程无法直接访问其他进程的内存，保证了内存安全。</li><li>空间扩展：虚拟内存允许程序使用比实际物理内存更大的地址空间，从而使得程序能够在物理内存有限的情况下正常运行。</li><li>内存共享：虚拟内存技术可以实现不同进程间的内存共享，例如共享库和内存映射文件等。</li><li>内存利用率提高：虚拟内存通过按需分配页面、将不常用的页面交换到磁盘等方式，提高了物理内存的利用率。</li></ol><p>虚拟内存的实现依赖于硬件支持，如内存管理单元（Memory Management Unit，MMU）等。MMU 负责将虚拟地址转换为物理地址，并在访问权限检查和页面错误处理等方面与操作系统协同工作。</p><hr><h2 id="编码题"><a href="#编码题" class="headerlink" title="编码题"></a>编码题</h2><h3 id="用-setTimeout-实现-setInterval"><a href="#用-setTimeout-实现-setInterval" class="headerlink" title="用 setTimeout 实现 setInterval"></a>用 setTimeout 实现 setInterval</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">customSetInterval</span>(<span class="params">callback: () =&gt; <span class="built_in">void</span>, delay: <span class="built_in">number</span></span>): <span class="function">() =&gt;</span> <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">interval</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(interval, delay);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回清除定时器的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> delay = <span class="number">1000</span>; <span class="comment">// 每隔1000毫秒执行一次</span></span><br><span class="line"><span class="keyword">const</span> clearIntervalFunc = <span class="title function_">customSetInterval</span>(callback, delay);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：在需要的时候清除定时器</span></span><br><span class="line"><span class="comment">// clearIntervalFunc();</span></span><br></pre></td></tr></table></figure><h3 id="var-实现-let"><a href="#var-实现-let" class="headerlink" title="var 实现 let"></a>var 实现 let</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 &quot;Hello, world!&quot;</span></span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 抛出 ReferenceError，因为x在这个作用域内未定义</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 输出错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">demo</span>();</span><br></pre></td></tr></table></figure><h3 id="实现所有的-TypeScript-Utility-Types"><a href="#实现所有的-TypeScript-Utility-Types" class="headerlink" title="实现所有的 TypeScript Utility Types"></a>实现所有的 TypeScript Utility Types</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Partial&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Required&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Readonly&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Pick&lt;T, K&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [P <span class="keyword">in</span> K]: T[P] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Omit&lt;T, K&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. Exclude&lt;T, U&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. Extract&lt;T, U&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. NonNullable&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = <span class="title class_">Exclude</span>&lt;T, <span class="literal">null</span> | <span class="literal">undefined</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. ReturnType&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. InstanceType&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InstanceType</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. ThisParameterType&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ThisParameterType</span>&lt;T&gt; = T <span class="keyword">extends</span> (<span class="attr">this</span>: infer U, ...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? U</span><br><span class="line">  : unknown;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12. OmitThisParameter&lt;T&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OmitThisParameter</span>&lt;T&gt; = T <span class="keyword">extends</span> (<span class="attr">this</span>: <span class="built_in">any</span>, ...<span class="attr">args</span>: infer A) =&gt; infer R</span><br><span class="line">  ? <span class="function">(<span class="params">...args: A</span>) =&gt;</span> R</span><br><span class="line">  : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 13. ThisType&lt;T&gt;</span></span><br><span class="line"><span class="comment">// `ThisType` is a marker utility type and can&#x27;t be implemented like other utility types.</span></span><br></pre></td></tr></table></figure><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params"></span></span><br><span class="line"><span class="params">  func: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  wait: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">timeout</span>: <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setTimeout</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params"></span></span><br><span class="line"><span class="params">  func: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  limit: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lastCall = <span class="number">0</span>; <span class="comment">// 记录上次调用的时间戳</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前时间与上次调用的时间差大于等于设定的限制时间，执行函数并更新上次调用时间</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastCall &gt;= limit) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">      lastCall = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">customNew</span>(<span class="params">constructorFn: <span class="built_in">Function</span>, ...args: <span class="built_in">any</span>[]</span>): <span class="built_in">object</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructorFn.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建一个新对象，并将其原型链设置为构造函数的prototype</span></span><br><span class="line">  <span class="keyword">const</span> result = constructorFn.<span class="title function_">apply</span>(obj, args); <span class="comment">// 调用构造函数并将this绑定到新创建的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果构造函数返回了一个对象，那么返回这个对象，否则返回创建的新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> &amp;&amp; result !== <span class="literal">null</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alice = <span class="title function_">customNew</span>(<span class="title class_">Person</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>) <span class="keyword">as</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alice.<span class="property">name</span>); <span class="comment">// 输出 &quot;Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alice.<span class="property">age</span>); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uniqueArray</span> = (<span class="params">arr: <span class="built_in">any</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Second</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uniqueArray</span> = (<span class="params">arr: <span class="built_in">any</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Third</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uniqueArray</span> = (<span class="params">arr: <span class="built_in">any</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uniqueArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="实现正则切分千分位"><a href="#实现正则切分千分位" class="headerlink" title="实现正则切分千分位"></a>实现正则切分千分位</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatThousands</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line">  <span class="keyword">const</span> num = n.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">const</span> formattedNum = num.<span class="title function_">replace</span>(reg, <span class="string">&quot;$&amp;,&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> formattedNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatThousands</span>(<span class="number">123456789</span>)); <span class="comment">// 输出: 123,456,789</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatThousands</span>(<span class="number">1000000</span>)); <span class="comment">// 输出: 1,000,000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatThousands</span>(<span class="number">9876543210</span>)); <span class="comment">// 输出: 9,876,543,210</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现自定义call方法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> uniqueKey = <span class="title class_">Symbol</span>(<span class="string">&quot;uniqueKey&quot;</span>);</span><br><span class="line">  thisArg[uniqueKey] = fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[uniqueKey](...args);</span><br><span class="line">  <span class="keyword">delete</span> thisArg[uniqueKey];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting: <span class="built_in">string</span>, punctuation: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;punctuation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">myCall</span>(obj, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;!&quot;</span>); <span class="comment">// 输出 &quot;Hello, Alice!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现自定义apply方法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg: <span class="built_in">any</span>, args: <span class="built_in">any</span>[]</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> uniqueKey = <span class="title class_">Symbol</span>(<span class="string">&quot;uniqueKey&quot;</span>);</span><br><span class="line">  thisArg[uniqueKey] = fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[uniqueKey](...args);</span><br><span class="line">  <span class="keyword">delete</span> thisArg[uniqueKey];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting: <span class="built_in">string</span>, punctuation: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;punctuation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">myApply</span>(obj, [<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;!&quot;</span>]); <span class="comment">// 输出 &quot;Hi, Alice!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现自定义bind方法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  thisArg: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  ...args1: <span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params"></span>): <span class="function">(<span class="params">...args2: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">myApply</span>(thisArg, args1.<span class="title function_">concat</span>(args2));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting: <span class="built_in">string</span>, punctuation: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;punctuation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">myBind</span>(obj, <span class="string">&quot;Hey&quot;</span>);</span><br><span class="line"><span class="title function_">boundGreet</span>(<span class="string">&quot;?&quot;</span>); <span class="comment">// 输出 &quot;Hey, Alice?&quot;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj: <span class="built_in">any</span>, cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">get</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj.<span class="title function_">getTime</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      obj.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">clonedArr</span>: <span class="built_in">any</span>[] = [];</span><br><span class="line">    cache.<span class="title function_">set</span>(obj, clonedArr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      clonedArr[i] = <span class="title function_">deepClone</span>(obj[i], cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clonedArr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">clonedObj</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; = &#123;&#125;;</span><br><span class="line">  cache.<span class="title function_">set</span>(obj, clonedObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, key)) &#123;</span><br><span class="line">      clonedObj[key] = <span class="title function_">deepClone</span>(obj[key], cache);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clonedObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">original</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">dateOfBirth</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;1993-01-01&quot;</span>),</span><br><span class="line">  <span class="attr">preferences</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">    <span class="attr">food</span>: <span class="string">&quot;pizza&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">original.<span class="property">original</span> = original;</span><br><span class="line">original.<span class="property">originalArr</span> = [original, original];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloned = <span class="title function_">deepClone</span>(original);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloned); <span class="comment">// 输出与 original 相同但不是同一个引用的对象</span></span><br></pre></td></tr></table></figure><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span>): <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arity = fn.<span class="property">length</span>; <span class="comment">// 获取原函数的参数个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= arity) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...restArgs: <span class="built_in">any</span>[]</span>) =&gt;</span> curried.<span class="title function_">apply</span>(<span class="literal">null</span>, args.<span class="title function_">concat</span>(restArgs));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure><h3 id="es5-和-es6-继承"><a href="#es5-和-es6-继承" class="headerlink" title="es5 和 es6 继承"></a>es5 和 es6 继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5继承（构造函数 + 原型链）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AnimalES5</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AnimalES5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DogES5</span>(<span class="params">name: string, breed: string</span>) &#123;</span><br><span class="line">  <span class="title class_">AnimalES5</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DogES5</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">AnimalES5</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 设置原型链</span></span><br><span class="line"><span class="title class_">DogES5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">DogES5</span>; <span class="comment">// 修复构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">DogES5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayBreed</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My breed is &quot;</span> + <span class="variable language_">this</span>.<span class="property">breed</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> dogES5 = <span class="keyword">new</span> <span class="title class_">DogES5</span>(<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>);</span><br><span class="line">dogES5.<span class="title function_">sayName</span>(); <span class="comment">// 输出 &quot;My name is Max&quot;</span></span><br><span class="line">dogES5.<span class="title function_">sayBreed</span>(); <span class="comment">// 输出 &quot;My breed is Golden Retriever&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6继承（使用class和extends关键字）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalES6</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogES6</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalES6</span> &#123;</span><br><span class="line">  <span class="attr">breed</span>: string;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, breed: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayBreed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My breed is &quot;</span> + <span class="variable language_">this</span>.<span class="property">breed</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> dogES6 = <span class="keyword">new</span> <span class="title class_">DogES6</span>(<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>);</span><br><span class="line">dogES6.<span class="title function_">sayName</span>(); <span class="comment">// 输出 &quot;My name is Max&quot;</span></span><br><span class="line">dogES6.<span class="title function_">sayBreed</span>(); <span class="comment">// 输出 &quot;My breed is Golden Retriever&quot;</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现 instanceof</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">target: <span class="built_in">any</span>, constructorFunc: <span class="built_in">Function</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 参数校验</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> ||</span><br><span class="line">    target === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> constructorFunc !== <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取目标对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> targetProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取构造函数的原型</span></span><br><span class="line">  <span class="keyword">const</span> constructorProto = constructorFunc.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历原型链，查找目标对象是否是构造函数的实例</span></span><br><span class="line">  <span class="keyword">while</span> (targetProto !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetProto === constructorProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    targetProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(targetProto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(dog, <span class="title class_">Dog</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(dog, <span class="title class_">Animal</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(cat, <span class="title class_">Dog</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(cat, <span class="title class_">Animal</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(<span class="number">123</span>, <span class="title class_">Number</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现数组扁平化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归处理每个元素</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processItem</span>(<span class="params">item: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果元素是数组，则递归处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      item.<span class="title function_">forEach</span>(processItem);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果元素不是数组，直接添加到结果数组中</span></span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  arr.<span class="title function_">forEach</span>(processItem);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, [<span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]], <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenArray</span>(nestedArray)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nestedArray2 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, [[<span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>]]]]];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenArray</span>(nestedArray2)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure><h3 id="对象扁平化"><a href="#对象扁平化" class="headerlink" title="对象扁平化"></a>对象扁平化</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;,</span></span><br><span class="line"><span class="params">  prefix = <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="params"></span>): &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">flattened</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> newKey = prefix ? <span class="string">`<span class="subst">$&#123;prefix&#125;</span>.<span class="subst">$&#123;key&#125;</span>`</span> : key;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">        obj[key] !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj[key])</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(flattened, <span class="title function_">flattenObject</span>(obj[key], newKey));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flattened[newKey] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flattened;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> nestedObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      <span class="attr">c</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">d</span>: &#123;</span><br><span class="line">        <span class="attr">e</span>: <span class="number">2</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">g</span>: &#123;</span><br><span class="line">    <span class="attr">h</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flattenedObj = <span class="title function_">flattenObject</span>(nestedObj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedObj);</span><br><span class="line"><span class="comment">// 输出 &#123; &#x27;a.b.c&#x27;: 1, &#x27;a.b.d.e&#x27;: 2, &#x27;a.f&#x27;: 3, &#x27;g.h&#x27;: 4 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myJSONParse</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">`(<span class="subst">$&#123;target&#125;</span>)`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> jsonString = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> parsedObject = <span class="title function_">myJSONParse</span>(jsonString);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parsedObject); <span class="comment">// &#123; name: &#x27;JOHN&#x27;, age: 30, city: &#x27;NEW YORK&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="EventEmitter-事件触发器"><a href="#EventEmitter-事件触发器" class="headerlink" title="EventEmitter 事件触发器"></a>EventEmitter 事件触发器</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">events</span>: <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Array</span>&lt;<span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 存储事件名和对应的回调函数列表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加事件监听</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="attr">event</span>: <span class="built_in">string</span>, <span class="attr">listener</span>: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">has</span>(event)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(event, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(event)!.<span class="title function_">push</span>(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件监听</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="attr">event</span>: <span class="built_in">string</span>, <span class="attr">listener</span>: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listeners = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = listeners.<span class="title function_">indexOf</span>(listener);</span><br><span class="line">      <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">        listeners.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">event</span>: <span class="built_in">string</span>, ...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> listeners = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">      listeners.<span class="title function_">forEach</span>(<span class="function">(<span class="params">listener</span>) =&gt;</span> listener.<span class="title function_">apply</span>(<span class="literal">null</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加只执行一次的事件监听</span></span><br><span class="line">  <span class="title function_">once</span>(<span class="attr">event</span>: <span class="built_in">string</span>, <span class="attr">listener</span>: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">wrappedListener</span> = (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; &#123;</span><br><span class="line">      listener.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(event, wrappedListener);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(event, wrappedListener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">on</span>(<span class="string">&quot;greet&quot;</span>, hello);</span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&quot;greet&quot;</span>, <span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出 &quot;Hello, Alice!&quot;</span></span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">off</span>(<span class="string">&quot;greet&quot;</span>, hello);</span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&quot;greet&quot;</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 不会输出，因为监听器已被移除</span></span><br><span class="line"></span><br><span class="line">eventEmitter.<span class="title function_">once</span>(<span class="string">&quot;welcome&quot;</span>, hello);</span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&quot;welcome&quot;</span>, <span class="string">&quot;Carol&quot;</span>); <span class="comment">// 输出 &quot;Hello, Carol!&quot;</span></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&quot;welcome&quot;</span>, <span class="string">&quot;David&quot;</span>); <span class="comment">// 不会输出，因为监听器只执行一次</span></span><br></pre></td></tr></table></figure><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">customAsync</span>(<span class="params">generatorFn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Generator</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> generator = generatorFn.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">result: IteratorResult&lt;<span class="built_in">any</span>&gt;</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(result.<span class="property">value</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(result.<span class="property">value</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">handle</span>(generator.<span class="title function_">next</span>(value)))</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="title function_">handle</span>(generator.<span class="property">throw</span>!(error)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handle</span>(generator.<span class="title function_">next</span>());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;First result&quot;</span>), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;Second result&quot;</span>), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myAsyncFunction = <span class="title function_">customAsync</span>(myGenerator);</span><br><span class="line"><span class="title function_">myAsyncFunction</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)); <span class="comment">// 依次输出 &quot;First result&quot;, &quot;Second result&quot;, &quot;Done&quot;</span></span><br></pre></td></tr></table></figure><h3 id="正则获取-url-params"><a href="#正则获取-url-params" class="headerlink" title="正则获取 url params"></a>正则获取 url params</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现获取 URL 参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUrlParams</span>(<span class="params">url: <span class="built_in">string</span></span>): <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">params</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> regex = <span class="regexp">/[?&amp;]([^=&amp;#]+)=([^&amp;#]*)/g</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">match</span>: <span class="title class_">RegExpExecArray</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用正则表达式匹配 URL 参数</span></span><br><span class="line">  <span class="keyword">while</span> ((match = regex.<span class="title function_">exec</span>(url)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将匹配到的参数名称和值添加到结果对象中</span></span><br><span class="line">    params[<span class="built_in">decodeURIComponent</span>(match[<span class="number">1</span>])] = <span class="built_in">decodeURIComponent</span>(match[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> testUrl1 =</span><br><span class="line">  <span class="string">&quot;https://www.example.com/test?name=John&amp;age=30&amp;city=New%20York&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title function_">getUrlParams</span>(testUrl1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// &#123; name: &#x27;John&#x27;, age: &#x27;30&#x27;, city: &#x27;New York&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testUrl2 = <span class="string">&quot;https://www.example.com/test?query=test&amp;page=1&amp;filter=active&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">getUrlParams</span>(testUrl2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// &#123; query: &#x27;test&#x27;, page: &#x27;1&#x27;, filter: &#x27;active&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params"></span></span><br><span class="line"><span class="params">  url: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  params: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;,</span></span><br><span class="line"><span class="params">  callbackName: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个全局回调函数，用于接收请求返回的数据</span></span><br><span class="line">    (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>)[callbackName] = <span class="function">(<span class="params">data: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>)[callbackName]; <span class="comment">// 请求完成后删除全局回调函数</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script); <span class="comment">// 移除script标签</span></span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 解析Promise，返回数据</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求参数和回调函数名添加到URL</span></span><br><span class="line">    <span class="keyword">const</span> queryString = <span class="title class_">Object</span>.<span class="title function_">entries</span>(params)</span><br><span class="line">      .<span class="title function_">map</span>(</span><br><span class="line">        <span class="function">(<span class="params">[key, value]</span>) =&gt;</span></span><br><span class="line">          <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(key)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span></span><br><span class="line">      )</span><br><span class="line">      .<span class="title function_">join</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> finalUrl = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;queryString&#125;</span>&amp;callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并插入一个script标签，用于发起JSONP请求</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    script.<span class="property">src</span> = finalUrl;</span><br><span class="line">    script.<span class="property">onerror</span> = <span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;JSONP request failed&quot;</span>)); <span class="comment">// 监听错误事件以处理请求失败的情况</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://api.example.com/data&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">  <span class="attr">userId</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">accessToken</span>: <span class="string">&quot;abcdefgh&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> callbackName = <span class="string">&quot;jsonpCallback&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonp</span>(url, params, callbackName)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">customJSONStringify</span>(<span class="params">obj: <span class="built_in">any</span></span>): <span class="built_in">string</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">seenObjects</span>: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">stringify</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="built_in">string</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> value === <span class="string">&quot;boolean&quot;</span> ||</span><br><span class="line">      value === <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">String</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&quot;<span class="subst">$&#123;value&#125;</span>&quot;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">typeof</span> value === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span> ||</span><br><span class="line">      value <span class="keyword">instanceof</span> <span class="title class_">Symbol</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seenObjects.<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Converting circular structure to JSON&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    seenObjects.<span class="title function_">push</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> arr = value.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="title function_">stringify</span>(item) ?? <span class="string">&quot;null&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;arr.join(<span class="string">&quot;,&quot;</span>)&#125;</span>]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(value).<span class="title function_">filter</span>(</span><br><span class="line">      <span class="function">(<span class="params">key</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> value[key] !== <span class="string">&quot;function&quot;</span> &amp;&amp; <span class="keyword">typeof</span> value[key] !== <span class="string">&quot;undefined&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> keyValuePairs = keys.<span class="title function_">map</span>(</span><br><span class="line">      <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="string">`&quot;<span class="subst">$&#123;key&#125;</span>&quot;:<span class="subst">$&#123;stringify(value[key]) ?? <span class="string">&quot;null&quot;</span>&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;keyValuePairs.join(<span class="string">&quot;,&quot;</span>)&#125;</span>&#125;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">stringify</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">preferences</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">    <span class="attr">food</span>: <span class="string">&quot;pizza&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">customJSONStringify</span>(obj)); <span class="comment">// 输出 &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;preferences&quot;:&#123;&quot;color&quot;:&quot;blue&quot;,&quot;food&quot;:&quot;pizza&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">PromiseStatus</span> &#123;</span><br><span class="line">  <span class="title class_">Pending</span> = <span class="string">&quot;PENDING&quot;</span>,</span><br><span class="line">  <span class="title class_">Fulfilled</span> = <span class="string">&quot;FULFILLED&quot;</span>,</span><br><span class="line">  <span class="title class_">Rejected</span> = <span class="string">&quot;REJECTED&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomPromise</span> &#123;</span><br><span class="line">  <span class="attr">status</span>: <span class="title class_">PromiseStatus</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">reason</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">onFulfilledCallbacks</span>: <span class="title class_">Array</span>&lt;<span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br><span class="line">  <span class="attr">onRejectedCallbacks</span>: <span class="title class_">Array</span>&lt;<span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    executor: (</span></span><br><span class="line"><span class="params">      resolve: (value?: <span class="built_in">any</span>) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">      reject: (reason?: <span class="built_in">any</span>) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params">    ) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">PromiseStatus</span>.<span class="property">Pending</span>; <span class="comment">// 初始状态为Pending</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>; <span class="comment">// 存储成功时的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">null</span>; <span class="comment">// 存储失败时的原因</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = []; <span class="comment">// 存储成功时的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = []; <span class="comment">// 存储失败时的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value?: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">PromiseStatus</span>.<span class="property">Pending</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">PromiseStatus</span>.<span class="property">Fulfilled</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="title function_">callback</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason?: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">PromiseStatus</span>.<span class="property">Pending</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">PromiseStatus</span>.<span class="property">Rejected</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="title function_">callback</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(</span><br><span class="line">    onFulfilled?: <span class="function">(<span class="params">value: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>,</span><br><span class="line">    onRejected?: <span class="function">(<span class="params">reason: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line">  ): <span class="title class_">CustomPromise</span> &#123;</span><br><span class="line">    onFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">CustomPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handleFulfilled</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = onFulfilled!(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">          <span class="keyword">if</span> (result === promise) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">CustomPromise</span>) &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handleRejected</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = onRejected!(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">          <span class="keyword">if</span> (result === promise) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">CustomPromise</span>) &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">PromiseStatus</span>.<span class="property">Fulfilled</span>) &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(handleFulfilled);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">PromiseStatus</span>.<span class="property">Rejected</span>) &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(handleRejected);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> <span class="title function_">queueMicrotask</span>(handleFulfilled));</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> <span class="title function_">queueMicrotask</span>(handleRejected));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected?: <span class="function">(<span class="params">reason: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>): <span class="title class_">CustomPromise</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式"><a href="#写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式" class="headerlink" title="写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式"></a>写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryParam</span>(<span class="params">paramName</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> urlParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>);</span><br><span class="line">  <span class="keyword">return</span> urlParams.<span class="title function_">get</span>(paramName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> myParamValue = <span class="title function_">getQueryParam</span>(<span class="string">&quot;myParam&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myParamValue); <span class="comment">// 输出myParam参数的值</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryParam</span>(<span class="params">paramName</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> params = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substr</span>(<span class="number">1</span>).<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; params.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> keyValuePair = params[i].<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>);=</span><br><span class="line">    <span class="keyword">if</span> (keyValuePair[<span class="number">0</span>] === paramName) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(keyValuePair[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> myParamValue = <span class="title function_">getQueryParam</span>(<span class="string">&#x27;myParam&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myParamValue); <span class="comment">// 输出myParam参数的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023 前端面试题&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题</title>
    <link href="http://example.com/2023/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-07T09:22:13.000Z</published>
    <updated>2023-08-31T17:58:06.407Z</updated>
    
    <content type="html"><![CDATA[<p>前端面试题</p><span id="more"></span><h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><p>简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。<br>1、重点</p><ul><li>简历就像高考作文——阅卷时间非常短。</li><li>内容要简洁。</li><li>直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。</li></ul><p>2、简历包含的内容</p><ul><li><p>个人信息。</p></li><li><p>专业技能。</p></li><li><p>工作经历。</p></li><li><p>项目经历。</p></li><li><p>社区贡献。</p><p>2.1 基本信息</p></li><li><p>必备：姓名 电话 邮箱。</p></li><li><p>年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。</p></li><li><p>头像无所谓（好看就放上呗）。</p></li><li><p>可以放 github 链接，前提是有内容。</p><p>2.2 专业技能</p></li><li><p>表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。</p></li><li><p>内容不要太多，3、5 条即可。</p></li><li><p>太基础的不要写，例如会用 vscode、<a href="https://www.zhihu.com/search?q=lodash&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2430900871%7D">lodash</a>。</p><p>2.3 工作经历</p></li><li><p>如实写。</p></li><li><p>写明公司，职位，入职离职时间即可，多写无益。</p></li><li><p>如果有空窗期，如实写明即可。</p><p>2.4 项目经历</p></li><li><p>写 2-4 个具有说服力的项目（不要什么项目都写，没用）。</p></li><li><p>项目名称，项目描述，技术栈，个人角色。</p><p>2.5 社区贡献</p></li><li><p>有博客或者开源作品，会让你更有竞争力。</p></li><li><p>切记：需要真的有内容，不可临时抱佛脚。</p></li></ul><p>3、注意事项</p><ul><li>界面不能太花哨，简洁明了即可。</li><li>注意用词，“精通”“熟练”等慎用，可用“熟悉”。</li><li>不可造假，会被拉入黑名单。</li></ul><p>4、面试前准备</p><ul><li>看 JD，是否需要临时准备一下。</li><li>打印纸质简历，带着纸和笔（增加好印象）。</li><li>最好带着自己电脑，现场可能手写代码（带一个帆布包最适合，又优雅又方便）。</li><li>要有时间观念，如果迟到或者推迟，要提前说。</li><li>衣着适当，不用正装，也不要太随意。</li><li>为何离职？—— 不要吐槽前东家，说自己的原因（想找一个更好的发展平台等）。</li><li>能加班吗？—— 能！除非你特别自信，能找到其他机会。</li><li>不要挑战面试官，即便他错了（面试一定要保证愉快）。</li><li>遇到不会的问题，要表现出自己积极的一面（不好意思哈，确实是我的知识盲区，可以跟我说下 xxx 吗，我回去研究一下）。</li></ul><h1 id="HTML-CSS-面试题"><a href="#HTML-CSS-面试题" class="headerlink" title="HTML+CSS 面试题"></a>HTML+CSS 面试题</h1><p>HTML 和 CSS 面试题答不出来基本可以回去了。<br>1、HTML 面试题<br>以下是针对 HTML 相关的面试题，一般来说这地方不会出太多题，面试官也不愿意花太多时间在这上面。<br>1.1 如何理解 HTML 语义化？</p><ul><li><p>让人更容易读懂（增加代码可读性）。</p></li><li><p>让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。</p></li><li><p>在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。</p><p>1.2 script 标签中 defer 和 async 的区别？</p></li><li><p><code>script</code> ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</p></li><li><p><code>async script</code> ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</p></li><li><p><code>defer script</code>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</p></li></ul><p>下图清晰地展示了三种 <code>script</code> 的过程：</p><p><img src="/lcz/./assets/img/interview/1.png" alt="img"></p><p>推荐文章：</p><ul><li><p><a href="./assets/img/interview/1.png">图解 script 标签中的 async 和 defer 属性</a></p><p>1.3 从浏览器地址栏输入 url 到请求返回发生了什么</p></li></ul><p>先阅读这篇科普性质的：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903784229896199">从 URL 输入到页面展现到底发生什么？</a> 先阅读篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6935232082482298911">从输入 URL 开始建立前端知识体系</a>。</p><ol><li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。</li></ol><ul><li>强缓存。</li><li>协商缓存。</li></ul><ol><li>DNS 域名解析。（<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6990344840181940261">字节面试被虐后，是时候搞懂 DNS 了</a>）</li><li>TCP 连接。<br>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点<strong>可靠传输</strong>决定的。客户端和服务端要进行可靠传输，那么就需要<strong>确认双方的接收和发送能力</strong>。第一次握手可以确认客服端的<strong>发送能力</strong>，第二次握手，确认了服务端的<strong>发送能力和接收能力</strong>，所以第三次握手才可以确认客户端的<strong>接收能力</strong>。不然容易出现丢包的现象。</li><li>http 请求。</li><li>服务器处理请求并返回 HTTP 报文。</li><li>浏览器渲染页面。</li></ol><p><img src="/lcz/./assets/img/interview2.png" alt="img"></p><ol><li>断开 TCP 连接。</li></ol><p>2、CSS 面试题<br>以下是针对 CSS 相关的面试题，这些题答不出来会给人非常不好的技术印象。<br>2.1 盒模型介绍<br>CSS3 中的盒模型有以下两种：<strong>标准盒模型</strong>、<strong>IE（替代）盒模型</strong>。<br>两种盒子模型都是由 <code>content + padding + border + margin</code> 构成，其大小都是由 <code>content + padding + border</code> 决定的，但是盒子内容宽&#x2F;高度（即 <code>width/height</code>）的计算范围根据盒模型的不同会有所不同：</p><ul><li>标准盒模型：只包含 <code>content</code> 。</li><li>IE（替代）盒模型：<code>content + padding + border</code> 。</li></ul><p>可以通过 <code>box-sizing</code> 来改变元素的盒模型：</p><ul><li><p><code>box-sizing: content-box</code> ：标准盒模型（默认值）。</p></li><li><p><code>box-sizing: border-box</code> ：IE（替代）盒模型。</p><p>2.2 css 选择器和优先级<br>首先我们要知道有哪些选择器：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors%23%25E9%2580%2589%25E6%258B%25A9%25E5%2599%25A8%25E5%258F%2582%25E8%2580%2583%25E8%25A1%25A8">选择器参考表</a>。<br>常规来说，大家都知道样式的优先级一般为 <code>!important &gt; style &gt; id &gt; class</code> ，但是涉及多类选择器作用于同一个元素时候怎么判断优先级呢？相信我，你在改一些第三方库（比如 <a href="https://www.zhihu.com/search?q=antd&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2430900871%7D">antd</a> ）样式时，理解这个会帮助很大！<br>这篇文章写的非常清晰易懂，强烈推荐，看完之后就没啥问题了：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903709772611592">深入理解 CSS 选择器优先级</a>。<br>上述文章中核心内容： 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p></li><li><p>如果存在内联样式，那么 <code>A = 1</code>，否则 <code>A = 0</code> ；</p></li><li><p>B 的值等于 <code>ID选择器（#id）</code> 出现的次数；</p></li><li><p>C 的值等于 <code>类选择器（.class）</code> 和 <code>属性选择器（a[href=&quot;https://example.org&quot;]）</code> 和 <code>伪类（:first-child）</code> 出现的总次数；</p></li><li><p>D 的值等于 <code>标签选择器（h1,a,div）</code> 和 <code>伪元素（::before,::after）</code> 出现的总次数。<br>从左至右比较，如果是样式优先级相等，取后面出现的样式。<br>2.3 重排（reflow）和重绘（repaint）的理解<br>简单地总结下两者的概念：</p></li><li><p>重排：无论通过什么方式影响了元素的<strong>几何信息</strong>(元素在视口内的位置和尺寸大小)，浏览器需要<strong>重新计算</strong>元素在视口内的几何属性，这个过程叫做重排。</p></li><li><p>重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的<strong>实际像素</strong>，这个阶段就叫做重绘。</p></li></ul><p>如何减少重排和重绘？</p><ul><li><strong>最小化重绘和重排</strong>，比如样式集中改变，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</li><li><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</li><li><strong>使用 <code>\**absolute\**</code> 或 <code>\**fixed\**</code> 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</li><li><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</li></ul><p>这里推荐<strong>腾讯 IVWEB 团队</strong>的这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a>，好好认真看完，面试应该没问题的。</p><p>2.4 对 BFC 的理解<br>BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到<strong>尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸</strong>等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做<strong>视觉格式化模型</strong>的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，<strong>用于决定块级盒的布局及浮动相互影响范围的一个区域</strong>。<br>BFC 具有一些特性：</p><ol><li>块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。</li><li>在 BFC 中上下相邻的两个容器的 <code>margin</code> 会重叠，创建新的 BFC 可以避免外边距重叠。</li><li>计算 BFC 的高度时，需要计算浮动元素的高度。</li><li>BFC 区域不会与浮动的容器发生重叠。</li><li>BFC 是独立的容器，容器内部元素不会影响外部元素。</li><li>每个元素的左 <code>margin</code> 值和容器的左 <code>border</code> 相接触。</li></ol><p>利用这些特性，我们可以解决以下问题：</p><ul><li>利用 <code>4</code> 和 <code>6</code> ，我们可以实现三栏（或两栏）自适应布局。</li><li>利用 <code>2</code> ，我们可以避免 <code>margin</code> 重叠问题。</li><li>利用 <code>3</code> ，我们可以避免高度塌陷。</li></ul><p>创建 BFC 的方式：</p><ul><li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li><li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li><li><code>overflow</code> 的值不为 <code>visible</code> 。</li></ul><p>推荐文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6960866014384881671">可能是最好的 BFC 解析了…</a></p><p>2.5 实现两栏布局（左侧固定 + 右侧自适应布局）<br>现在有以下 DOM 结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt; &lt;/div&gt; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   height: 100px; &#125; .left &#123;   float: left;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   margin-left: 200px;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   height: 100px; &#125; .left &#123;   float: left;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   overflow: auto;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   display: flex;   height: 100px; &#125; .left &#123;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   flex: 1;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code> 定位，宽度固定。右边元素的 <code>margin-left</code> 的值设为左边元素的宽度值。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   position: relative;   height: 100px; &#125; .left &#123;   position: absolute;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   margin-left: 200px;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code> 定位， <code>left</code> 为宽度大小，其余方向定位为 <code>0</code> 。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   position: relative;   height: 100px; &#125; .left &#123;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   position: absolute;   left: 200px;   top: 0;   right: 0;   bottom: 0;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br></pre></td></tr></table></figure><p>2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）<br>圣杯布局和双飞翼布局的目的：</p><ul><li>三栏布局，中间一栏最先加载和渲染（<strong>内容最重要，这就是为什么还需要了解这种布局的原因</strong>）。</li><li>两侧内容固定，中间内容随着宽度自适应。</li><li>一般用于 PC 网页。</li></ul><p>圣杯布局和双飞翼布局的技术总结：</p><ul><li>使用 <code>float</code> 布局。</li><li>两侧使用 <code>margin</code> 负值，以便和中间内容横向重叠。</li><li>防止中间内容被两侧覆盖，圣杯布局用 <code>padding</code> ，双飞翼布局用 <code>margin</code> 。</li></ul><p><strong>圣杯布局：</strong> HTML 结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt; &lt;p class=&quot;center&quot;&gt;我是中间&lt;/p&gt; &lt;p class=&quot;left&quot;&gt;我是左边&lt;/p&gt; &lt;p class=&quot;right&quot;&gt;我是右边&lt;/p&gt; &lt;/div&gt; 复制代码</span><br><span class="line">CSS 样式：</span><br><span class="line">#container &#123;   padding-left: 200px;   padding-right: 150px;   overflow: auto; &#125; #container p &#123;   float: left; &#125; .center &#123;   width: 100%;   background-color: lightcoral; &#125; .left &#123;   width: 200px;   position: relative;   left: -200px;   margin-left: -100%;   background-color: lightcyan; &#125; .right &#123;   width: 150px;   margin-right: -150px;   background-color: lightgreen; &#125; .clearfix:after &#123;   content: &quot;&quot;;   display: table;   clear: both; &#125; 复制代码</span><br></pre></td></tr></table></figure><p><strong>双飞翼布局：</strong> HTML 结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;main&quot; class=&quot;float&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;float&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;float&quot;&gt;right&lt;/div&gt; 复制代码</span><br><span class="line">CSS 样式：</span><br><span class="line">.float &#123;   float: left; &#125; #main &#123;   width: 100%;   height: 200px;   background-color: lightpink; &#125; #main-wrap &#123;   margin: 0 190px 0 190px; &#125; #left &#123;   width: 190px;   height: 200px;   background-color: lightsalmon;   margin-left: -100%; &#125; #right &#123;   width: 190px;   height: 200px;   background-color: lightskyblue;   margin-left: -190px; &#125; 复制代码</span><br></pre></td></tr></table></figure><p>tips：上述代码中 <code>margin-left: -100%</code> 相对的是父元素的 <code>content</code> 宽度，即不包含 <code>paddig</code> 、 <code>border</code> 的宽度。</p><p>其实以上问题需要掌握 <strong>margin 负值问题</strong> 即可很好理解。<br>2.7 水平垂直居中多种实现方式</p><ol><li>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code> 来调整子元素的中心点到父元素的中心。该方法可以<strong>不定宽高</strong>。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;   position: relative; &#125; .son &#123;   position: absolute;   left: 50%;   top: 50%;   transform: translate(-50%, -50%); &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用绝对定位，子元素所有方向都为 <code>0</code> ，将 <code>margin</code> 设置为 <code>auto</code> ，由于宽高固定，对应方向实现平分，该方法必须<strong>盒子有宽高</strong>。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;   position: relative; &#125; .son &#123;   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0px;   margin: auto;   height: 100px;   width: 100px; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code> 和 <code>margin-top</code> 以子元素自己的一半宽高进行负值赋值。该方法<strong>必须定宽高</strong>。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;   position: relative; &#125; .son &#123;   position: absolute;   left: 50%;   top: 50%;   width: 200px;   height: 200px;   margin-left: -100px;   margin-top: -100px; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>利用 <code>flex</code> ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。</li></ol><p>.father { display: flex; justify-content: center; align-items: center; } 复制代码<br>其实还有很多方法，比如 <code>display: grid</code> 或 <code>display: table-cell</code> 来做，有兴趣点击下面这篇文章可以了解下：</p><p><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903982960214029">面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高）</a>。</p><p>2.8 flex 布局</p><p>这一块内容看 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a> 就够了。<br>这里有个小问题，很多时候我们会用到 <code>flex: 1</code> ，它具体包含了以下的意思：</p><ul><li><p><code>flex-grow: 1</code> ：该属性默认为 <code>0</code> ，如果存在剩余空间，元素也不放大。设置为 <code>1</code> 代表会放大。</p></li><li><p><code>flex-shrink: 1</code> ：该属性默认为 <code>1</code> ，如果空间不足，元素缩小。</p></li><li><p><code>flex-basis: 0%</code> ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来<strong>计算是否有多余空间</strong>的。默认值为 <code>auto</code> ，即项目本身大小。设置为 <code>0%</code> 之后，因为有 <code>flex-grow</code> 和 <code>flex-shrink</code> 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 <code>flex-basis</code> 设为 <code>auto</code> 的话，其本身大小将会是 <code>0</code> 。</p><p>2.9 line-height 如何继承？</p></li><li><p>父元素的 <code>line-height</code> 写了<strong>具体数值</strong>，比如 <code>30px</code>，则子元素 <code>line-height</code> 继承该值。</p></li><li><p>父元素的 <code>line-height</code> 写了<strong>比例</strong>，比如 <code>1.5 或 2</code>，则子元素 <code>line-height</code> 也是继承该比例。</p></li><li><p>父元素的 <code>line-height</code> 写了<strong>百分比</strong>，比如 <code>200%</code>，则子元素 <code>line-height</code> 继承的是父元素 <code>font-size * 200%</code> 计算出来的值。</p></li></ul><h1 id="js-基础"><a href="#js-基础" class="headerlink" title="js 基础"></a>js 基础</h1><p>js 的考察其实来回就那些东西，不过就我自己而已学习的时候理解是真的理解了，但是忘也确实会忘（大家都说理解了一定不会忘，但是要答全的话还是需要理解+背）。<br>1、数据类型<br>以下是比较重要的几个 js 变量要掌握的点。<br>1.1 基本的数据类型介绍，及值类型和引用类型的理解<br>在 JS 中共有 <code>8</code> 种基础的数据类型，分别为： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Object</code> 、 <code>Symbol</code> 、 <code>BigInt</code> 。<br>其中 <code>Symbol</code> 和 <code>BigInt</code> 是 ES6 新增的数据类型，可能会被单独问：</p><ul><li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li><li>BigInt 可以表示任意大小的整数。</li></ul><p><strong>值类型的赋值变动过程如下：</strong><br>let a &#x3D; 100; let b &#x3D; a; a &#x3D; 200; console.log(b); &#x2F;&#x2F; 100 复制代码</p><p><img src="/lcz/./assets/img/interview/3.png" alt="img"></p><p>值类型是直接存储在<strong>栈（stack）</strong>中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br><strong>引用类型的赋值变动过程如下：</strong><br>let a &#x3D; { age: 20 }; let b &#x3D; a; b.age &#x3D; 30; console.log(a.age); &#x2F;&#x2F; 30 复制代码</p><p><img src="/lcz/./assets/img/interview/4.png" alt="img"></p><p>引用类型存储在<strong>堆（heap）</strong>中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；<br>1.2 数据类型的判断</p><ul><li><strong>typeof</strong>：能判断所有<strong>值类型，函数</strong>。不可对 <strong>null、对象、数组</strong>进行精确判断，因为都返回 <code>object</code> 。</li></ul><p>console.log(typeof undefined); &#x2F;&#x2F; undefined console.log(typeof 2); &#x2F;&#x2F; number console.log(typeof true); &#x2F;&#x2F; boolean console.log(typeof “str”); &#x2F;&#x2F; string console.log(typeof Symbol(“foo”)); &#x2F;&#x2F; symbol console.log(typeof 2172141653n); &#x2F;&#x2F; bigint console.log(typeof function () {}); &#x2F;&#x2F; function &#x2F;&#x2F; 不能判别 console.log(typeof []); &#x2F;&#x2F; object console.log(typeof {}); &#x2F;&#x2F; object console.log(typeof null); &#x2F;&#x2F; object 复制代码</p><ul><li><strong>instanceof</strong>：能判断<strong>对象</strong>类型，不能判断基本数据类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。比如考虑以下代码：</li></ul><p>class People {} class Student extends People {} const vortesnail &#x3D; new Student(); console.log(vortesnail instanceof People); &#x2F;&#x2F; true console.log(vortesnail instanceof Student); &#x2F;&#x2F; true 复制代码<br>其实现就是顺着<strong>原型链</strong>去找，如果能找到对应的 <code>Xxxxx.prototype</code> 即为 <code>true</code> 。比如这里的 <code>vortesnail</code> 作为实例，顺着原型链能找到 <code>Student.prototype</code> 及 <code>People.prototype</code> ，所以都为 <code>true</code> 。</p><ul><li>**Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 <strong>Error 对象，Date 对象</strong>等。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2); // &quot;[object Number]&quot; Object.prototype.toString.call(&quot;&quot;); // &quot;[object String]&quot; Object.prototype.toString.call(true); // &quot;[object Boolean]&quot; Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot; Object.prototype.toString.call(null); // &quot;[object Null]&quot; Object.prototype.toString.call(Math); // &quot;[object Math]&quot; Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot; Object.prototype.toString.call([]); // &quot;[object Array]&quot; Object.prototype.toString.call(function () &#123;&#125;); // &quot;[object Function]&quot; 复制代码</span><br></pre></td></tr></table></figure><p>在面试中有一个经常被问的问题就是：如何判断变量是否为数组？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(arr); // true arr.__proto__ === Array.prototype; // true arr instanceof Array; // true Object.prototype.toString.call(arr); // &quot;[object Array]&quot; 复制代码</span><br></pre></td></tr></table></figure><p>1.3 手写深拷贝</p><p>这个题一定要会啊！笔者面试过程中疯狂被问到！</p><p>文章推荐：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**  * 深拷贝  * @param &#123;Object&#125; obj 要拷贝的对象  * @param &#123;Map&#125; map 用于存储循环引用对象的地址  */ function deepClone(obj = &#123;&#125;, map = new Map()) &#123;   if (typeof obj !== &quot;object&quot;) &#123;     return obj;   &#125;   if (map.get(obj)) &#123;     return map.get(obj);   &#125;    let result = &#123;&#125;;   // 初始化返回结果 if (     obj instanceof Array ||     // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此 Object.prototype.toString(obj) === &quot;[object Array]&quot;   ) &#123;     result = [];   &#125;   // 防止循环引用   map.set(obj, result);   for (const key in obj) &#123;     // 保证 key 不是原型属性 if (obj.hasOwnProperty(key)) &#123;       // 递归调用       result[key] = deepClone(obj[key], map);     &#125;   &#125;    // 返回结果 return result; &#125; 复制代码</span><br></pre></td></tr></table></figure><p>1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？</p><p>建议先阅读这篇文章了解 IEEE 754 ：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6940405970954616839">硬核基础二进制篇（一）0.1 + 0.2 !&#x3D; 0.3 和 IEEE-754 标准</a>。 再阅读这篇文章了解如何运算：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903680362151950">0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？</a>。 ​<br>原因总结：</p><ul><li><code>进制转换</code> ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。</li><li><code>对阶运算</code> ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（<code>0舍1入</code>），尾数位移时可能会发生数丢失的情况，影响精度。</li></ul><p>解决办法：</p><ol><li>转为整数（大数）运算。</li></ol><p>function add(a, b) { const maxLen &#x3D; Math.max( a.toString().split(“.”)[1].length, b.toString().split(“.”)[1].length ); const base &#x3D; 10 ** maxLen; const bigA &#x3D; BigInt(base _ a); const bigB &#x3D; BigInt(base _ b); const bigRes &#x3D; (bigA + bigB) &#x2F; BigInt(base); &#x2F;&#x2F; 如果是 (1n + 2n) &#x2F; 10n 是等于 0n 的。。。 return Number(bigRes); } 复制代码<br>这里代码是有问题的，因为最后计算 <code>bigRes</code> 的大数相除（即 <code>/</code>）是会把小数部分截掉的，所以我很疑惑为什么网络上很多文章都说可以通过**先转为整数运算再除回去，为了防止转为的整数超出 js 表示范围，还可以运用到 ES6 新增的大数类型，我真的很疑惑，希望有好心人能解答下。**</p><ol><li>使用 <code>Number.EPSILON</code> 误差范围。</li></ol><p>function isEqual(a, b) { return Math.abs(a - b) &lt; Number.EPSILON; } console.log(isEqual(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true 复制代码<br><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。 ​</p><ol><li>转成字符串，对字符串做加法运算。</li></ol><p>&#x2F;&#x2F; 字符串数字相加 var addStrings &#x3D; function (num1, num2) { let i &#x3D; num1.length - 1; let j &#x3D; num2.length - 1; const res &#x3D; []; let carry &#x3D; 0; while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) { const n1 &#x3D; i &gt;&#x3D; 0 ? Number(num1[i]) : 0; const n2 &#x3D; j &gt;&#x3D; 0 ? Number(num2[j]) : 0; const sum &#x3D; n1 + n2 + carry; res.unshift(sum % 10); carry &#x3D; Math.floor(sum &#x2F; 10); i–; j–; } if (carry) { res.unshift(carry); } return res.join(“”); }; function isEqual(a, b, sum) { const [intStr1, deciStr1] &#x3D; a.toString().split(“.”); const [intStr2, deciStr2] &#x3D; b.toString().split(“.”); const inteSum &#x3D; addStrings(intStr1, intStr2); &#x2F;&#x2F; 获取整数相加部分 const deciSum &#x3D; addStrings(deciStr1, deciStr2); &#x2F;&#x2F; 获取小数相加部分 return inteSum + “.” + deciSum &#x3D;&#x3D;&#x3D; String(sum); } console.log(isEqual(0.1, 0.2, 0.3)); &#x2F;&#x2F; true 复制代码<br>这是 leetcode 上一道原题：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a>。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。<br>2、 原型和原型链<br>可以说这部分每家面试官都会问了。。首先理解的话，其实一张图即可，一段代码即可。<br>function Foo() {} let f1 &#x3D; new Foo(); let f2 &#x3D; new Foo(); 复制代码<br>千万别畏惧下面这张图，特别有用，一定要搞懂，熟到提笔就能默画出来。</p><p><img src="/lcz/./assets/img/interview/5.png" alt="img"></p><p>总结：</p><ul><li>原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性，其实就是 <code>prototype</code> 对象。</li><li>原型链：由相互关联的原型组成的<strong>链状结构</strong>就是原型链。</li></ul><p>先说出总结的话，再举例子说明如何顺着原型链找到某个属性。<br>推荐的阅读：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/blog/issues/2">JavaScript 深入之从原型到原型链</a> 掌握基本概念，再阅读这篇文章<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903989088092174">轻松理解 JS 原型原型链</a>加深上图的印象。<br>3、 作用域与作用域链</p><ul><li>作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</li><li>作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）</li></ul><p><strong>需要注意的是，js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。</strong><br>推荐阅读：先阅读<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/3">JavaScript 深入之词法作用域和动态作用域</a>，再阅读<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903797135769614">深入理解 JavaScript 作用域和作用域链</a>。 ​<br>4、 执行上下文<br>这部分一定要按顺序连续读这几篇文章，必须多读几遍：</p><ul><li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a>；</li><li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a>；</li><li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a>；</li><li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/8">JavaScript 深入之执行上下文</a>。</li></ul><p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象（Variable object，VO）；</li><li>作用域链（Scope chain）；</li><li>this。（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a>）</li></ul><p>5、 闭包<br>根据 MDN 中文的定义，闭包的定义如下：<br>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。</p><p>也可以这样说：<br>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是<strong>函数参数</strong>也不是<strong>函数的局部变量</strong>的<strong>变量</strong>。 闭包 &#x3D; 函数 + 函数能够访问的自由变量。</p><p>在经过上一小节“执行上下文”的学习，再来阅读这篇文章：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/9">JavaScript 深入之闭包</a>，你会对闭包的实质有一定的了解。在回答时，我们这样答：<br>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。<br>闭包应用： 函数作为参数被传递：<br>function print(fn) { const a &#x3D; 200; fn(); } const a &#x3D; 100; function fn() { console.log(a); } print(fn); &#x2F;&#x2F; 100 复制代码<br>函数作为返回值被返回：<br>function create() { const a &#x3D; 100; return function () { console.log(a); }; } const fn &#x3D; create(); const a &#x3D; 200; fn(); &#x2F;&#x2F; 100 复制代码<br><strong>闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。</strong> <strong>​</strong><br>应用实例：比如缓存工具，隐藏数据，只提供 API 。<br>function createCache() { const data &#x3D; {}; &#x2F;&#x2F; 闭包中被隐藏的数据，不被外界访问 return { set: function (key, val) { data[key] &#x3D; val; }, get: function (key) { return data[key]; }, }; } const c &#x3D; createCache(); c.set(“a”, 100); console.log(c.get(“a”)); &#x2F;&#x2F; 100 复制代码<br>6、 call、apply、bind 实现<br>这部分实现还是要知道的，就算工作中不会自己手写，但是说不准面试官就是要问，知道点原理也好，可以扩宽我们写代码的思路。<br><strong>call</strong><br>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p><p>举个例子：<br>var obj &#x3D; { value: “vortesnail”, }; function fn() { console.log(this.value); } fn.call(obj); &#x2F;&#x2F; vortesnail 复制代码<br>通过 <code>call</code> 方法我们做到了以下两点：</p><ul><li><code>call</code> 改变了 this 的指向，指向到 <code>obj</code> 。</li><li><code>fn</code> 函数执行了。</li></ul><p>那么如果我们自己写 <code>call</code> 方法的话，可以怎么做呢？我们先考虑改造 <code>obj</code> 。<br>var obj &#x3D; { value: “vortesnail”, fn: function () { console.log(this.value); }, }; obj.fn(); &#x2F;&#x2F; vortesnail 复制代码<br>这时候 this 就指向了 <code>obj</code> ，但是这样做我们手动给 <code>obj</code> 增加了一个 <code>fn</code> 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？<br>obj.fn &#x3D; fn; obj.fn(); delete obj.fn; 复制代码<br>根据这个思路，我们就可以写出来了：<br>Function.prototype.myCall &#x3D; function (context) { &#x2F;&#x2F; 判断调用对象 if (typeof this !&#x3D;&#x3D; “function”) { throw new Error(“Type error”); } &#x2F;&#x2F; 首先获取参数 let args &#x3D; […arguments].slice(1); let result &#x3D; null; &#x2F;&#x2F; 判断 context 是否传入，如果没有传就设置为 window context &#x3D; context || window; &#x2F;&#x2F; 将被调用的方法设置为 context 的属性 &#x2F;&#x2F; this 即为我们要调用的方法 context.fn &#x3D; this; &#x2F;&#x2F; 执行要被调用的方法 result &#x3D; context.fn(…args); &#x2F;&#x2F; 删除手动增加的属性方法 delete context.fn; &#x2F;&#x2F; 将执行结果返回 return result; }; 复制代码<br><strong>apply</strong><br>我们会了 <code>call</code> 的实现之后，<code>apply</code> 就变得很简单了，他们没有任何区别，除了传参方式。<br>Function.prototype.myApply &#x3D; function (context) { if (typeof this !&#x3D;&#x3D; “function”) { throw new Error(“Type error”); } let result &#x3D; null; context &#x3D; context || window; &#x2F;&#x2F; 与上面代码相比，我们使用 Symbol 来保证属性唯一 &#x2F;&#x2F; 也就是保证不会重写用户自己原来定义在 context 中的同名属性 const fnSymbol &#x3D; Symbol(); context[fnSymbol] &#x3D; this; &#x2F;&#x2F; 执行要被调用的方法 if (arguments[1]) { result &#x3D; context<a href="...arguments%5B1%5D">fnSymbol</a>; } else { result &#x3D; context<a href="">fnSymbol</a>; } delete context[fnSymbol]; return result; }; 复制代码<br><strong>bind</strong><br><code>bind</code> 返回的是一个函数，这个地方可以详细阅读这篇文章，讲的非常清楚：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/sisterAn/JavaScript-Algorithms/issues/81">解析 bind 原理，并手写 bind 实现</a>。<br>Function.prototype.myBind &#x3D; function (context) { &#x2F;&#x2F; 判断调用对象是否为函数 if (typeof this !&#x3D;&#x3D; “function”) { throw new Error(“Type error”); } &#x2F;&#x2F; 获取参数 const args &#x3D; […arguments].slice(1), const fn &#x3D; this; return function Fn() { return fn.apply( this instanceof Fn ? this : context, &#x2F;&#x2F; 当前的这个 arguments 是指 Fn 的参数 args.concat(…arguments) ); }; }; 复制代码<br>7、 new 实现</p><ol><li>首先创一个新的空对象。</li><li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li><li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li><li>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</li></ol><p>function myNew(context) { const obj &#x3D; new Object(); obj.<strong>proto</strong> &#x3D; context.prototype; const res &#x3D; context.apply(obj, […arguments].slice(1)); return typeof res &#x3D;&#x3D;&#x3D; “object” ? res : obj; } 复制代码<br>8、 异步<br>这部分着重要理解 Promise、async awiat、event loop 等。<br>8.1 event loop、宏任务和微任务<br>首先推荐一个可以在线看代码流程的网站：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D">loupe</a>。 然后看下这个视频学习下：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1">到底什么是 Event Loop 呢？</a><br>简单的例子：<br>console.log(“Hi”); setTimeout(function cb() { console.log(“cb”); &#x2F;&#x2F; cb 即 callback }, 5000); console.log(“Bye”); 复制代码<br>它的执行过程是这样的：</p><p><img src="/lcz/./assets/img/interview/6.png" alt="img"></p><p>Web APIs 会创建对应的线程，比如 <code>setTimeout</code> 会创建定时器线程，<code>ajax</code> 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。<br>看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到<strong>宏任务</strong>和<strong>微任务</strong>，我们还得拜读一下这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a>。如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6969028296893792286%23comment">做一些动图，学习一下 EventLoop</a>。想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904165462769678">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p><p><strong>注意：1.Call Stack 调用栈空闲 -&gt; 2.尝试 DOM 渲染 -&gt; 触发 Event loop</strong>。</p><ul><li>每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。</li><li>都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。</li><li>然后再去触发下一次 Event loop。</li></ul><p>宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async&#x2F;await。<br>两者区别：</p><ul><li>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</li><li>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</li></ul><p><strong>从 event loop 解释，为何微任务执行更早？</strong></p><ul><li><p>微任务是 ES6 语法规定的（被压入 micro task queue）。</p></li><li><p>宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。</p></li><li><p>宏任务执行时间一般比较长。</p></li><li><p>每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。</p><p>8.2 Promise</p></li></ul><p>关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。<br>关于 Promise 的所有使用方式，可参照这篇文章：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/promise">ECMAScript 6 入门 - Promise 对象</a>。 手写 Promise 源码的解析文章，可阅读此篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6945319439772434469%23heading-0">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a>。 关于 Promise 的面试题，可参考这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904077537574919">要就来 45 道 Promise 面试题一次爽到底</a>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现一个 Promise.all：</span><br><span class="line">Promise.all = function (promises) &#123;   return new Promise((resolve, reject) =&gt; &#123;     // 参数可以不是数组，但必须具有 Iterator 接口 if (typeof promises[Symbol.iterator] !== &quot;function&quot;) &#123;       reject(&quot;Type error&quot;);     &#125;     if (promises.length === 0) &#123;       resolve([]);     &#125; else &#123;       const res = [];       let count = 0;       const len = promises.length;       for (let i = 0; i &lt; len; i++) &#123;         //考虑到 promises[i] 可能是 thenable 对象也可能是普通值 Promise.resolve(promises[i])           .then((data) =&gt; &#123;             res[i] = data;             if (++count === len) &#123;               resolve(res);             &#125;           &#125;)           .catch((err) =&gt; &#123;             reject(err);           &#125;);       &#125;     &#125;   &#125;); &#125;; 复制代码</span><br></pre></td></tr></table></figure><p>8.3 async&#x2F;await 和 Promise 的关系</p><ul><li>async&#x2F;await 是消灭异步回调的终极武器。</li><li>但和 Promise 并不互斥，反而，两者相辅相成。</li><li>执行 async 函数，返回的一定是 Promise 对象。</li><li>await 相当于 Promise 的 then。</li><li>tru…catch 可捕获异常，代替了 Promise 的 catch。</li></ul><p>9、 浏览器的垃圾回收机制<br>这里看这篇文章即可：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6981588276356317214">「硬核 JS」你真的了解垃圾回收机制吗</a>。<br>总结一下：<br>有两种垃圾回收策略：</p><ul><li><strong>标记清除</strong>：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li><li><strong>引用计数</strong>：它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong>。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li></ul><p>标记清除的缺点：</p><ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li><li><strong>分配速度慢</strong>，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li></ul><p>解决以上的缺点可以使用 **标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p><p><img src="/lcz/./assets/img/interview/7.png" alt="img"></p><p>引用计数的缺点：</p><ul><li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li><li>解决不了循环引用导致的无法回收问题。</li></ul><p>V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。</p><ul><li>针对新生区采用并行回收。</li><li>针对老生区采用增量标记与惰性回收。</li></ul><p>10、 实现一个 EventMitter 类<br>EventMitter 就是发布订阅模式的典型应用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export class EventEmitter &#123;   private _events: Record&lt;string, Array&lt;Function&gt;&gt;;    constructor() &#123;     this._events = Object.create(null);   &#125;    emit(evt: string, ...args: any[]) &#123;     if (!this._events[evt]) return false;      const fns = [...this._events[evt]];     fns.forEach((fn) =&gt; &#123;       fn.apply(this, args);     &#125;);      return true;   &#125;    on(evt: string, fn: Function) &#123;     if (typeof fn !== &quot;function&quot;) &#123;       throw new TypeError(&quot;The evet-triggered callback must be a function&quot;);     &#125;     if (!this._events[evt]) &#123;       this._events[evt] = [fn];     &#125; else &#123;       this._events[evt].push(fn);     &#125;   &#125;    once(evt: string, fn: Function) &#123;     const execFn = () =&gt; &#123;       fn.apply(this);       this.off(evt, execFn);     &#125;;     this.on(evt, execFn);   &#125;    off(evt: string, fn?: Function) &#123;     if (!this._events[evt]) return;     if (!fn) &#123;       this._events[evt] &amp;&amp; (this._events[evt].length = 0);     &#125;      let cb;     const cbLen = this._events[evt].length;     for (let i = 0; i &lt; cbLen; i++) &#123;       cb = this._events[evt][i];       if (cb === fn) &#123;         this._events[evt].splice(i, 1);         break;       &#125;     &#125;   &#125;    removeAllListeners(evt?: string) &#123;     if (evt) &#123;       this._events[evt] &amp;&amp; (this._events[evt].length = 0);     &#125; else &#123;       this._events = Object.create(null);     &#125;   &#125; &#125; 复制代码</span><br></pre></td></tr></table></figure><h1 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h1><p>要掌握 cookie，localStorage 和 sessionStorage。<br>1、cookie</p><ul><li>本身用于浏览器和 server 通讯。</li><li>被“借用”到本地存储来的。</li><li>可用 document.cookie &#x3D; ‘…’ 来修改。</li></ul><p>其缺点：</p><ul><li>存储大小限制为 4KB。</li><li>http 请求时需要发送到服务端，增加请求数量。</li><li>只能用 document.cookie &#x3D; ‘…’ 来修改，太过简陋。</li></ul><p>2、localStorage 和 sessionStorage</p><ul><li>HTML5 专门为存储来设计的，最大可存 5M。</li><li>API 简单易用， setItem getItem。</li><li>不会随着 http 请求被发送到服务端。</li></ul><p>它们的区别：</p><ul><li>localStorage 数据会永久存储，除非代码删除或手动删除。</li><li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空。</li><li>一般用 localStorage 会多一些。</li></ul><h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><p>前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。<br>1、http 状态码<br>1.1 状态码分类</p><ul><li><p>1xx - 服务器收到请求。</p></li><li><p>2xx - 请求成功，如 200。</p></li><li><p>3xx - 重定向，如 302。</p></li><li><p>4xx - 客户端错误，如 404。</p></li><li><p>5xx - 服务端错误，如 500。</p><p>1.2 常见状态码</p></li><li><p>200 - 成功。</p></li><li><p>301 - 永久重定向（配合 location，浏览器自动处理）。</p></li><li><p>302 - 临时重定向（配合 location，浏览器自动处理）。</p></li><li><p>304 - 资源未被修改。</p></li><li><p>403 - 没权限。</p></li><li><p>404 - 资源未找到。</p></li><li><p>500 - 服务器错误。</p></li><li><p>504 - 网关超时。</p><p>1.3 关于协议和规范</p></li><li><p>状态码都是约定出来的。</p></li><li><p>要求大家都跟着执行。</p></li><li><p>不要违反规范，例如 IE 浏览器。</p></li></ul><p>2、http 缓存</p><ul><li><p>关于缓存的介绍。</p></li><li><p>http 缓存策略（强制缓存 + 协商缓存）。</p></li><li><p>刷新操作方式，对缓存的影响。</p><p>4.1 关于缓存<br>什么是缓存？ 把一些不需要重新获取的内容再重新获取一次<br>为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。<br>哪些资源可以被缓存？ 静态资源，比如 js css img。<br>4.2 强制缓存</p></li></ul><p><img src="/lcz/./assets/img/interview/8.png" alt="img"></p><p>Cache-Control：</p><ul><li>在 Response Headers 中。</li><li>控制强制缓存的逻辑。</li><li>例如 Cache-Control: max-age&#x3D;3153600（单位是秒）</li></ul><p>Cache-Control 有哪些值：</p><ul><li><p>max-age：缓存最大过期时间。</p></li><li><p>no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。</p></li><li><p>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。</p><p>4.3 协商缓存（对比缓存）</p></li><li><p>服务端缓存策略。</p></li><li><p>服务端判断客户端资源，是否和服务端资源一样。</p></li><li><p>一致则返回 304，否则返回 200 和最新的资源。</p></li></ul><p><img src="/lcz/./assets/img/interview/9.png" alt="img"></p><p>资源标识：</p><ul><li>在 Response Headers 中，有两种。</li><li>Last-Modified：资源的最后修改时间。</li><li>Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。</li></ul><p><strong>Last-Modified：</strong></p><p><img src="/lcz/./assets/img/interview/10.png" alt="img"></p><p>服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。<br><strong>Etag：</strong></p><p><img src="/lcz/./assets/img/interview/11.png" alt="img"></p><p>其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。<br><strong>两者比较：</strong></p><ul><li><p>优先使用 Etag。</p></li><li><p>Last-Modified 只能精确到秒级。</p></li><li><p>如果资源被重复生成，而内容不变，则 Etag 更精确。</p><p>4.4 综述</p></li></ul><p><img src="/lcz/./assets/img/interview/12.png" alt="img"></p><p>4.4 三种刷新操作对 http 缓存的影响</p><ul><li>正常操作：地址栏输入 url，跳转链接，前进后退等。</li><li>手动刷新：f5，点击刷新按钮，右键菜单刷新。</li><li>强制刷新：ctrl + f5，shift+command+r。</li></ul><p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong> ****</p><ol start="3"><li>面试</li></ol><p><strong>对于更多面试中可能出现的问题，我还是建议精读这篇三元的文章：</strong><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904100035821575">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a>。<br>比如会被经常问到的： GET 和 POST 的区别。</p><ul><li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li><li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li><li>从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul><p>HTTP&#x2F;2 有哪些改进？（很大可能问原理）</p><ul><li>头部压缩。</li><li>多路复用。</li><li>服务器推送。</li></ul><p>关于 HTTPS 的一些原理，可以阅读这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904038509576199">这一次，彻底理解 https 原理</a>。接着你可以观看这个视频进行更进一步的学习：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1XL411b7KZ?p=1">HTTPS 底层原理，面试官直接下跪，唱征服！</a><br>关于<strong>跨域</strong>问题，大部分文章都是理论性比较强，还不如读这篇文章，<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/149734572?from_voters_page=true">聊聊跨域的原理与解决方法</a>，讲的非常清晰，我个人觉得对付面试就是先知道使用流程，把这个流程能自己说出来，然后再讲下原理即可。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>1、 React 事件机制，React 16 和 React 17 事件机制的不同<br>阅读这篇文章即可：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6955636911214067720">一文吃透 react 事件系统原理</a>。<br>为什么要自定义事件机制？</p><ul><li>抹平浏览器差异，实现更好的跨平台。</li><li>避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。</li><li>方便事件统一管理和事务机制。</li></ul><p>2、class component<br>不排除现在还会有面试官问关于 class component 的问题。<br>2.1 生命周期</p><ul><li>初始化阶段。</li></ul><p>发生在 <code>constructor</code> 中的内容，在 <code>constructor</code> 中进行 <code>state</code> 、<code>props</code> 的初始化，在这个阶段修改 <code>state</code>，不会执行更新阶段的生命周期，可以直接对 <code>state</code> 赋值。</p><ul><li><p>挂载阶段。</p></li><li><p>componentWillMount 发生在 render 函数之前，还没有挂载 Dom 2. render 3. componentDidMount 发生在 render 函数之后，已经挂载 Dom 复制代码</p></li><li><p>更新阶段。</p></li></ul><p>更新阶段分为由 <code>state</code> 更新引起和 <code>props</code> 更新引起。<br>props 更新时： 1. componentWillReceiveProps(nextProps,nextState) 这个生命周期主要为我们提供对 props 发生改变的监听，如果你需要在 props 发生改变后，相应改变组件的一些 state。在这个方法中改变 state 不会二次渲染，而是直接合并 state。 2. shouldComponentUpdate(nextProps,nextState) 这个生命周期需要返回一个 Boolean 类型的值，判断是否需要更新渲染组件，优化 react 应用的主要手段之一，当返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。 3. componentWillUpdate(nextProps,nextState) 这个生命周期主要是给我们一个时机能够处理一些在 Dom 发生更新之前的事情，如获得 Dom 更新前某些元素的坐标、大小等，在这个阶段不可以 setState()，会导致循环调用。 <strong>一直到这里 this.props 和 this.state 都还未发生更新</strong> 4. render 5. componentDidUpdate(prevProps, prevState) 在此时已经完成渲染，Dom 已经发生变化，state 已经发生更新，prevProps、prevState 均为上一个状态的值。 state 更新时（具体同上） 1. shouldComponentUpdate 2. componentWillUpdate 3. render 4. componentDidUpdate 复制代码</p><ul><li>卸载阶段。</li><li>componentWillUnmount 在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount 中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。 复制代码</li></ul><p>在 React 16 中官方已经建议删除以下三个方法，非要使用必须加前缀：<code>UNSAVE_</code> 。<br>componentWillMount; componentWillReceiveProps; componentWillUpdate; 复制代码<br>取代这两三个生命周期的以下两个新的。</p><ol><li>static getDerivedStateFromProps(nextProps,nextState) 在组件实例化、接收到新的 props 、组件状态更新时会被调用 2. getSnapshotBeforeUpdate（prevProps,prevState） 在这个阶段我们可以拿到上一个状态 Dom 元素的坐标、大小的等相关信息。用于替代旧的生命周期中的 componentWillUpdate。 该函数的返回值将会作为 componentDidUpdate 的第三个参数出现。 复制代码</li></ol><p>需要注意的是，一般都会问为什么要废弃三个生命周期，原因是什么。<br>2.2 setState 同步还是异步<br><code>setState</code> 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。</p><ul><li>如果 <code>setState</code> 在 React 能够控制的范围被调用，它就是<strong>异步</strong>的。比如<strong>合成事件处理函数</strong>，<strong>生命周期函数</strong>， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。</li><li>如果 <code>setState</code> 在原生 JavaScript 控制的范围被调用，它就是<strong>同步</strong>的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 <code>setState</code> 被调用后会立即更新 DOM 。</li></ul><p>3、对函数式编程的理解<br>这篇文章写的真的太好了，一定要读：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903936378273799">简明 JavaScript 函数式编程——入门篇</a>。<br>总结一下： 函数式编程有两个核心概念。</p><ul><li><strong>数据不可变（无副作用）：</strong> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</li><li><strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</li></ul><p>纯函数带来的意义。</p><ul><li><strong>便于测试和优化</strong>：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。</li><li><strong>可缓存性</strong>：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。</li><li><strong>更少的 Bug</strong>：使用纯函数意味着你的函数中<strong>不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改</strong>，这些共享状态往往是绝大多数 bug 的源头。</li></ul><p>4、react hooks<br>现在应该大多数面试官会问 hooks 相关的啦。这里我强烈推荐三篇文章，即使没看过源码，也能比较好地理解一些原理：<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904127110053895">用动画和实战打开 React Hooks（一）：useState 和 useEffect</a><br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904132164190221">用动画和实战打开 React Hooks（二）：自定义 Hook 和 useCallback</a><br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904149746728973">用动画和实战打开 React Hooks（三）：useReducer 和 useContext</a><br>4.1 为什么不能在条件语句中写 hook<br>推荐这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6939766434159394830">我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁</a>。<br>hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。<br>4.2 HOC 和 hook 的区别<br>hoc 能复用<strong>逻辑和视图</strong>，hook 只能复用<strong>逻辑</strong>。<br>4.3 useEffect 和 useLayoutEffect 区别<br>对于 React 的函数组件来说，其更新过程大致分为以下步骤：</p><ol><li>因为某个事件 <code>state</code> 发生变化。</li><li>React 内部更新 <code>state</code> 变量。</li><li>React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。</li><li>将更新过后的 DOM 数据绘制到浏览器中。</li><li>用户看到新的页面。</li></ol><p><code>useEffect</code> 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 <code>useLayoutEffect</code> 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。<br>4.4 useEffect 依赖为空数组与 componentDidMount 区别<br>在 <code>render</code> 执行之后，<code>componentDidMount</code> 会执行，如果在这个生命周期中再一次 <code>setState</code> ，会导致再次 <code>render</code> ，返回了新的值，浏览器只会渲染第二次 <code>render</code> 返回的值，这样可以避免闪屏。<br>但是 <code>useEffect</code> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 <code>render</code> ，有可能会闪屏。<br>实际上 <code>useLayoutEffect</code> 会更接近 <code>componentDidMount</code> 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。<br>4.5 React.memo() 和 React.useMemo() 的区别</p><ul><li><p><code>memo</code> 是一个高阶组件，默认情况下会对 <code>props</code> 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。</p></li><li><p><code>useMemo</code> 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，<code>useMemo</code> 是在 <code>render</code> 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴。</p><p>4.6 React.useCallback() 和 React.useMemo() 的区别</p></li><li><p><code>useCallback</code> 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。</p></li><li><p><code>useMemo</code> 可缓存值。</p></li></ul><p>有很多时候，我们在 <code>useEffect</code> 中使用某个定义的外部函数，是要添加到 <code>deps</code> 数组中的，如果不用 <code>useCallback</code> 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 <code>useEffect</code> 总会无意义的执行。<br>4.7 React.forwardRef 是什么及其作用<br>这里还是阅读官方文档来的清晰：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/react-api.html%23reactforwardref">React.forwardRef</a>。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。<br>6、react hooks 与 class 组件对比<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904179136200712">react hooks 与 class 组件对比</a> <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同</a><br>7、介绍 React dom diff 算法<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903806132568072">让虚拟 DOM 和 DOM-diff 不再成为你的绊脚石</a>。<br>8、对 React Fiber 的理解<br>关于这块儿我觉得可以好好阅读下这篇无敌的博客了：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://pomb.us/build-your-own-react/">Build your own React</a>。 它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。<br>然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章： <a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903975112671239">这可能是最通俗的 React Fiber(时间分片) 打开方式</a><br>9、React 性能优化手段<br>推荐文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903924302888973">React 性能优化的 8 种方式了解一下？</a></p><ul><li>使用 <code>React.memo</code> 来缓存组件。</li><li>使用 <code>React.useMemo</code> 缓存大量的计算。</li><li>避免使用匿名函数。</li><li>利用 <code>React.lazy</code> 和 <code>React.Suspense</code> 延迟加载不是立即需要的组件。</li><li>尽量使用 CSS 而不是强制加载和卸载组件。</li><li>使用 <code>React.Fragment</code> 避免添加额外的 DOM。</li></ul><p>10、React Redux<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904021187117069">Redux 包教包会（一）：介绍 Redux 三大核心概念</a></p><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>原理初探：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6943468761575849992">当面试官问 Webpack 的时候他想知道什么</a><br>简易实现：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/Cosen95/blog/issues/48">面试官：webpack 原理都不会</a>，<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://segmentfault.com/a/1190000039231950">手写一个 webpack，看看 AST 怎么用</a><br>加料：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903520378814471">简单易懂的 webpack 打包后 JS 的运行过程</a>，<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6888936770692448270">Webpack 手写 loader 和 plugin</a><br>热更新原理：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a><br>面试题：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打 Webpack 面试题</a><br><strong>这里要注意，应该还会考 webpack5 和 4 有哪些区别。</strong></p><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a> （这里面没有讲 umd）<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903927104667662">可能是最详细的 UMD 模块入门指南</a></p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>代码层面：</p><ul><li>防抖和节流（resize，scroll，input）。</li><li>减少回流（重排）和重绘。</li><li>事件委托。</li><li>css 放 ，js 脚本放 最底部。</li><li>减少 DOM 操作。</li><li>按需加载，比如 React 中使用 <code>React.lazy</code> 和 <code>React.Suspense</code> ，通常需要与 webpack 中的 <code>splitChunks</code> 配合。</li></ul><p>构建方面：</p><ul><li><strong>压缩代码文件</strong>，在 webpack 中使用 <code>terser-webpack-plugin</code> 压缩 Javascript 代码；使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS 代码；使用 <code>html-webpack-plugin</code> 压缩 html 代码。</li><li><strong>开启 gzip 压缩</strong>，webpack 中使用 <code>compression-webpack-plugin</code> ，node 作为服务器也要开启，使用 <code>compression</code>。</li><li><strong>常用的第三方库使用 CDN 服务</strong>，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。</li></ul><p>其它：</p><ul><li>使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。</li><li>使用服务端渲染。</li><li>图片压缩。</li><li>使用 http 缓存，比如服务端的响应中添加 <code>Cache-Control / Expires</code> 。</li></ul><h1 id="常见手写"><a href="#常见手写" class="headerlink" title="常见手写"></a>常见手写</h1><p>以下的内容是上面没有提到的手写，比如 <code>new</code> 、<code>Promise.all</code> 这种上面内容中已经提到了如何写。<br>1、防抖<br><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/22">JavaScript 专题之跟着 underscore 学防抖 </a>​<br>function debounce(func, wait, immediate) { let timeout; return function () { let context &#x3D; this; let args &#x3D; arguments; if (timeout) clearTimeout(timeout); if (immediate) { let callNow &#x3D; !timeout; timeout &#x3D; setTimeout(function () { timeout &#x3D; null; }, wait); if (callNow) func.apply(context, args); } else { timeout &#x3D; setTimeout(function () { func.apply(context, args); }, wait); } }; } 复制代码<br>2、节流<br><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/26">JavaScript 专题之跟着 underscore 学节流</a><br>&#x2F;&#x2F; 使用时间戳 function throttle(func, wait) { let preTime &#x3D; 0; return function () { let nowTime &#x3D; +new Date(); let context &#x3D; this; let args &#x3D; arguments; if (nowTime - preTime &gt; wait) { func.apply(context, args); preTime &#x3D; nowTime; } }; } &#x2F;&#x2F; 定时器实现 function throttle(func, wait) { let timeout; return function () { let context &#x3D; this; let args &#x3D; arguments; if (!timeout) { timeout &#x3D; setTimeout(function () { timeout &#x3D; null; func.apply(context, args); }, wait); } }; } 复制代码<br>3、快速排序<br>这里对快排思想不太明白的同学可以看下这个讲解的很清晰的视频：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1at411T75o?from=search&seid=10065750342799523965&spm_id_from=333.337.0.0">快速排序算法</a>。<br>function sortArray(nums) { quickSort(0, nums.length - 1, nums); return nums; } function quickSort(start, end, arr) { if (start &lt; end) { const mid &#x3D; sort(start, end, arr); quickSort(start, mid - 1, arr); quickSort(mid + 1, end, arr); } } function sort(start, end, arr) { const base &#x3D; arr[start]; let left &#x3D; start; let right &#x3D; end; while (left !&#x3D;&#x3D; right) { while (arr[right] &gt;&#x3D; base &amp;&amp; right &gt; left) { right–; } arr[left] &#x3D; arr[right]; while (arr[left] &lt;&#x3D; base &amp;&amp; right &gt; left) { left++; } arr[right] &#x3D; arr[left]; } arr[left] &#x3D; base; return left; } 复制代码<br>4、instanceof<br>这个手写一定要懂原型及原型链。<br>function myInstanceof(target, origin) { if (typeof target !&#x3D;&#x3D; “object” || target &#x3D;&#x3D;&#x3D; null) return false; if (typeof origin !&#x3D;&#x3D; “function”) throw new TypeError(“origin must be function”); let proto &#x3D; Object.getPrototypeOf(target); &#x2F;&#x2F; 相当于 proto &#x3D; target.<strong>proto</strong>; while (proto) { if (proto &#x3D;&#x3D;&#x3D; origin.prototype) return true; proto &#x3D; Object.getPrototypeOf(proto); } return false; } 复制代码<br>5、数组扁平化<br>重点，不要觉得用不到就不管，这道题就是考察你对 js 语法的熟练程度以及手写代码的基本能力。<br>function flat(arr, depth &#x3D; 1) { if (depth &gt; 0) { &#x2F;&#x2F; 以下代码还可以简化，不过为了可读性，还是…. return arr.reduce((pre, cur) &#x3D;&gt; { return pre.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur); }, []); } return arr.slice(); } 复制代码<br>6、手写 reduce<br>先不考虑第二个参数初始值：<br>Array.prototype.reduce &#x3D; function (cb) { const arr &#x3D; this; &#x2F;&#x2F;this 就是调用 reduce 方法的数组 let total &#x3D; arr[0]; &#x2F;&#x2F; 默认为数组的第一项 for (let i &#x3D; 1; i &lt; arr.length; i++) { total &#x3D; cb(total, arr[i], i, arr); } return total; }; 复制代码<br>考虑上初始值：<br>Array.prototype.reduce &#x3D; function (cb, initialValue) { const arr &#x3D; this; let total &#x3D; initialValue || arr[0]; &#x2F;&#x2F; 有初始值的话从 0 遍历，否则从 1 遍历 for (let i &#x3D; initialValue ? 0 : 1; i &lt; arr.length; i++) { total &#x3D; cb(total, arr[i], i, arr); } return total; }; 复制代码<br>7、带并发的异步调度器 Scheduler<br>JS 实现一个带并发限制的异度调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。<br>class Scheduler { add(promiseMaker) {} } const timeout &#x3D; (time) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; { setTimeout(resolve, time); }); const scheduler &#x3D; new Scheduler(); const addTask &#x3D; (time, order) &#x3D;&gt; { scheduler.add(() &#x3D;&gt; timeout(time).then(() &#x3D;&gt; console.log(order))); }; addTask(1000, “1”); addTask(500, “2”); addTask(300, “3”); addTask(400, “4”); &#x2F;&#x2F; output：2 3 1 4 &#x2F;&#x2F; 一开始，1，2 两个任务进入队列。 &#x2F;&#x2F; 500ms 时，2 完成，输出 2，任务 3 入队。 &#x2F;&#x2F; 800ms 时，3 完成，输出 3，任务 4 入队。 &#x2F;&#x2F; 1000ms 时，1 完成，输出 1。 复制代码<br>根据题目，我们只需要操作 <code>Scheduler</code> 类就行：<br>class Scheduler { constructor() { this.waitTasks &#x3D; []; &#x2F;&#x2F; 待执行的任务队列 this.excutingTasks &#x3D; []; &#x2F;&#x2F; 正在执行的任务队列 this.maxExcutingNum &#x3D; 2; &#x2F;&#x2F; 允许同时运行的任务数量 } add(promiseMaker) { if (this.excutingTasks.length &lt; this.maxExcutingNum) { this.run(promiseMaker); } else { this.waitTasks.push(promiseMaker); } } run(promiseMaker) { const len &#x3D; this.excutingTasks.push(promiseMaker); const index &#x3D; len - 1; promiseMaker().then(() &#x3D;&gt; { this.excutingTasks.splice(index, 1); if (this.waitTasks.length &gt; 0) { this.run(this.waitTasks.shift()); } }); } } 复制代码<br>8、去重</p><ul><li>利用 ES6 <code>set</code> 关键字：</li></ul><p>function unique(arr) { return […new Set(arr)]; } 复制代码</p><ul><li>利用 ES5 <code>filter</code> 方法：</li></ul><p>function unique(arr) { return arr.filter((item, index, array) &#x3D;&gt; { return array.indexOf(item) &#x3D;&#x3D;&#x3D; index; }); } 复制代码</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol><li>requestAnimationFrame（<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6991297852462858277">一个神奇的前端动画 API requestAnimationFrame</a>）</li><li>如何排查内存泄漏问题，面试官可能会问为什么页面越来越卡顿，直至卡死，怎么定位到产生这种现象的源代码（开发环境）？（<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6947841638118998029">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a>）</li><li>vite 大火，我复习的时候是去年 9 月份，还没那么火，可能现在的你需要学一学了～</li><li>vue3 也一样，如果你是 React 技术栈（就像我之前一样）当我没说。</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>这部分大家可以点击以下这个仓库，按照仓库中的题目顺序进行刷题，都是我亲自刷过的，排了最适合的顺序：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/vortesnail/leetcode">vortesnail&#x2F;leetcode</a>。<br>然后如果大家想看下大厂的算法高频题可以看这个仓库：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/afatcoder/LeetcodeTop">afatcoder&#x2F;LeetcodeTop</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端面试题&lt;/p&gt;</summary>
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>VUE 自定义组件库搭建</title>
    <link href="http://example.com/2022/06/07/VUE-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2022/06/07/VUE-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/</id>
    <published>2022-06-07T10:07:50.000Z</published>
    <updated>2023-08-31T17:58:06.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据项目开发情况，子系统过多（三十多个系统），且各系统之间存在高重复性的开发内容，因此封装属于公司内部的组件库（开源npm库&#x2F;个人私库是一样的，只是组件库存放的地方不一样）是非常有必要的。</p><span id="more"></span><p>企业私库搭建：<a href="https://cz-liang.github.io/lcz/2022/06/07/Verdaccio-%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%A7%81%E5%BA%93/">Verdaccio-搭建企业私库</a></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create 项目名称</span><br></pre></td></tr></table></figure><h1 id="调整目录"><a href="#调整目录" class="headerlink" title="调整目录"></a>调整目录</h1><p>我们需要一个目录存放组件，一个目录存放示例，按照以下方式对目录进行改造</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|-- examples <span class="comment">// 原 src 目录，改成 examples 用作示例展示</span></span><br><span class="line">|-- packages <span class="comment">// 新增 packages 用于编写存放组件</span></span><br></pre></td></tr></table></figure><p>配置项目以支持新的目录结构<br>我们通过上一步的目录改造后，会遇到两个问题。<br>1、src 目录更名为 examples ，导致项目无法运行<br>2、新增 packages 目录，该目录未加入 webpack 编译<br>注：cli3 提供一个可选的 vue.config.js 配置文件。如果这个文件存在则他会被自动加载，所有的对项目和webpack的配置，都在这个文件中。</p><ul><li>重新配置入口，修改配置中的 pages 选项<br>新版 Vue CLI 支持使用 vue.config.js 中的 pages 选项构建一个多页面的应用。<br>这里使用 pages 修改入口到 examples<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 修改 src 为 examples</span></span><br><span class="line">  <span class="attr">pages</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: &#123;</span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&quot;examples/main.js&quot;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;public/index.html&quot;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 扩展 webpack 配置，使 packages 加入编译</span></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">module</span></span><br><span class="line">      .<span class="title function_">rule</span>(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .<span class="property">include</span></span><br><span class="line">        .<span class="title function_">add</span>(<span class="string">&#x27;/packages/&#x27;</span>)</span><br><span class="line">        .<span class="title function_">end</span>()</span><br><span class="line">      .<span class="title function_">use</span>(<span class="string">&#x27;babel&#x27;</span>)</span><br><span class="line">        .<span class="title function_">loader</span>(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">        .<span class="title function_">tap</span>(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 修改它的选项...</span></span><br><span class="line">          <span class="keyword">return</span> options</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h1><p>以分页组件（element-ui分页组件二次封装）为例：</p><h2 id="packages目录下新建pagination文件夹"><a href="#packages目录下新建pagination文件夹" class="headerlink" title="packages目录下新建pagination文件夹"></a>packages目录下新建pagination文件夹</h2><h2 id="pagination文件夹下新建index-vue文件，用于编写组件具体内容："><a href="#pagination文件夹下新建index-vue文件，用于编写组件具体内容：" class="headerlink" title="pagination文件夹下新建index.vue文件，用于编写组件具体内容："></a>pagination文件夹下新建index.vue文件，用于编写组件具体内容：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination-class&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">background</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:total</span>=<span class="string">&quot;pageTotal.total&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:page-sizes</span>=<span class="string">&quot;[5, 10, 15, 30, 50, 100]&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:current-page</span>=<span class="string">&quot;pageTotal.pageNum&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:page-size</span>=<span class="string">&quot;pageTotal.pageSize&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:layout</span>=<span class="string">&quot;pageTotal.layout&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">size-change</span>=<span class="string">&quot;handleSizeChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;pagination&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">pageTotal</span>: <span class="title class_">Object</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">requery</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 更换总条数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">handleSizeChange</span>(<span class="params">val</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;handleSizeChange&#x27;</span>, val)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 切换页数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">handleCurrentChange</span>(<span class="params">val</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;handleCurrentChange&#x27;</span>, val)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.pagination-class</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">margin-top</span>: <span class="number">16px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">text-align</span>: right;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.el-pagination</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">padding</span>: <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组件名要求驼峰命名（不用会报错），解决：<br>在vue.config.js文件下加配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  ***</span><br><span class="line">  <span class="attr">lintOnSave</span>: <span class="literal">false</span></span><br><span class="line">  ***</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="pagination文件夹下新建index-js文件，用于导出当前组件："><a href="#pagination文件夹下新建index-js文件，用于导出当前组件：" class="headerlink" title="pagination文件夹下新建index.js文件，用于导出当前组件："></a>pagination文件夹下新建index.js文件，用于导出当前组件：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> pagination <span class="keyword">from</span> <span class="string">&#x27;./index.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为组件提供 install 安装方法，供按需引入</span></span><br><span class="line">pagination.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(pagination.<span class="property">name</span>, pagination)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pagination</span><br></pre></td></tr></table></figure><h2 id="packages目录下新建index-js文件，整合所有的组件，对外导出，即一个完整的组件库："><a href="#packages目录下新建index-js文件，整合所有的组件，对外导出，即一个完整的组件库：" class="headerlink" title="packages目录下新建index.js文件，整合所有的组件，对外导出，即一个完整的组件库："></a>packages目录下新建index.js文件，整合所有的组件，对外导出，即一个完整的组件库：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入颜色选择器组件</span></span><br><span class="line"><span class="keyword">import</span> pagination <span class="keyword">from</span> <span class="string">&#x27;./pagination&#x27;</span></span><br><span class="line"><span class="comment">// import colorPicker from &#x27;./color-picker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  pagination,</span><br><span class="line"><span class="comment">//   colorPicker</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="keyword">function</span> (<span class="params">Vue</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否可以安装</span></span><br><span class="line">  <span class="keyword">if</span> (install.<span class="property">installed</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 遍历注册全局组件</span></span><br><span class="line">  components.<span class="title function_">map</span>(<span class="function"><span class="params">component</span> =&gt;</span> <span class="title class_">Vue</span>.<span class="title function_">component</span>(component.<span class="property">name</span>, component))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">Vue</span>) &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="variable language_">window</span>.<span class="property">Vue</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default install</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install,</span><br><span class="line">  pagination,</span><br><span class="line"><span class="comment">//   colorPicker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译库"><a href="#编译库" class="headerlink" title="编译库"></a>编译库</h1><p>修改package.json文件，scripts 中新增一条命令 npm run lib：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">    ***</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: <span class="string">&quot;vue-cli-service build --target lib --name dop-cpn --dest lib packages/index.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>–target</strong>：构建目标，默认为应用模式。这里修改为 lib 启用库模式。<br><strong>–dest</strong>： 输出目录，默认 dist。这里我们改成 lib<br><strong>entry</strong>: 最后一个参数为入口文件，默认为 src&#x2F;App.vue。这里我们指定编译 packages&#x2F; 组件库目录。</p><h2 id="执行编译库命令"><a href="#执行编译库命令" class="headerlink" title="执行编译库命令"></a>执行编译库命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run lib</span><br></pre></td></tr></table></figure><p>配置 package.json 文件中发布到 npm 的字段<br><strong>name</strong>: 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。<br><strong>version</strong>: 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。<br><strong>description</strong>: 描述。<br><strong>main</strong>: <font color="red">入口文件，该字段需指向我们最终编译后的包文件。注意路径是否正确，否则包引入包错误。</font><br><strong>keyword</strong>：关键字，以空格分离希望用户最终搜索的词。<br><strong>author</strong>：作者<br><strong>private</strong>：是否私有，需要修改为 false 才能发布到 npm<br><strong>license</strong>： 开源协议</p><p>参考配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;dop-cpn&quot;</span>,</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.3&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;基于 Vue 的颜色选择器&quot;</span>,</span><br><span class="line"><span class="string">&quot;main&quot;</span>: <span class="string">&quot;lib/dop-cpn.umd.min.js&quot;</span>, <span class="comment">// 注意路径是否正确，否则包引入包错误</span></span><br><span class="line"><span class="string">&quot;keyword&quot;</span>: <span class="string">&quot;color-picker&quot;</span>,</span><br><span class="line"><span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;private&quot;</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="发布组件到开源npm"><a href="#发布组件到开源npm" class="headerlink" title="发布组件到开源npm"></a>发布组件到开源npm</h1><p>如果配置了其他镜像，先设置回npm镜像：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm use npm</span><br></pre></td></tr></table></figure><h2 id="登录npm"><a href="#登录npm" class="headerlink" title="登录npm"></a>登录npm</h2><p>终端执行登录命令，输入用户名、密码、邮箱即可登录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><h2 id="发布到-npm"><a href="#发布到-npm" class="headerlink" title="发布到 npm"></a>发布到 npm</h2><p>执行发布命令，发布组件到 npm</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><ul><li>每次发布注意包名唯一，版本号不能和历史版本号相同</li></ul><h1 id="发布组件到企业私库"><a href="#发布组件到企业私库" class="headerlink" title="发布组件到企业私库"></a>发布组件到企业私库</h1><p>结合：<a href="https://cz-liang.github.io/lcz/2022/06/07/Verdaccio-%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%A7%81%E5%BA%93/">Verdaccio-搭建企业私库</a></p><p>如果配置了其他镜像，先设置回搭建的企业私库的镜像源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm use dop</span><br></pre></td></tr></table></figure><h2 id="直接发布私库上"><a href="#直接发布私库上" class="headerlink" title="直接发布私库上"></a>直接发布私库上</h2><p>执行发布命令，发布组件到 npm</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><ul><li>每次发布注意包名唯一，版本号不能和历史版本号相同</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dop-cpn</span><br></pre></td></tr></table></figure><ul><li>全局引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line"><span class="keyword">import</span> dop <span class="keyword">from</span> <span class="string">&#x27;dop-cpn&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(dop)</span><br><span class="line">***</span><br></pre></td></tr></table></figure><ul><li>按需引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dop <span class="keyword">from</span> <span class="string">&#x27;dop-cpn&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(dop.<span class="property">cpnName</span>) <span class="comment">// cpnName：具体的组件名称</span></span><br></pre></td></tr></table></figure><p>这里的dop名字随便起都可以</p><ul><li>在具体文件中直接使用组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pagination :pageTotal=&quot;pageTotal&quot;</span><br><span class="line">     @handleCurrentChange=&quot;handleCurrentChange&quot;</span><br><span class="line">     @handleSizeChange=&quot;handleSizeChange&quot;</span><br><span class="line">     style=&quot;text-align:right&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;根据项目开发情况，子系统过多（三十多个系统），且各系统之间存在高重复性的开发内容，因此封装属于公司内部的组件库（开源npm库&amp;#x2F;个人私库是一样的，只是组件库存放的地方不一样）是非常有必要的。&lt;/p&gt;</summary>
    
    
    
    <category term="npm" scheme="http://example.com/categories/npm/"/>
    
    
    <category term="npm" scheme="http://example.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Verdaccio 搭建企业私库</title>
    <link href="http://example.com/2022/06/07/Verdaccio-%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%A7%81%E5%BA%93/"/>
    <id>http://example.com/2022/06/07/Verdaccio-%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%A7%81%E5%BA%93/</id>
    <published>2022-06-07T07:13:18.000Z</published>
    <updated>2023-08-31T17:58:06.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>私有 npm 库，我想是每个团队都会实践和经历的一个阶段。实现私有 npm 的方式有很多种，例如基于私有 Git 仓库、基于 npm 官方提供的私有功能（付费）、Verdaccio 等等。但是，综合比较各种因素下来（不要钱、还好用），Verdaccio 都略胜前面两者。</p><span id="more"></span><!-- 文章适当文字截断 --><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Verdaccio 的安装启动过程较为简单。首先是全局安装 Verdaccio：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g verdaccio</span><br></pre></td></tr></table></figure><p>默认安装路径：C:\Users\EDY\AppData\Roaming\verdaccio</p><ul><li>启动<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verdaccio </span><br></pre></td></tr></table></figure>此时浏览器打开可访问： <a href="http://localhost:4873/">http://localhost:4873/</a><h1 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h1>config.yaml默认配置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage</span>: ./storage</span><br><span class="line"><span class="attr">plugins</span>: ./plugins</span><br><span class="line"><span class="attr">web</span>:</span><br><span class="line">  <span class="attr">title</span>: <span class="title class_">Verdaccio</span></span><br><span class="line"><span class="attr">auth</span>:</span><br><span class="line">  <span class="attr">htpasswd</span>:</span><br><span class="line">    <span class="attr">file</span>: ./htpasswd</span><br><span class="line"><span class="attr">uplinks</span>:</span><br><span class="line">  <span class="attr">npmjs</span>:</span><br><span class="line">    <span class="attr">url</span>: <span class="attr">https</span>:<span class="comment">//registry.npmjs.org/</span></span><br><span class="line"><span class="attr">packages</span>:</span><br><span class="line">  <span class="string">&#x27;@*/*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">unpublish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">unpublish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br><span class="line"><span class="attr">server</span>:</span><br><span class="line">  <span class="attr">keepAliveTimeout</span>: <span class="number">60</span></span><br><span class="line"><span class="attr">middlewares</span>:</span><br><span class="line">  <span class="attr">audit</span>:</span><br><span class="line">    <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">logs</span>:</span><br><span class="line">  - &#123; <span class="attr">type</span>: stdout, <span class="attr">format</span>: pretty, <span class="attr">level</span>: http &#125;</span><br></pre></td></tr></table></figure>这里我们来逐个认识一下默认配置中的几个值的含义：</li></ul><p><strong>storage</strong>   已发布的包的存储位置，默认存储在 ~&#x2F;.config&#x2F;Verdaccio&#x2F; 文件夹下<br><strong>plugins</strong>   插件所在的目录<br><strong>web</strong>   界面相关的配置<br><strong>auth</strong>  用户相关，例如注册、鉴权插件（默认使用的是 htpasswd）<br><strong>uplinks</strong>   用于提供对外部包的访问，例如访问 npm、cnpm 对应的源<br><strong>packages</strong>  用于配置发布包、删除包、查看包的权限<br><strong>server</strong>  私有库服务端相关的配置<br><strong>middlewares</strong>   中间件相关配置，默认会引入 auit 中间件，来支持 npm audit 命令<br><strong>logs</strong>  终端输出的信息的配置</p><p>这里我们要做一些处理，前面监听的地址为<a href="http://localhost:4783/,%E4%BD%86%E6%98%AF%E5%85%AC%E7%BD%91%E4%B8%8A%E8%AE%BF%E9%97%AE%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%BA0.0.0.0:4873">http://localhost:4783/,但是公网上访问需要设置为0.0.0.0:4873</a></p><ul><li>公网访问需要在配置上加：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">listen</span>: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">4873</span></span><br></pre></td></tr></table></figure></li></ul><p>在生产环境下，私有 npm 库还需要具备以下 2 个功能：</p><ul><li>支持对 npm 包的搜索</li><li>严格的权限把控，npm 包的访问只能是已注册的用户。并且在一些场景下，需要删除用户</li></ul><ol><li>首先前往verdaccio配置文件config.yaml中加入<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>权限把控</li></ol><ul><li>access 控制包的访问权限</li><li>publish 控制包的发布权限</li><li>unpublish 控制包的删除权限<br>相关的权限，它有三个可选值 $all（所有人）、$anonymous（未注册用户）、$authenticated（注册用户）。<br>作为企业私库，需要修改下权限，为如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages</span>:</span><br><span class="line">  <span class="string">&#x27;@*/*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $authenticated</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">unpublish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $authenticated</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">unpublish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br></pre></td></tr></table></figure></li></ul><p>以上修改后的完整配置为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage</span>: ./storage</span><br><span class="line"><span class="attr">plugins</span>: ./plugins</span><br><span class="line"><span class="attr">web</span>:</span><br><span class="line">  <span class="attr">title</span>: <span class="title class_">Verdaccio</span></span><br><span class="line"><span class="attr">auth</span>:</span><br><span class="line">  <span class="attr">htpasswd</span>:</span><br><span class="line">    <span class="attr">file</span>: ./htpasswd</span><br><span class="line">    <span class="attr">max_users</span>: <span class="number">1000</span> #默认用户为<span class="number">1000</span>，改为-<span class="number">1</span>，禁止注册</span><br><span class="line"><span class="attr">uplinks</span>:</span><br><span class="line">  <span class="attr">npmjs</span>:</span><br><span class="line">    <span class="attr">url</span>: <span class="attr">https</span>:<span class="comment">//registry.npmjs.org/</span></span><br><span class="line"><span class="attr">packages</span>:</span><br><span class="line">  <span class="string">&#x27;@*/*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $authenticated</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">unpublish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $authenticated</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">unpublish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br><span class="line"><span class="attr">server</span>:</span><br><span class="line">  <span class="attr">keepAliveTimeout</span>: <span class="number">60</span></span><br><span class="line"><span class="attr">middlewares</span>:</span><br><span class="line">  <span class="attr">audit</span>:</span><br><span class="line">    <span class="attr">enabled</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">logs</span>: &#123; <span class="attr">type</span>: stdout, <span class="attr">format</span>: pretty, <span class="attr">level</span>: http &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">listen</span>: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">4873</span></span><br><span class="line"></span><br><span class="line"><span class="attr">search</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>修改完了配置，到verdaccio目录下通过$ verdaccio -c config.yaml更新一下<br>重启Verdaccio就可以通过ip访问：<a href="http://192.168.18.170:4873/">http://192.168.18.170:4873/</a><br>后续发布包也可以搜索</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="注册用户"><a href="#注册用户" class="headerlink" title="注册用户"></a>注册用户</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry <span class="attr">http</span>:<span class="comment">//192.168.18.170:4873/</span></span><br></pre></td></tr></table></figure><p>接着，它会要求你填写用户名、密码和邮箱，用于登陆私有 npm 库<br>注册的用户信息会存储在 ~&#x2F;.config&#x2F;verdaccio&#x2F;htpasswd 文件中，<br>想要删除用户可直接在htpasswd文件中删除</p><h2 id="添加、切换源"><a href="#添加、切换源" class="headerlink" title="添加、切换源"></a>添加、切换源</h2><p>nrm 来切换源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g nrm</span><br></pre></td></tr></table></figure><p>添加源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm add dop <span class="attr">http</span>:<span class="comment">//192.168.18.170:4873/</span></span><br></pre></td></tr></table></figure><p>dop 为自定义源名称<br>查看源列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure><p>使用内部自定义源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm use dop</span><br></pre></td></tr></table></figure><h2 id="使用自定义源发布npm包"><a href="#使用自定义源发布npm包" class="headerlink" title="使用自定义源发布npm包"></a>使用自定义源发布npm包</h2><p>在组件库代码项目中执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>组件库封装并发布看另外一篇文章<br><a href="https://cz-liang.github.io/lcz/2022/06/07/VUE-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/">VUE-自定义组件库搭建</a></p><h1 id="使用pm2管理进程"><a href="#使用pm2管理进程" class="headerlink" title="使用pm2管理进程"></a>使用pm2管理进程</h1><p>在确定verdaccio安装成功（本地可以正常运行并发包）的情况下，使用pm2能更好的管理verdaccio服务（需要node.js环境），避免服务被错误关闭，进程被中断的情况。</p><h2 id="pm2简介"><a href="#pm2简介" class="headerlink" title="pm2简介"></a>pm2简介</h2><p>pm2是node进程管理工具，可以用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。关于pm2的内容这里不做过多介绍，大家可以去官网或者其他博客查看了解，后文会附上pm2的常用命令。</p><h2 id="全局安装pm2"><a href="#全局安装pm2" class="headerlink" title="全局安装pm2"></a>全局安装pm2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><h2 id="使用pm2启动verdaccio"><a href="#使用pm2启动verdaccio" class="headerlink" title="使用pm2启动verdaccio"></a>使用pm2启动verdaccio</h2><p><strong>pm2 start verdaccio</strong>启动会报错</p><ul><li>需要找到verdaccio安装目录的bin文件夹中的verdaccio启动文件启动成功<br>（路径：D:\nvm\v16.14.2\node_modules\verdaccio\bin）</li><li>然后：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start <span class="attr">D</span>:\nvm\v16<span class="number">.14</span><span class="number">.2</span>\node_modules\verdaccio\bin\verdaccio</span><br></pre></td></tr></table></figure></li><li>pm2 show verdaccio 查看该进程详细信息</li><li>pm2 logs 查看错误日志</li><li>pm2… …pm2常用命令文末附上<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2>在这个路径C:\Users\EDY\AppData\Roaming\verdaccio直接<strong>verdaccio</strong>启动的服务发的包和pm2启动服务进程（路径：D:\nvm\v16.14.2\node_modules\verdaccio\bin）发的包因为位置不同所以不共用<br><font color=#FF0000 >* 生产环境需要在pm2启动verdaccio进程的状态下发布包</font></li></ul><h1 id="windows下pm2设置开机自启动"><a href="#windows下pm2设置开机自启动" class="headerlink" title="windows下pm2设置开机自启动"></a>windows下pm2设置开机自启动</h1><p>pm2只是保证verdaccio进程不会挂掉，但是pm2自身可会因为机器重启没有启动</p><p>以下为设置pm2开机自启动方法：</p><ul><li>安装windows自启动包<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2-windows-startup -g</span><br></pre></td></tr></table></figure></li><li>执行命令<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2-startup install</span><br></pre></td></tr></table></figure></li><li>使用pm2启用项目<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start 路径 --name 名称</span><br></pre></td></tr></table></figure></li><li>启动所有要管理的应用程序后，保存要在机器重新启动时重新生成的列表<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 save</span><br></pre></td></tr></table></figure></li><li>生成开机自启动服务<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 startup</span><br></pre></td></tr></table></figure></li><li>开机服务<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable pm2-root</span><br></pre></td></tr></table></figure></li><li>重启电脑可以查看<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 ls </span><br></pre></td></tr></table></figure></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>同域下测试过，用其他电脑通过ip访问可下载依赖包并正常使用<br>后续放到服务器需要装相关环境（node等）</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://juejin.cn/post/6844904033354776590">Verdaccio，cnpm，git仓库搭建企业级私库</a><br><a href="https://blog.csdn.net/weixin_43249693/article/details/84453017?spm=1001.2101.3001.6650.19&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-19-84453017-blog-114261826.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-19-84453017-blog-114261826.pc_relevant_antiscanv2&utm_relevant_index=25">记录windows环境下用verdaccio搭建npm私有库</a><br><a href="https://blog.csdn.net/qq_42049445/article/details/114261826">使用 Verdaccio 搭建一个企业级私有 npm 库</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;私有 npm 库，我想是每个团队都会实践和经历的一个阶段。实现私有 npm 的方式有很多种，例如基于私有 Git 仓库、基于 npm 官方提供的私有功能（付费）、Verdaccio 等等。但是，综合比较各种因素下来（不要钱、还好用），Verdaccio 都略胜前面两者。&lt;/p&gt;</summary>
    
    
    
    <category term="npm" scheme="http://example.com/categories/npm/"/>
    
    
    <category term="npm" scheme="http://example.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JS常见算法</title>
    <link href="http://example.com/2022/03/04/JS%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/03/04/JS%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-04T15:52:59.000Z</published>
    <updated>2023-08-31T17:58:06.405Z</updated>
    
    <content type="html"><![CDATA[<p>常见算法积累</p><span id="more"></span><h3 id="找出-1-2-1-3-2-3-4-2-5-数组中出现最多的数字，出现几次"><a href="#找出-1-2-1-3-2-3-4-2-5-数组中出现最多的数字，出现几次" class="headerlink" title="找出 [1, 2, 1, 3, 2, 3, 4, 2, 5] 数组中出现最多的数字，出现几次?"></a>找出 [1, 2, 1, 3, 2, 3, 4, 2, 5] 数组中出现最多的数字，出现几次?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">moreNum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span> <span class="comment">// 出现次数</span></span><br><span class="line">    <span class="keyword">let</span> akey = <span class="literal">null</span>  <span class="comment">// 出现最多的数字</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">im</span> =&gt;</span> &#123;</span><br><span class="line">        obj[im]?</span><br><span class="line">        obj[im] = obj[im] + <span class="number">1</span></span><br><span class="line">        :</span><br><span class="line">        obj[im] = <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj[key] &gt; num)&#123;</span><br><span class="line">            num = obj[key]</span><br><span class="line">            akey = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(akey,num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">moreNum</span>(arr)</span><br></pre></td></tr></table></figure><p>解题思路：</p><ul><li>遍历数组把每个数字作为对象的key,存在key,则该值+1，不存在则为1</li></ul><hr><h3 id="判断-str-x3D-”-”字符串中符号是否正确匹配"><a href="#判断-str-x3D-”-”字符串中符号是否正确匹配" class="headerlink" title="判断 str&#x3D;”([]{})”字符串中符号是否正确匹配?"></a>判断 str&#x3D;”([]{})”字符串中符号是否正确匹配?</h3><p>指的是符号一一对应，()、{}、[]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;([]&#123;&#125;)&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isBalance</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> new_arr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 把左括号加入栈（数组）中</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;(&#x27;</span> || arr[i] == <span class="string">&#x27;&#123;&#x27;</span> || arr[i] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            new_arr.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 然后判断出现的右括号是否和最后加入栈中（数组最后一项）的左括号匹配</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; new_arr.<span class="title function_">pop</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; new_arr.<span class="title function_">pop</span>() != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; new_arr.<span class="title function_">pop</span>() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_arr.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isBalance</span>(str))</span><br></pre></td></tr></table></figure><p>解题思路：</p><ul><li>首先字符串先分割成数组，利用 <strong>“栈”的先进后出</strong> 原理判断符号是否成对出现</li><li>关键：数组 <strong>.pop()</strong> （删除数组最后一项并返回该项）方法返回数组最后一项，如[‘(‘,’{‘].pop()返回’{‘</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常见算法积累&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS继承的6种方式</title>
    <link href="http://example.com/2022/02/28/JS%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/02/28/JS%E7%BB%A7%E6%89%BF%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-02-28T04:03:09.000Z</published>
    <updated>2023-08-31T17:58:06.406Z</updated>
    
    <content type="html"><![CDATA[<p>JS作为面向对象的弱类型语言，继承是其中非常强大的特性之一</p><span id="more"></span><!-- 文章适当文职截断 --><h1 id="JS继承的实现方式"><a href="#JS继承的实现方式" class="headerlink" title="JS继承的实现方式"></a>JS继承的实现方式</h1><p>要实现继承，首先得有一个父类，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (name) &#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;Animal&#x27;</span></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sleep</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在吃&#x27;</span> + food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型连继承"><a href="#原型连继承" class="headerlink" title="原型连继承"></a>原型连继承</h2><p><strong>核心：</strong> 将父类的实例作为子类的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span> () &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>非常纯粹的继承关系</li><li>父类新增的原型方法&#x2F;原型属性，子类都能访问到</li><li>简单，易于实现</li></ol><p>缺点：</p><ol><li>要想为子类新增属性和方法，必须在<code>JS new Animal() </code>这样的语句之后执行，不能放到构造器中</li></ol><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>参考：<a href="https://www.cnblogs.com/humin/p/4556820.html">原文地址</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS作为面向对象的弱类型语言，继承是其中非常强大的特性之一&lt;/p&gt;</summary>
    
    
    
    <category term="JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>nvm node 包管理</title>
    <link href="http://example.com/2022/02/22/nvmuse/"/>
    <id>http://example.com/2022/02/22/nvmuse/</id>
    <published>2022-02-22T04:21:24.000Z</published>
    <updated>2023-08-31T17:58:06.406Z</updated>
    
    <content type="html"><![CDATA[<p>nvm node版本管理工具</p><span id="more"></span><h2 id="nvm下载地址"><a href="#nvm下载地址" class="headerlink" title="nvm下载地址"></a>nvm下载地址</h2><ul><li><a href="https://github.com/coreybutler/nvm-windows/tags">https://github.com/coreybutler/nvm-windows/tags</a></li><li>下载nvm-setup.zip文件，默认安装即可<br>（默认安装路径：C:\Users\Administrator\AppData\Roaming\nvm）</li><li>在此路径下才能管理操作，其他路径下会提示：This is not the package you are looking for: please go to <a href="http://nvm.sh/">http://nvm.sh</a><br>（可做其他配置，这里就直接在默认路径下管理node版本）</li></ul><h2 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h2><ul><li>nvm install version 安装指定node版本</li><li>nvm ls 查看安装的node版本列表</li><li>nvm use version 使用node不同版本</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;nvm node版本管理工具&lt;/p&gt;</summary>
    
    
    
    <category term="前端环境" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>npm does not support nodejs</title>
    <link href="http://example.com/2022/02/21/npm-does-not-support-nodejs/"/>
    <id>http://example.com/2022/02/21/npm-does-not-support-nodejs/</id>
    <published>2022-02-21T15:30:00.000Z</published>
    <updated>2023-08-31T17:58:06.406Z</updated>
    
    <content type="html"><![CDATA[<p>win7不支持安装高版本node.js</p><p>win7支持最高的nodejs版本为v13.14.0</p><span id="more"></span><p>下载链接：<a href="https://nodejs.org/zh-cn/download/releases/">https://nodejs.org/zh-cn/download/releases/</a></p><p>安装高版本的node.js后出现 npm does not support nodejs 等问题<br>是因为npm版本与node版本不一致<br>删除npm后重新安装node即可<br>手动删除npm：<br>删除默认安装路径C:\Program Files\nodejs\node_modules下的npm文件夹</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;win7不支持安装高版本node.js&lt;/p&gt;
&lt;p&gt;win7支持最高的nodejs版本为v13.14.0&lt;/p&gt;</summary>
    
    
    
    <category term="前端环境" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法</title>
    <link href="http://example.com/2022/01/17/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/01/17/Markdown-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2022-01-17T08:21:53.000Z</published>
    <updated>2023-08-31T17:58:06.406Z</updated>
    
    <content type="html"><![CDATA[<p> Markdown 常用语法</p><span id="more"></span><p>一、标题<br>　一般使用 来进行层级标识。共 6 个层级，再多不识别。</p><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><h6 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h6><p>　　注：h1 级别会默认带一个 <hr/></p><p>二、分隔线<br>　　至少三个 * 或 - 或 _ ，有空格也可以，不必连续。</p><hr><p>三、换行加缩进，输入法全角模式下两个空格（一般情况下中英文打字是用半角）<br>　　两个空格 + 一个回车<br>　　试试</p><p>四、代码<br>　　一行代码好像有简写，不过为了统一方便（偷懒，不想记），如下格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">link</span> <span class="attr">href</span>=<span class="string">&quot;http://aaa.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　即首尾各多行 &#96;&#96;&#96; 。</p><p>五、引用<br>　　符号是 &gt; ，引用里可以套引用，理论上无限嵌套。如：</p><blockquote><p>一级</p><blockquote><p>二级</p><blockquote><p>三级</p><blockquote><p>四级<br>…</p></blockquote></blockquote></blockquote></blockquote><p>　图片上传不了，请参考 <a href="https://www.cnblogs.com/liugang-vip/p/6337580.html%E3%80%82">https://www.cnblogs.com/liugang-vip/p/6337580.html。</a></p><p>六、强调<br>  　　<em>文本1</em>或 <em>文本1</em> 　　斜体；</p><p>　　<strong>文本2</strong>或者 <strong>文本2</strong> 　　加重强调；</p><p>　　<em><strong>文本3</strong></em> 或者  <em><strong>文本3</strong></em> 　　特别强调；</p><p>七、链接<br>　　格式：<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">页面文字</a>，如：<a href="https://www.baidu.com/">百度</a>；</p><p>　　但是，md 中链接不支持 _blank，所以个人的写法还是直接写成：<a href="www.baidu.com" target="_blank">百度xx</a> ；</p><p>八、列表<br>　　有序列表（注意，’ . ‘ 后面要跟一个空格）：</p><ol><li>xxxx</li><li>xxxxx</li><li>xxxx</li></ol><p>　　无序列表（注意，’ * ‘ 后面要跟一个空格）：</p><ul><li>xxxx</li><li>xxxx</li><li>xxxxx</li></ul><p>　　也支持嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数。</p><p>九、图片<br>　　和 链接 类似，格式：</p><p> <img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" alt="Alt text"><br>十、表格</p><p>　注意：上面是三种不同的写法，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中。</p><p>十一、删除线<br>代码：</p><p><del>删除我吧</del></p><p>样式：<br> 删除我吧</p><p>十二、 转义</p><p>转义就是将一些特殊字符转换成正常显示的样子，和大多数编程语言相同使用反斜杠()表示。下面简单列举几个。<br>代码：</p><ul><li>\</li><li>`</li><li>*</li><li>!</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; Markdown 常用语法&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Markdown" scheme="http://example.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>无法提交next文件到github问题解决</title>
    <link href="http://example.com/2022/01/17/%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4next%E6%96%87%E4%BB%B6%E5%88%B0github%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/2022/01/17/%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4next%E6%96%87%E4%BB%B6%E5%88%B0github%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2022-01-17T07:17:12.000Z</published>
    <updated>2023-08-31T17:58:06.407Z</updated>
    
    <content type="html"><![CDATA[<p>无法提交根本原因是next主题也是一个repo。</p><span id="more"></span><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>剪切 themes&#x2F;next&#x2F;.git文件夹到其它处</p></li><li><p>从暂存区删除该文件夹<br>git rm –cache themes&#x2F;next</p></li><li><p>使用git status查看状态</p></li><li><p>三步走: –&gt;git add .  –&gt;git commit -m “” –&gt;git push</p></li><li><p>再移回themes&#x2F;next&#x2F;.git文件夹</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;无法提交根本原因是next主题也是一个repo。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Next 博客建设</title>
    <link href="http://example.com/2022/01/17/Hexo+Next/"/>
    <id>http://example.com/2022/01/17/Hexo+Next/</id>
    <published>2022-01-17T03:10:16.000Z</published>
    <updated>2023-08-31T17:58:06.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><span id="more"></span><ul><li>hexo new articleName #新建文章</li><li>hexo new page pageName #新建页面</li><li>hexo generate #生成静态页面至public目录</li><li>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</li><li>hexo deploy #将.deploy目录部署到GitHub</li><li>hexo help  #查看帮助</li><li>hexo version  #查看Hexo的版本</li></ul><h2 id="使用以下命令部署"><a href="#使用以下命令部署" class="headerlink" title="使用以下命令部署"></a>使用以下命令部署</h2><ul><li>hexo clean</li><li>hexo generate</li><li>hexo deploy</li></ul><h3 id="Next主题后续美化可参考"><a href="#Next主题后续美化可参考" class="headerlink" title="Next主题后续美化可参考"></a>Next主题后续美化可参考</h3><p><a href="https://siriusq.top/Next%E5%8D%87%E7%BA%A7-Mac%E8%BF%81%E7%A7%BB.html">https://siriusq.top/Next%E5%8D%87%E7%BA%A7-Mac%E8%BF%81%E7%A7%BB.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Hexo常用命令&quot;&gt;&lt;a href=&quot;#Hexo常用命令&quot; class=&quot;headerlink&quot; title=&quot;Hexo常用命令&quot;&gt;&lt;/a&gt;Hexo常用命令&lt;/h2&gt;</summary>
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
