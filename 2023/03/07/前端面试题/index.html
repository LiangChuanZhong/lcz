<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/lcz/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/lcz/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/lcz/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/lcz/images/logo.svg" color="#222">

<link rel="stylesheet" href="/lcz/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/lcz/","images":"/lcz/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/lcz/js/config.js"></script>

  <meta name="description" content="前端面试题">
<meta property="og:type" content="website">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://example.com/2023/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="cz-liang">
<meta property="og:description" content="前端面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/1.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview2.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/3.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/4.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/5.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/6.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/7.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/8.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/9.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/10.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/11.png">
<meta property="og:image" content="http://example.com/lcz/assets/img/interview/12.png">
<meta property="article:published_time" content="2023-03-07T09:22:13.000Z">
<meta property="article:modified_time" content="2023-08-31T17:58:06.407Z">
<meta property="article:author" content="cz-liang">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/lcz/assets/img/interview/1.png">


<link rel="canonical" href="http://example.com/2023/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","path":"2023/03/07/前端面试题/","title":"前端面试题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端面试题 | cz-liang</title>
  





  <noscript>
    <link rel="stylesheet" href="/lcz/css/noscript.css">
  </noscript>
<link rel="alternate" href="/lcz/atom.xml" title="cz-liang" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/lcz/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">cz-liang</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/lcz/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/lcz/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/lcz/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/lcz/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/lcz/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8E%86"><span class="nav-number">1.</span> <span class="nav-text">简历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML-CSS-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">HTML+CSS 面试题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js-%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">js 基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#web-%E5%AD%98%E5%82%A8"><span class="nav-number">4.</span> <span class="nav-text">web 存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Http"><span class="nav-number">5.</span> <span class="nav-text">Http</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">6.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#webpack"><span class="nav-number">7.</span> <span class="nav-text">webpack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99"><span class="nav-number">10.</span> <span class="nav-text">常见手写</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">11.</span> <span class="nav-text">其它</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">算法</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cz-liang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/lcz/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/lcz/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/lcz/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/lcz/images/avatar.gif">
      <meta itemprop="name" content="cz-liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cz-liang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端面试题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-07 17:22:13" itemprop="dateCreated datePublished" datetime="2023-03-07T17:22:13+08:00">2023-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-01 01:58:06" itemprop="dateModified" datetime="2023-09-01T01:58:06+08:00">2023-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/lcz/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>前端面试题</p>
<span id="more"></span>
<h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><p>简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。<br>1、重点</p>
<ul>
<li>简历就像高考作文——阅卷时间非常短。</li>
<li>内容要简洁。</li>
<li>直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。</li>
</ul>
<p>2、简历包含的内容</p>
<ul>
<li><p>个人信息。</p>
</li>
<li><p>专业技能。</p>
</li>
<li><p>工作经历。</p>
</li>
<li><p>项目经历。</p>
</li>
<li><p>社区贡献。</p>
<p>2.1 基本信息</p>
</li>
<li><p>必备：姓名 电话 邮箱。</p>
</li>
<li><p>年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。</p>
</li>
<li><p>头像无所谓（好看就放上呗）。</p>
</li>
<li><p>可以放 github 链接，前提是有内容。</p>
<p>2.2 专业技能</p>
</li>
<li><p>表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。</p>
</li>
<li><p>内容不要太多，3、5 条即可。</p>
</li>
<li><p>太基础的不要写，例如会用 vscode、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=lodash&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2430900871%7D">lodash</a>。</p>
<p>2.3 工作经历</p>
</li>
<li><p>如实写。</p>
</li>
<li><p>写明公司，职位，入职离职时间即可，多写无益。</p>
</li>
<li><p>如果有空窗期，如实写明即可。</p>
<p>2.4 项目经历</p>
</li>
<li><p>写 2-4 个具有说服力的项目（不要什么项目都写，没用）。</p>
</li>
<li><p>项目名称，项目描述，技术栈，个人角色。</p>
<p>2.5 社区贡献</p>
</li>
<li><p>有博客或者开源作品，会让你更有竞争力。</p>
</li>
<li><p>切记：需要真的有内容，不可临时抱佛脚。</p>
</li>
</ul>
<p>3、注意事项</p>
<ul>
<li>界面不能太花哨，简洁明了即可。</li>
<li>注意用词，“精通”“熟练”等慎用，可用“熟悉”。</li>
<li>不可造假，会被拉入黑名单。</li>
</ul>
<p>4、面试前准备</p>
<ul>
<li>看 JD，是否需要临时准备一下。</li>
<li>打印纸质简历，带着纸和笔（增加好印象）。</li>
<li>最好带着自己电脑，现场可能手写代码（带一个帆布包最适合，又优雅又方便）。</li>
<li>要有时间观念，如果迟到或者推迟，要提前说。</li>
<li>衣着适当，不用正装，也不要太随意。</li>
<li>为何离职？—— 不要吐槽前东家，说自己的原因（想找一个更好的发展平台等）。</li>
<li>能加班吗？—— 能！除非你特别自信，能找到其他机会。</li>
<li>不要挑战面试官，即便他错了（面试一定要保证愉快）。</li>
<li>遇到不会的问题，要表现出自己积极的一面（不好意思哈，确实是我的知识盲区，可以跟我说下 xxx 吗，我回去研究一下）。</li>
</ul>
<h1 id="HTML-CSS-面试题"><a href="#HTML-CSS-面试题" class="headerlink" title="HTML+CSS 面试题"></a>HTML+CSS 面试题</h1><p>HTML 和 CSS 面试题答不出来基本可以回去了。<br>1、HTML 面试题<br>以下是针对 HTML 相关的面试题，一般来说这地方不会出太多题，面试官也不愿意花太多时间在这上面。<br>1.1 如何理解 HTML 语义化？</p>
<ul>
<li><p>让人更容易读懂（增加代码可读性）。</p>
</li>
<li><p>让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。</p>
</li>
<li><p>在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。</p>
<p>1.2 script 标签中 defer 和 async 的区别？</p>
</li>
<li><p><code>script</code> ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</p>
</li>
<li><p><code>async script</code> ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</p>
</li>
<li><p><code>defer script</code>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</p>
</li>
</ul>
<p>下图清晰地展示了三种 <code>script</code> 的过程：</p>
<p><img src="/lcz/./assets/img/interview/1.png" alt="img"></p>
<p>推荐文章：</p>
<ul>
<li><p><a href="./assets/img/interview/1.png">图解 script 标签中的 async 和 defer 属性</a></p>
<p>1.3 从浏览器地址栏输入 url 到请求返回发生了什么</p>
</li>
</ul>
<p>先阅读这篇科普性质的：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903784229896199">从 URL 输入到页面展现到底发生什么？</a> 先阅读篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6935232082482298911">从输入 URL 开始建立前端知识体系</a>。</p>
<ol>
<li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。</li>
</ol>
<ul>
<li>强缓存。</li>
<li>协商缓存。</li>
</ul>
<ol>
<li>DNS 域名解析。（<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6990344840181940261">字节面试被虐后，是时候搞懂 DNS 了</a>）</li>
<li>TCP 连接。<br>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点<strong>可靠传输</strong>决定的。客户端和服务端要进行可靠传输，那么就需要<strong>确认双方的接收和发送能力</strong>。第一次握手可以确认客服端的<strong>发送能力</strong>，第二次握手，确认了服务端的<strong>发送能力和接收能力</strong>，所以第三次握手才可以确认客户端的<strong>接收能力</strong>。不然容易出现丢包的现象。</li>
<li>http 请求。</li>
<li>服务器处理请求并返回 HTTP 报文。</li>
<li>浏览器渲染页面。</li>
</ol>
<p><img src="/lcz/./assets/img/interview2.png" alt="img"></p>
<ol>
<li>断开 TCP 连接。</li>
</ol>
<p>2、CSS 面试题<br>以下是针对 CSS 相关的面试题，这些题答不出来会给人非常不好的技术印象。<br>2.1 盒模型介绍<br>CSS3 中的盒模型有以下两种：<strong>标准盒模型</strong>、<strong>IE（替代）盒模型</strong>。<br>两种盒子模型都是由 <code>content + padding + border + margin</code> 构成，其大小都是由 <code>content + padding + border</code> 决定的，但是盒子内容宽&#x2F;高度（即 <code>width/height</code>）的计算范围根据盒模型的不同会有所不同：</p>
<ul>
<li>标准盒模型：只包含 <code>content</code> 。</li>
<li>IE（替代）盒模型：<code>content + padding + border</code> 。</li>
</ul>
<p>可以通过 <code>box-sizing</code> 来改变元素的盒模型：</p>
<ul>
<li><p><code>box-sizing: content-box</code> ：标准盒模型（默认值）。</p>
</li>
<li><p><code>box-sizing: border-box</code> ：IE（替代）盒模型。</p>
<p>2.2 css 选择器和优先级<br>首先我们要知道有哪些选择器：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors%23%25E9%2580%2589%25E6%258B%25A9%25E5%2599%25A8%25E5%258F%2582%25E8%2580%2583%25E8%25A1%25A8">选择器参考表</a>。<br>常规来说，大家都知道样式的优先级一般为 <code>!important &gt; style &gt; id &gt; class</code> ，但是涉及多类选择器作用于同一个元素时候怎么判断优先级呢？相信我，你在改一些第三方库（比如 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=antd&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2430900871%7D">antd</a> ）样式时，理解这个会帮助很大！<br>这篇文章写的非常清晰易懂，强烈推荐，看完之后就没啥问题了：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903709772611592">深入理解 CSS 选择器优先级</a>。<br>上述文章中核心内容： 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>
</li>
<li><p>如果存在内联样式，那么 <code>A = 1</code>，否则 <code>A = 0</code> ；</p>
</li>
<li><p>B 的值等于 <code>ID选择器（#id）</code> 出现的次数；</p>
</li>
<li><p>C 的值等于 <code>类选择器（.class）</code> 和 <code>属性选择器（a[href=&quot;https://example.org&quot;]）</code> 和 <code>伪类（:first-child）</code> 出现的总次数；</p>
</li>
<li><p>D 的值等于 <code>标签选择器（h1,a,div）</code> 和 <code>伪元素（::before,::after）</code> 出现的总次数。<br>从左至右比较，如果是样式优先级相等，取后面出现的样式。<br>2.3 重排（reflow）和重绘（repaint）的理解<br>简单地总结下两者的概念：</p>
</li>
<li><p>重排：无论通过什么方式影响了元素的<strong>几何信息</strong>(元素在视口内的位置和尺寸大小)，浏览器需要<strong>重新计算</strong>元素在视口内的几何属性，这个过程叫做重排。</p>
</li>
<li><p>重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的<strong>实际像素</strong>，这个阶段就叫做重绘。</p>
</li>
</ul>
<p>如何减少重排和重绘？</p>
<ul>
<li><strong>最小化重绘和重排</strong>，比如样式集中改变，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</li>
<li><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</li>
<li><strong>使用 <code>\**absolute\**</code> 或 <code>\**fixed\**</code> 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</li>
<li><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</li>
</ul>
<p>这里推荐<strong>腾讯 IVWEB 团队</strong>的这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a>，好好认真看完，面试应该没问题的。</p>
<p>2.4 对 BFC 的理解<br>BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到<strong>尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸</strong>等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做<strong>视觉格式化模型</strong>的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，<strong>用于决定块级盒的布局及浮动相互影响范围的一个区域</strong>。<br>BFC 具有一些特性：</p>
<ol>
<li>块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。</li>
<li>在 BFC 中上下相邻的两个容器的 <code>margin</code> 会重叠，创建新的 BFC 可以避免外边距重叠。</li>
<li>计算 BFC 的高度时，需要计算浮动元素的高度。</li>
<li>BFC 区域不会与浮动的容器发生重叠。</li>
<li>BFC 是独立的容器，容器内部元素不会影响外部元素。</li>
<li>每个元素的左 <code>margin</code> 值和容器的左 <code>border</code> 相接触。</li>
</ol>
<p>利用这些特性，我们可以解决以下问题：</p>
<ul>
<li>利用 <code>4</code> 和 <code>6</code> ，我们可以实现三栏（或两栏）自适应布局。</li>
<li>利用 <code>2</code> ，我们可以避免 <code>margin</code> 重叠问题。</li>
<li>利用 <code>3</code> ，我们可以避免高度塌陷。</li>
</ul>
<p>创建 BFC 的方式：</p>
<ul>
<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li>
<li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 。</li>
</ul>
<p>推荐文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6960866014384881671">可能是最好的 BFC 解析了…</a></p>
<p>2.5 实现两栏布局（左侧固定 + 右侧自适应布局）<br>现在有以下 DOM 结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt; &lt;/div&gt; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   height: 100px; &#125; .left &#123;   float: left;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   margin-left: 200px;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   height: 100px; &#125; .left &#123;   float: left;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   overflow: auto;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   display: flex;   height: 100px; &#125; .left &#123;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   flex: 1;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code> 定位，宽度固定。右边元素的 <code>margin-left</code> 的值设为左边元素的宽度值。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   position: relative;   height: 100px; &#125; .left &#123;   position: absolute;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   margin-left: 200px;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code> 定位， <code>left</code> 为宽度大小，其余方向定位为 <code>0</code> 。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;   position: relative;   height: 100px; &#125; .left &#123;   width: 200px;   height: 100%;   background: lightcoral; &#125; .right &#123;   position: absolute;   left: 200px;   top: 0;   right: 0;   bottom: 0;   height: 100%;   background: lightseagreen; &#125; 复制代码</span><br></pre></td></tr></table></figure>

<p>2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）<br>圣杯布局和双飞翼布局的目的：</p>
<ul>
<li>三栏布局，中间一栏最先加载和渲染（<strong>内容最重要，这就是为什么还需要了解这种布局的原因</strong>）。</li>
<li>两侧内容固定，中间内容随着宽度自适应。</li>
<li>一般用于 PC 网页。</li>
</ul>
<p>圣杯布局和双飞翼布局的技术总结：</p>
<ul>
<li>使用 <code>float</code> 布局。</li>
<li>两侧使用 <code>margin</code> 负值，以便和中间内容横向重叠。</li>
<li>防止中间内容被两侧覆盖，圣杯布局用 <code>padding</code> ，双飞翼布局用 <code>margin</code> 。</li>
</ul>
<p><strong>圣杯布局：</strong> HTML 结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt; &lt;p class=&quot;center&quot;&gt;我是中间&lt;/p&gt; &lt;p class=&quot;left&quot;&gt;我是左边&lt;/p&gt; &lt;p class=&quot;right&quot;&gt;我是右边&lt;/p&gt; &lt;/div&gt; 复制代码</span><br><span class="line">CSS 样式：</span><br><span class="line">#container &#123;   padding-left: 200px;   padding-right: 150px;   overflow: auto; &#125; #container p &#123;   float: left; &#125; .center &#123;   width: 100%;   background-color: lightcoral; &#125; .left &#123;   width: 200px;   position: relative;   left: -200px;   margin-left: -100%;   background-color: lightcyan; &#125; .right &#123;   width: 150px;   margin-right: -150px;   background-color: lightgreen; &#125; .clearfix:after &#123;   content: &quot;&quot;;   display: table;   clear: both; &#125; 复制代码</span><br></pre></td></tr></table></figure>

<p><strong>双飞翼布局：</strong> HTML 结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;main&quot; class=&quot;float&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;float&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;float&quot;&gt;right&lt;/div&gt; 复制代码</span><br><span class="line">CSS 样式：</span><br><span class="line">.float &#123;   float: left; &#125; #main &#123;   width: 100%;   height: 200px;   background-color: lightpink; &#125; #main-wrap &#123;   margin: 0 190px 0 190px; &#125; #left &#123;   width: 190px;   height: 200px;   background-color: lightsalmon;   margin-left: -100%; &#125; #right &#123;   width: 190px;   height: 200px;   background-color: lightskyblue;   margin-left: -190px; &#125; 复制代码</span><br></pre></td></tr></table></figure>

<p>tips：上述代码中 <code>margin-left: -100%</code> 相对的是父元素的 <code>content</code> 宽度，即不包含 <code>paddig</code> 、 <code>border</code> 的宽度。</p>
<p>其实以上问题需要掌握 <strong>margin 负值问题</strong> 即可很好理解。<br>2.7 水平垂直居中多种实现方式</p>
<ol>
<li>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code> 来调整子元素的中心点到父元素的中心。该方法可以<strong>不定宽高</strong>。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;   position: relative; &#125; .son &#123;   position: absolute;   left: 50%;   top: 50%;   transform: translate(-50%, -50%); &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用绝对定位，子元素所有方向都为 <code>0</code> ，将 <code>margin</code> 设置为 <code>auto</code> ，由于宽高固定，对应方向实现平分，该方法必须<strong>盒子有宽高</strong>。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;   position: relative; &#125; .son &#123;   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0px;   margin: auto;   height: 100px;   width: 100px; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code> 和 <code>margin-top</code> 以子元素自己的一半宽高进行负值赋值。该方法<strong>必须定宽高</strong>。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father &#123;   position: relative; &#125; .son &#123;   position: absolute;   left: 50%;   top: 50%;   width: 200px;   height: 200px;   margin-left: -100px;   margin-top: -100px; &#125; 复制代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>利用 <code>flex</code> ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。</li>
</ol>
<p>.father { display: flex; justify-content: center; align-items: center; } 复制代码<br>其实还有很多方法，比如 <code>display: grid</code> 或 <code>display: table-cell</code> 来做，有兴趣点击下面这篇文章可以了解下：</p>
<p><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903982960214029">面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高）</a>。</p>
<p>2.8 flex 布局</p>
<p>这一块内容看 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a> 就够了。<br>这里有个小问题，很多时候我们会用到 <code>flex: 1</code> ，它具体包含了以下的意思：</p>
<ul>
<li><p><code>flex-grow: 1</code> ：该属性默认为 <code>0</code> ，如果存在剩余空间，元素也不放大。设置为 <code>1</code> 代表会放大。</p>
</li>
<li><p><code>flex-shrink: 1</code> ：该属性默认为 <code>1</code> ，如果空间不足，元素缩小。</p>
</li>
<li><p><code>flex-basis: 0%</code> ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来<strong>计算是否有多余空间</strong>的。默认值为 <code>auto</code> ，即项目本身大小。设置为 <code>0%</code> 之后，因为有 <code>flex-grow</code> 和 <code>flex-shrink</code> 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 <code>flex-basis</code> 设为 <code>auto</code> 的话，其本身大小将会是 <code>0</code> 。</p>
<p>2.9 line-height 如何继承？</p>
</li>
<li><p>父元素的 <code>line-height</code> 写了<strong>具体数值</strong>，比如 <code>30px</code>，则子元素 <code>line-height</code> 继承该值。</p>
</li>
<li><p>父元素的 <code>line-height</code> 写了<strong>比例</strong>，比如 <code>1.5 或 2</code>，则子元素 <code>line-height</code> 也是继承该比例。</p>
</li>
<li><p>父元素的 <code>line-height</code> 写了<strong>百分比</strong>，比如 <code>200%</code>，则子元素 <code>line-height</code> 继承的是父元素 <code>font-size * 200%</code> 计算出来的值。</p>
</li>
</ul>
<h1 id="js-基础"><a href="#js-基础" class="headerlink" title="js 基础"></a>js 基础</h1><p>js 的考察其实来回就那些东西，不过就我自己而已学习的时候理解是真的理解了，但是忘也确实会忘（大家都说理解了一定不会忘，但是要答全的话还是需要理解+背）。<br>1、数据类型<br>以下是比较重要的几个 js 变量要掌握的点。<br>1.1 基本的数据类型介绍，及值类型和引用类型的理解<br>在 JS 中共有 <code>8</code> 种基础的数据类型，分别为： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Object</code> 、 <code>Symbol</code> 、 <code>BigInt</code> 。<br>其中 <code>Symbol</code> 和 <code>BigInt</code> 是 ES6 新增的数据类型，可能会被单独问：</p>
<ul>
<li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li>
<li>BigInt 可以表示任意大小的整数。</li>
</ul>
<p><strong>值类型的赋值变动过程如下：</strong><br>let a &#x3D; 100; let b &#x3D; a; a &#x3D; 200; console.log(b); &#x2F;&#x2F; 100 复制代码</p>
<p><img src="/lcz/./assets/img/interview/3.png" alt="img"></p>
<p>值类型是直接存储在<strong>栈（stack）</strong>中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br><strong>引用类型的赋值变动过程如下：</strong><br>let a &#x3D; { age: 20 }; let b &#x3D; a; b.age &#x3D; 30; console.log(a.age); &#x2F;&#x2F; 30 复制代码</p>
<p><img src="/lcz/./assets/img/interview/4.png" alt="img"></p>
<p>引用类型存储在<strong>堆（heap）</strong>中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；<br>1.2 数据类型的判断</p>
<ul>
<li><strong>typeof</strong>：能判断所有<strong>值类型，函数</strong>。不可对 <strong>null、对象、数组</strong>进行精确判断，因为都返回 <code>object</code> 。</li>
</ul>
<p>console.log(typeof undefined); &#x2F;&#x2F; undefined console.log(typeof 2); &#x2F;&#x2F; number console.log(typeof true); &#x2F;&#x2F; boolean console.log(typeof “str”); &#x2F;&#x2F; string console.log(typeof Symbol(“foo”)); &#x2F;&#x2F; symbol console.log(typeof 2172141653n); &#x2F;&#x2F; bigint console.log(typeof function () {}); &#x2F;&#x2F; function &#x2F;&#x2F; 不能判别 console.log(typeof []); &#x2F;&#x2F; object console.log(typeof {}); &#x2F;&#x2F; object console.log(typeof null); &#x2F;&#x2F; object 复制代码</p>
<ul>
<li><strong>instanceof</strong>：能判断<strong>对象</strong>类型，不能判断基本数据类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。比如考虑以下代码：</li>
</ul>
<p>class People {} class Student extends People {} const vortesnail &#x3D; new Student(); console.log(vortesnail instanceof People); &#x2F;&#x2F; true console.log(vortesnail instanceof Student); &#x2F;&#x2F; true 复制代码<br>其实现就是顺着<strong>原型链</strong>去找，如果能找到对应的 <code>Xxxxx.prototype</code> 即为 <code>true</code> 。比如这里的 <code>vortesnail</code> 作为实例，顺着原型链能找到 <code>Student.prototype</code> 及 <code>People.prototype</code> ，所以都为 <code>true</code> 。</p>
<ul>
<li>**Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 <strong>Error 对象，Date 对象</strong>等。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2); // &quot;[object Number]&quot; Object.prototype.toString.call(&quot;&quot;); // &quot;[object String]&quot; Object.prototype.toString.call(true); // &quot;[object Boolean]&quot; Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot; Object.prototype.toString.call(null); // &quot;[object Null]&quot; Object.prototype.toString.call(Math); // &quot;[object Math]&quot; Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot; Object.prototype.toString.call([]); // &quot;[object Array]&quot; Object.prototype.toString.call(function () &#123;&#125;); // &quot;[object Function]&quot; 复制代码</span><br></pre></td></tr></table></figure>

<p>在面试中有一个经常被问的问题就是：如何判断变量是否为数组？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(arr); // true arr.__proto__ === Array.prototype; // true arr instanceof Array; // true Object.prototype.toString.call(arr); // &quot;[object Array]&quot; 复制代码</span><br></pre></td></tr></table></figure>

<p>1.3 手写深拷贝</p>
<p>这个题一定要会啊！笔者面试过程中疯狂被问到！</p>
<p>文章推荐：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**  * 深拷贝  * @param &#123;Object&#125; obj 要拷贝的对象  * @param &#123;Map&#125; map 用于存储循环引用对象的地址  */ function deepClone(obj = &#123;&#125;, map = new Map()) &#123;   if (typeof obj !== &quot;object&quot;) &#123;     return obj;   &#125;   if (map.get(obj)) &#123;     return map.get(obj);   &#125;    let result = &#123;&#125;;   // 初始化返回结果 if (     obj instanceof Array ||     // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此 Object.prototype.toString(obj) === &quot;[object Array]&quot;   ) &#123;     result = [];   &#125;   // 防止循环引用   map.set(obj, result);   for (const key in obj) &#123;     // 保证 key 不是原型属性 if (obj.hasOwnProperty(key)) &#123;       // 递归调用       result[key] = deepClone(obj[key], map);     &#125;   &#125;    // 返回结果 return result; &#125; 复制代码</span><br></pre></td></tr></table></figure>

<p>1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？</p>
<p>建议先阅读这篇文章了解 IEEE 754 ：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6940405970954616839">硬核基础二进制篇（一）0.1 + 0.2 !&#x3D; 0.3 和 IEEE-754 标准</a>。 再阅读这篇文章了解如何运算：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903680362151950">0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？</a>。 ​<br>原因总结：</p>
<ul>
<li><code>进制转换</code> ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。</li>
<li><code>对阶运算</code> ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（<code>0舍1入</code>），尾数位移时可能会发生数丢失的情况，影响精度。</li>
</ul>
<p>解决办法：</p>
<ol>
<li>转为整数（大数）运算。</li>
</ol>
<p>function add(a, b) { const maxLen &#x3D; Math.max( a.toString().split(“.”)[1].length, b.toString().split(“.”)[1].length ); const base &#x3D; 10 ** maxLen; const bigA &#x3D; BigInt(base _ a); const bigB &#x3D; BigInt(base _ b); const bigRes &#x3D; (bigA + bigB) &#x2F; BigInt(base); &#x2F;&#x2F; 如果是 (1n + 2n) &#x2F; 10n 是等于 0n 的。。。 return Number(bigRes); } 复制代码<br>这里代码是有问题的，因为最后计算 <code>bigRes</code> 的大数相除（即 <code>/</code>）是会把小数部分截掉的，所以我很疑惑为什么网络上很多文章都说可以通过**先转为整数运算再除回去，为了防止转为的整数超出 js 表示范围，还可以运用到 ES6 新增的大数类型，我真的很疑惑，希望有好心人能解答下。**</p>
<ol>
<li>使用 <code>Number.EPSILON</code> 误差范围。</li>
</ol>
<p>function isEqual(a, b) { return Math.abs(a - b) &lt; Number.EPSILON; } console.log(isEqual(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true 复制代码<br><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。 ​</p>
<ol>
<li>转成字符串，对字符串做加法运算。</li>
</ol>
<p>&#x2F;&#x2F; 字符串数字相加 var addStrings &#x3D; function (num1, num2) { let i &#x3D; num1.length - 1; let j &#x3D; num2.length - 1; const res &#x3D; []; let carry &#x3D; 0; while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) { const n1 &#x3D; i &gt;&#x3D; 0 ? Number(num1[i]) : 0; const n2 &#x3D; j &gt;&#x3D; 0 ? Number(num2[j]) : 0; const sum &#x3D; n1 + n2 + carry; res.unshift(sum % 10); carry &#x3D; Math.floor(sum &#x2F; 10); i–; j–; } if (carry) { res.unshift(carry); } return res.join(“”); }; function isEqual(a, b, sum) { const [intStr1, deciStr1] &#x3D; a.toString().split(“.”); const [intStr2, deciStr2] &#x3D; b.toString().split(“.”); const inteSum &#x3D; addStrings(intStr1, intStr2); &#x2F;&#x2F; 获取整数相加部分 const deciSum &#x3D; addStrings(deciStr1, deciStr2); &#x2F;&#x2F; 获取小数相加部分 return inteSum + “.” + deciSum &#x3D;&#x3D;&#x3D; String(sum); } console.log(isEqual(0.1, 0.2, 0.3)); &#x2F;&#x2F; true 复制代码<br>这是 leetcode 上一道原题：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a>。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。<br>2、 原型和原型链<br>可以说这部分每家面试官都会问了。。首先理解的话，其实一张图即可，一段代码即可。<br>function Foo() {} let f1 &#x3D; new Foo(); let f2 &#x3D; new Foo(); 复制代码<br>千万别畏惧下面这张图，特别有用，一定要搞懂，熟到提笔就能默画出来。</p>
<p><img src="/lcz/./assets/img/interview/5.png" alt="img"></p>
<p>总结：</p>
<ul>
<li>原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性，其实就是 <code>prototype</code> 对象。</li>
<li>原型链：由相互关联的原型组成的<strong>链状结构</strong>就是原型链。</li>
</ul>
<p>先说出总结的话，再举例子说明如何顺着原型链找到某个属性。<br>推荐的阅读：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/blog/issues/2">JavaScript 深入之从原型到原型链</a> 掌握基本概念，再阅读这篇文章<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903989088092174">轻松理解 JS 原型原型链</a>加深上图的印象。<br>3、 作用域与作用域链</p>
<ul>
<li>作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</li>
<li>作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）</li>
</ul>
<p><strong>需要注意的是，js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。</strong><br>推荐阅读：先阅读<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/3">JavaScript 深入之词法作用域和动态作用域</a>，再阅读<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903797135769614">深入理解 JavaScript 作用域和作用域链</a>。 ​<br>4、 执行上下文<br>这部分一定要按顺序连续读这几篇文章，必须多读几遍：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a>；</li>
<li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a>；</li>
<li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a>；</li>
<li><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/8">JavaScript 深入之执行上下文</a>。</li>
</ul>
<p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象（Variable object，VO）；</li>
<li>作用域链（Scope chain）；</li>
<li>this。（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a>）</li>
</ul>
<p>5、 闭包<br>根据 MDN 中文的定义，闭包的定义如下：<br>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。</p>
<p>也可以这样说：<br>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是<strong>函数参数</strong>也不是<strong>函数的局部变量</strong>的<strong>变量</strong>。 闭包 &#x3D; 函数 + 函数能够访问的自由变量。</p>
<p>在经过上一小节“执行上下文”的学习，再来阅读这篇文章：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/9">JavaScript 深入之闭包</a>，你会对闭包的实质有一定的了解。在回答时，我们这样答：<br>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。<br>闭包应用： 函数作为参数被传递：<br>function print(fn) { const a &#x3D; 200; fn(); } const a &#x3D; 100; function fn() { console.log(a); } print(fn); &#x2F;&#x2F; 100 复制代码<br>函数作为返回值被返回：<br>function create() { const a &#x3D; 100; return function () { console.log(a); }; } const fn &#x3D; create(); const a &#x3D; 200; fn(); &#x2F;&#x2F; 100 复制代码<br><strong>闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。</strong> <strong>​</strong><br>应用实例：比如缓存工具，隐藏数据，只提供 API 。<br>function createCache() { const data &#x3D; {}; &#x2F;&#x2F; 闭包中被隐藏的数据，不被外界访问 return { set: function (key, val) { data[key] &#x3D; val; }, get: function (key) { return data[key]; }, }; } const c &#x3D; createCache(); c.set(“a”, 100); console.log(c.get(“a”)); &#x2F;&#x2F; 100 复制代码<br>6、 call、apply、bind 实现<br>这部分实现还是要知道的，就算工作中不会自己手写，但是说不准面试官就是要问，知道点原理也好，可以扩宽我们写代码的思路。<br><strong>call</strong><br>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<p>举个例子：<br>var obj &#x3D; { value: “vortesnail”, }; function fn() { console.log(this.value); } fn.call(obj); &#x2F;&#x2F; vortesnail 复制代码<br>通过 <code>call</code> 方法我们做到了以下两点：</p>
<ul>
<li><code>call</code> 改变了 this 的指向，指向到 <code>obj</code> 。</li>
<li><code>fn</code> 函数执行了。</li>
</ul>
<p>那么如果我们自己写 <code>call</code> 方法的话，可以怎么做呢？我们先考虑改造 <code>obj</code> 。<br>var obj &#x3D; { value: “vortesnail”, fn: function () { console.log(this.value); }, }; obj.fn(); &#x2F;&#x2F; vortesnail 复制代码<br>这时候 this 就指向了 <code>obj</code> ，但是这样做我们手动给 <code>obj</code> 增加了一个 <code>fn</code> 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？<br>obj.fn &#x3D; fn; obj.fn(); delete obj.fn; 复制代码<br>根据这个思路，我们就可以写出来了：<br>Function.prototype.myCall &#x3D; function (context) { &#x2F;&#x2F; 判断调用对象 if (typeof this !&#x3D;&#x3D; “function”) { throw new Error(“Type error”); } &#x2F;&#x2F; 首先获取参数 let args &#x3D; […arguments].slice(1); let result &#x3D; null; &#x2F;&#x2F; 判断 context 是否传入，如果没有传就设置为 window context &#x3D; context || window; &#x2F;&#x2F; 将被调用的方法设置为 context 的属性 &#x2F;&#x2F; this 即为我们要调用的方法 context.fn &#x3D; this; &#x2F;&#x2F; 执行要被调用的方法 result &#x3D; context.fn(…args); &#x2F;&#x2F; 删除手动增加的属性方法 delete context.fn; &#x2F;&#x2F; 将执行结果返回 return result; }; 复制代码<br><strong>apply</strong><br>我们会了 <code>call</code> 的实现之后，<code>apply</code> 就变得很简单了，他们没有任何区别，除了传参方式。<br>Function.prototype.myApply &#x3D; function (context) { if (typeof this !&#x3D;&#x3D; “function”) { throw new Error(“Type error”); } let result &#x3D; null; context &#x3D; context || window; &#x2F;&#x2F; 与上面代码相比，我们使用 Symbol 来保证属性唯一 &#x2F;&#x2F; 也就是保证不会重写用户自己原来定义在 context 中的同名属性 const fnSymbol &#x3D; Symbol(); context[fnSymbol] &#x3D; this; &#x2F;&#x2F; 执行要被调用的方法 if (arguments[1]) { result &#x3D; context<a href="...arguments%5B1%5D">fnSymbol</a>; } else { result &#x3D; context<a href="">fnSymbol</a>; } delete context[fnSymbol]; return result; }; 复制代码<br><strong>bind</strong><br><code>bind</code> 返回的是一个函数，这个地方可以详细阅读这篇文章，讲的非常清楚：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/sisterAn/JavaScript-Algorithms/issues/81">解析 bind 原理，并手写 bind 实现</a>。<br>Function.prototype.myBind &#x3D; function (context) { &#x2F;&#x2F; 判断调用对象是否为函数 if (typeof this !&#x3D;&#x3D; “function”) { throw new Error(“Type error”); } &#x2F;&#x2F; 获取参数 const args &#x3D; […arguments].slice(1), const fn &#x3D; this; return function Fn() { return fn.apply( this instanceof Fn ? this : context, &#x2F;&#x2F; 当前的这个 arguments 是指 Fn 的参数 args.concat(…arguments) ); }; }; 复制代码<br>7、 new 实现</p>
<ol>
<li>首先创一个新的空对象。</li>
<li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li>
<li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li>
<li>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<p>function myNew(context) { const obj &#x3D; new Object(); obj.<strong>proto</strong> &#x3D; context.prototype; const res &#x3D; context.apply(obj, […arguments].slice(1)); return typeof res &#x3D;&#x3D;&#x3D; “object” ? res : obj; } 复制代码<br>8、 异步<br>这部分着重要理解 Promise、async awiat、event loop 等。<br>8.1 event loop、宏任务和微任务<br>首先推荐一个可以在线看代码流程的网站：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D">loupe</a>。 然后看下这个视频学习下：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1">到底什么是 Event Loop 呢？</a><br>简单的例子：<br>console.log(“Hi”); setTimeout(function cb() { console.log(“cb”); &#x2F;&#x2F; cb 即 callback }, 5000); console.log(“Bye”); 复制代码<br>它的执行过程是这样的：</p>
<p><img src="/lcz/./assets/img/interview/6.png" alt="img"></p>
<p>Web APIs 会创建对应的线程，比如 <code>setTimeout</code> 会创建定时器线程，<code>ajax</code> 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。<br>看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到<strong>宏任务</strong>和<strong>微任务</strong>，我们还得拜读一下这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a>。如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6969028296893792286%23comment">做一些动图，学习一下 EventLoop</a>。想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904165462769678">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p>
<p><strong>注意：1.Call Stack 调用栈空闲 -&gt; 2.尝试 DOM 渲染 -&gt; 触发 Event loop</strong>。</p>
<ul>
<li>每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。</li>
<li>都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。</li>
<li>然后再去触发下一次 Event loop。</li>
</ul>
<p>宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async&#x2F;await。<br>两者区别：</p>
<ul>
<li>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</li>
<li>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</li>
</ul>
<p><strong>从 event loop 解释，为何微任务执行更早？</strong></p>
<ul>
<li><p>微任务是 ES6 语法规定的（被压入 micro task queue）。</p>
</li>
<li><p>宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。</p>
</li>
<li><p>宏任务执行时间一般比较长。</p>
</li>
<li><p>每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。</p>
<p>8.2 Promise</p>
</li>
</ul>
<p>关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。<br>关于 Promise 的所有使用方式，可参照这篇文章：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/promise">ECMAScript 6 入门 - Promise 对象</a>。 手写 Promise 源码的解析文章，可阅读此篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6945319439772434469%23heading-0">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a>。 关于 Promise 的面试题，可参考这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904077537574919">要就来 45 道 Promise 面试题一次爽到底</a>。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现一个 Promise.all：</span><br><span class="line">Promise.all = function (promises) &#123;   return new Promise((resolve, reject) =&gt; &#123;     // 参数可以不是数组，但必须具有 Iterator 接口 if (typeof promises[Symbol.iterator] !== &quot;function&quot;) &#123;       reject(&quot;Type error&quot;);     &#125;     if (promises.length === 0) &#123;       resolve([]);     &#125; else &#123;       const res = [];       let count = 0;       const len = promises.length;       for (let i = 0; i &lt; len; i++) &#123;         //考虑到 promises[i] 可能是 thenable 对象也可能是普通值 Promise.resolve(promises[i])           .then((data) =&gt; &#123;             res[i] = data;             if (++count === len) &#123;               resolve(res);             &#125;           &#125;)           .catch((err) =&gt; &#123;             reject(err);           &#125;);       &#125;     &#125;   &#125;); &#125;; 复制代码</span><br></pre></td></tr></table></figure>

<p>8.3 async&#x2F;await 和 Promise 的关系</p>
<ul>
<li>async&#x2F;await 是消灭异步回调的终极武器。</li>
<li>但和 Promise 并不互斥，反而，两者相辅相成。</li>
<li>执行 async 函数，返回的一定是 Promise 对象。</li>
<li>await 相当于 Promise 的 then。</li>
<li>tru…catch 可捕获异常，代替了 Promise 的 catch。</li>
</ul>
<p>9、 浏览器的垃圾回收机制<br>这里看这篇文章即可：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6981588276356317214">「硬核 JS」你真的了解垃圾回收机制吗</a>。<br>总结一下：<br>有两种垃圾回收策略：</p>
<ul>
<li><strong>标记清除</strong>：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li>
<li><strong>引用计数</strong>：它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong>。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li>
</ul>
<p>标记清除的缺点：</p>
<ul>
<li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li>
<li><strong>分配速度慢</strong>，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li>
</ul>
<p>解决以上的缺点可以使用 **标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p>
<p><img src="/lcz/./assets/img/interview/7.png" alt="img"></p>
<p>引用计数的缺点：</p>
<ul>
<li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li>
<li>解决不了循环引用导致的无法回收问题。</li>
</ul>
<p>V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。</p>
<ul>
<li>针对新生区采用并行回收。</li>
<li>针对老生区采用增量标记与惰性回收。</li>
</ul>
<p>10、 实现一个 EventMitter 类<br>EventMitter 就是发布订阅模式的典型应用：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export class EventEmitter &#123;   private _events: Record&lt;string, Array&lt;Function&gt;&gt;;    constructor() &#123;     this._events = Object.create(null);   &#125;    emit(evt: string, ...args: any[]) &#123;     if (!this._events[evt]) return false;      const fns = [...this._events[evt]];     fns.forEach((fn) =&gt; &#123;       fn.apply(this, args);     &#125;);      return true;   &#125;    on(evt: string, fn: Function) &#123;     if (typeof fn !== &quot;function&quot;) &#123;       throw new TypeError(&quot;The evet-triggered callback must be a function&quot;);     &#125;     if (!this._events[evt]) &#123;       this._events[evt] = [fn];     &#125; else &#123;       this._events[evt].push(fn);     &#125;   &#125;    once(evt: string, fn: Function) &#123;     const execFn = () =&gt; &#123;       fn.apply(this);       this.off(evt, execFn);     &#125;;     this.on(evt, execFn);   &#125;    off(evt: string, fn?: Function) &#123;     if (!this._events[evt]) return;     if (!fn) &#123;       this._events[evt] &amp;&amp; (this._events[evt].length = 0);     &#125;      let cb;     const cbLen = this._events[evt].length;     for (let i = 0; i &lt; cbLen; i++) &#123;       cb = this._events[evt][i];       if (cb === fn) &#123;         this._events[evt].splice(i, 1);         break;       &#125;     &#125;   &#125;    removeAllListeners(evt?: string) &#123;     if (evt) &#123;       this._events[evt] &amp;&amp; (this._events[evt].length = 0);     &#125; else &#123;       this._events = Object.create(null);     &#125;   &#125; &#125; 复制代码</span><br></pre></td></tr></table></figure>

<h1 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h1><p>要掌握 cookie，localStorage 和 sessionStorage。<br>1、cookie</p>
<ul>
<li>本身用于浏览器和 server 通讯。</li>
<li>被“借用”到本地存储来的。</li>
<li>可用 document.cookie &#x3D; ‘…’ 来修改。</li>
</ul>
<p>其缺点：</p>
<ul>
<li>存储大小限制为 4KB。</li>
<li>http 请求时需要发送到服务端，增加请求数量。</li>
<li>只能用 document.cookie &#x3D; ‘…’ 来修改，太过简陋。</li>
</ul>
<p>2、localStorage 和 sessionStorage</p>
<ul>
<li>HTML5 专门为存储来设计的，最大可存 5M。</li>
<li>API 简单易用， setItem getItem。</li>
<li>不会随着 http 请求被发送到服务端。</li>
</ul>
<p>它们的区别：</p>
<ul>
<li>localStorage 数据会永久存储，除非代码删除或手动删除。</li>
<li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空。</li>
<li>一般用 localStorage 会多一些。</li>
</ul>
<h1 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h1><p>前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。<br>1、http 状态码<br>1.1 状态码分类</p>
<ul>
<li><p>1xx - 服务器收到请求。</p>
</li>
<li><p>2xx - 请求成功，如 200。</p>
</li>
<li><p>3xx - 重定向，如 302。</p>
</li>
<li><p>4xx - 客户端错误，如 404。</p>
</li>
<li><p>5xx - 服务端错误，如 500。</p>
<p>1.2 常见状态码</p>
</li>
<li><p>200 - 成功。</p>
</li>
<li><p>301 - 永久重定向（配合 location，浏览器自动处理）。</p>
</li>
<li><p>302 - 临时重定向（配合 location，浏览器自动处理）。</p>
</li>
<li><p>304 - 资源未被修改。</p>
</li>
<li><p>403 - 没权限。</p>
</li>
<li><p>404 - 资源未找到。</p>
</li>
<li><p>500 - 服务器错误。</p>
</li>
<li><p>504 - 网关超时。</p>
<p>1.3 关于协议和规范</p>
</li>
<li><p>状态码都是约定出来的。</p>
</li>
<li><p>要求大家都跟着执行。</p>
</li>
<li><p>不要违反规范，例如 IE 浏览器。</p>
</li>
</ul>
<p>2、http 缓存</p>
<ul>
<li><p>关于缓存的介绍。</p>
</li>
<li><p>http 缓存策略（强制缓存 + 协商缓存）。</p>
</li>
<li><p>刷新操作方式，对缓存的影响。</p>
<p>4.1 关于缓存<br>什么是缓存？ 把一些不需要重新获取的内容再重新获取一次<br>为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。<br>哪些资源可以被缓存？ 静态资源，比如 js css img。<br>4.2 强制缓存</p>
</li>
</ul>
<p><img src="/lcz/./assets/img/interview/8.png" alt="img"></p>
<p>Cache-Control：</p>
<ul>
<li>在 Response Headers 中。</li>
<li>控制强制缓存的逻辑。</li>
<li>例如 Cache-Control: max-age&#x3D;3153600（单位是秒）</li>
</ul>
<p>Cache-Control 有哪些值：</p>
<ul>
<li><p>max-age：缓存最大过期时间。</p>
</li>
<li><p>no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。</p>
</li>
<li><p>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。</p>
<p>4.3 协商缓存（对比缓存）</p>
</li>
<li><p>服务端缓存策略。</p>
</li>
<li><p>服务端判断客户端资源，是否和服务端资源一样。</p>
</li>
<li><p>一致则返回 304，否则返回 200 和最新的资源。</p>
</li>
</ul>
<p><img src="/lcz/./assets/img/interview/9.png" alt="img"></p>
<p>资源标识：</p>
<ul>
<li>在 Response Headers 中，有两种。</li>
<li>Last-Modified：资源的最后修改时间。</li>
<li>Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。</li>
</ul>
<p><strong>Last-Modified：</strong></p>
<p><img src="/lcz/./assets/img/interview/10.png" alt="img"></p>
<p>服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。<br><strong>Etag：</strong></p>
<p><img src="/lcz/./assets/img/interview/11.png" alt="img"></p>
<p>其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。<br><strong>两者比较：</strong></p>
<ul>
<li><p>优先使用 Etag。</p>
</li>
<li><p>Last-Modified 只能精确到秒级。</p>
</li>
<li><p>如果资源被重复生成，而内容不变，则 Etag 更精确。</p>
<p>4.4 综述</p>
</li>
</ul>
<p><img src="/lcz/./assets/img/interview/12.png" alt="img"></p>
<p>4.4 三种刷新操作对 http 缓存的影响</p>
<ul>
<li>正常操作：地址栏输入 url，跳转链接，前进后退等。</li>
<li>手动刷新：f5，点击刷新按钮，右键菜单刷新。</li>
<li>强制刷新：ctrl + f5，shift+command+r。</li>
</ul>
<p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong> ****</p>
<ol start="3">
<li>面试</li>
</ol>
<p><strong>对于更多面试中可能出现的问题，我还是建议精读这篇三元的文章：</strong><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904100035821575">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a>。<br>比如会被经常问到的： GET 和 POST 的区别。</p>
<ul>
<li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>
<li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>
<li>从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li>
<li>从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>
</ul>
<p>HTTP&#x2F;2 有哪些改进？（很大可能问原理）</p>
<ul>
<li>头部压缩。</li>
<li>多路复用。</li>
<li>服务器推送。</li>
</ul>
<p>关于 HTTPS 的一些原理，可以阅读这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904038509576199">这一次，彻底理解 https 原理</a>。接着你可以观看这个视频进行更进一步的学习：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1XL411b7KZ?p=1">HTTPS 底层原理，面试官直接下跪，唱征服！</a><br>关于<strong>跨域</strong>问题，大部分文章都是理论性比较强，还不如读这篇文章，<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/149734572?from_voters_page=true">聊聊跨域的原理与解决方法</a>，讲的非常清晰，我个人觉得对付面试就是先知道使用流程，把这个流程能自己说出来，然后再讲下原理即可。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>1、 React 事件机制，React 16 和 React 17 事件机制的不同<br>阅读这篇文章即可：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6955636911214067720">一文吃透 react 事件系统原理</a>。<br>为什么要自定义事件机制？</p>
<ul>
<li>抹平浏览器差异，实现更好的跨平台。</li>
<li>避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。</li>
<li>方便事件统一管理和事务机制。</li>
</ul>
<p>2、class component<br>不排除现在还会有面试官问关于 class component 的问题。<br>2.1 生命周期</p>
<ul>
<li>初始化阶段。</li>
</ul>
<p>发生在 <code>constructor</code> 中的内容，在 <code>constructor</code> 中进行 <code>state</code> 、<code>props</code> 的初始化，在这个阶段修改 <code>state</code>，不会执行更新阶段的生命周期，可以直接对 <code>state</code> 赋值。</p>
<ul>
<li><p>挂载阶段。</p>
</li>
<li><p>componentWillMount 发生在 render 函数之前，还没有挂载 Dom 2. render 3. componentDidMount 发生在 render 函数之后，已经挂载 Dom 复制代码</p>
</li>
<li><p>更新阶段。</p>
</li>
</ul>
<p>更新阶段分为由 <code>state</code> 更新引起和 <code>props</code> 更新引起。<br>props 更新时： 1. componentWillReceiveProps(nextProps,nextState) 这个生命周期主要为我们提供对 props 发生改变的监听，如果你需要在 props 发生改变后，相应改变组件的一些 state。在这个方法中改变 state 不会二次渲染，而是直接合并 state。 2. shouldComponentUpdate(nextProps,nextState) 这个生命周期需要返回一个 Boolean 类型的值，判断是否需要更新渲染组件，优化 react 应用的主要手段之一，当返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。 3. componentWillUpdate(nextProps,nextState) 这个生命周期主要是给我们一个时机能够处理一些在 Dom 发生更新之前的事情，如获得 Dom 更新前某些元素的坐标、大小等，在这个阶段不可以 setState()，会导致循环调用。 <strong>一直到这里 this.props 和 this.state 都还未发生更新</strong> 4. render 5. componentDidUpdate(prevProps, prevState) 在此时已经完成渲染，Dom 已经发生变化，state 已经发生更新，prevProps、prevState 均为上一个状态的值。 state 更新时（具体同上） 1. shouldComponentUpdate 2. componentWillUpdate 3. render 4. componentDidUpdate 复制代码</p>
<ul>
<li>卸载阶段。</li>
<li>componentWillUnmount 在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount 中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。 复制代码</li>
</ul>
<p>在 React 16 中官方已经建议删除以下三个方法，非要使用必须加前缀：<code>UNSAVE_</code> 。<br>componentWillMount; componentWillReceiveProps; componentWillUpdate; 复制代码<br>取代这两三个生命周期的以下两个新的。</p>
<ol>
<li>static getDerivedStateFromProps(nextProps,nextState) 在组件实例化、接收到新的 props 、组件状态更新时会被调用 2. getSnapshotBeforeUpdate（prevProps,prevState） 在这个阶段我们可以拿到上一个状态 Dom 元素的坐标、大小的等相关信息。用于替代旧的生命周期中的 componentWillUpdate。 该函数的返回值将会作为 componentDidUpdate 的第三个参数出现。 复制代码</li>
</ol>
<p>需要注意的是，一般都会问为什么要废弃三个生命周期，原因是什么。<br>2.2 setState 同步还是异步<br><code>setState</code> 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。</p>
<ul>
<li>如果 <code>setState</code> 在 React 能够控制的范围被调用，它就是<strong>异步</strong>的。比如<strong>合成事件处理函数</strong>，<strong>生命周期函数</strong>， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。</li>
<li>如果 <code>setState</code> 在原生 JavaScript 控制的范围被调用，它就是<strong>同步</strong>的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 <code>setState</code> 被调用后会立即更新 DOM 。</li>
</ul>
<p>3、对函数式编程的理解<br>这篇文章写的真的太好了，一定要读：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903936378273799">简明 JavaScript 函数式编程——入门篇</a>。<br>总结一下： 函数式编程有两个核心概念。</p>
<ul>
<li><strong>数据不可变（无副作用）：</strong> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</li>
<li><strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</li>
</ul>
<p>纯函数带来的意义。</p>
<ul>
<li><strong>便于测试和优化</strong>：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。</li>
<li><strong>可缓存性</strong>：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。</li>
<li><strong>更少的 Bug</strong>：使用纯函数意味着你的函数中<strong>不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改</strong>，这些共享状态往往是绝大多数 bug 的源头。</li>
</ul>
<p>4、react hooks<br>现在应该大多数面试官会问 hooks 相关的啦。这里我强烈推荐三篇文章，即使没看过源码，也能比较好地理解一些原理：<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904127110053895">用动画和实战打开 React Hooks（一）：useState 和 useEffect</a><br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904132164190221">用动画和实战打开 React Hooks（二）：自定义 Hook 和 useCallback</a><br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904149746728973">用动画和实战打开 React Hooks（三）：useReducer 和 useContext</a><br>4.1 为什么不能在条件语句中写 hook<br>推荐这篇文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6939766434159394830">我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁</a>。<br>hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。<br>4.2 HOC 和 hook 的区别<br>hoc 能复用<strong>逻辑和视图</strong>，hook 只能复用<strong>逻辑</strong>。<br>4.3 useEffect 和 useLayoutEffect 区别<br>对于 React 的函数组件来说，其更新过程大致分为以下步骤：</p>
<ol>
<li>因为某个事件 <code>state</code> 发生变化。</li>
<li>React 内部更新 <code>state</code> 变量。</li>
<li>React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。</li>
<li>将更新过后的 DOM 数据绘制到浏览器中。</li>
<li>用户看到新的页面。</li>
</ol>
<p><code>useEffect</code> 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 <code>useLayoutEffect</code> 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。<br>4.4 useEffect 依赖为空数组与 componentDidMount 区别<br>在 <code>render</code> 执行之后，<code>componentDidMount</code> 会执行，如果在这个生命周期中再一次 <code>setState</code> ，会导致再次 <code>render</code> ，返回了新的值，浏览器只会渲染第二次 <code>render</code> 返回的值，这样可以避免闪屏。<br>但是 <code>useEffect</code> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 <code>render</code> ，有可能会闪屏。<br>实际上 <code>useLayoutEffect</code> 会更接近 <code>componentDidMount</code> 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。<br>4.5 React.memo() 和 React.useMemo() 的区别</p>
<ul>
<li><p><code>memo</code> 是一个高阶组件，默认情况下会对 <code>props</code> 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。</p>
</li>
<li><p><code>useMemo</code> 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，<code>useMemo</code> 是在 <code>render</code> 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴。</p>
<p>4.6 React.useCallback() 和 React.useMemo() 的区别</p>
</li>
<li><p><code>useCallback</code> 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。</p>
</li>
<li><p><code>useMemo</code> 可缓存值。</p>
</li>
</ul>
<p>有很多时候，我们在 <code>useEffect</code> 中使用某个定义的外部函数，是要添加到 <code>deps</code> 数组中的，如果不用 <code>useCallback</code> 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 <code>useEffect</code> 总会无意义的执行。<br>4.7 React.forwardRef 是什么及其作用<br>这里还是阅读官方文档来的清晰：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/react-api.html%23reactforwardref">React.forwardRef</a>。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。<br>6、react hooks 与 class 组件对比<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904179136200712">react hooks 与 class 组件对比</a> <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同</a><br>7、介绍 React dom diff 算法<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903806132568072">让虚拟 DOM 和 DOM-diff 不再成为你的绊脚石</a>。<br>8、对 React Fiber 的理解<br>关于这块儿我觉得可以好好阅读下这篇无敌的博客了：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://pomb.us/build-your-own-react/">Build your own React</a>。 它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。<br>然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章： <a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903975112671239">这可能是最通俗的 React Fiber(时间分片) 打开方式</a><br>9、React 性能优化手段<br>推荐文章：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903924302888973">React 性能优化的 8 种方式了解一下？</a></p>
<ul>
<li>使用 <code>React.memo</code> 来缓存组件。</li>
<li>使用 <code>React.useMemo</code> 缓存大量的计算。</li>
<li>避免使用匿名函数。</li>
<li>利用 <code>React.lazy</code> 和 <code>React.Suspense</code> 延迟加载不是立即需要的组件。</li>
<li>尽量使用 CSS 而不是强制加载和卸载组件。</li>
<li>使用 <code>React.Fragment</code> 避免添加额外的 DOM。</li>
</ul>
<p>10、React Redux<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904021187117069">Redux 包教包会（一）：介绍 Redux 三大核心概念</a></p>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>原理初探：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6943468761575849992">当面试官问 Webpack 的时候他想知道什么</a><br>简易实现：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/Cosen95/blog/issues/48">面试官：webpack 原理都不会</a>，<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://segmentfault.com/a/1190000039231950">手写一个 webpack，看看 AST 怎么用</a><br>加料：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903520378814471">简单易懂的 webpack 打包后 JS 的运行过程</a>，<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6888936770692448270">Webpack 手写 loader 和 plugin</a><br>热更新原理：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a><br>面试题：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打 Webpack 面试题</a><br><strong>这里要注意，应该还会考 webpack5 和 4 有哪些区别。</strong></p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a> （这里面没有讲 umd）<br><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903927104667662">可能是最详细的 UMD 模块入门指南</a></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>代码层面：</p>
<ul>
<li>防抖和节流（resize，scroll，input）。</li>
<li>减少回流（重排）和重绘。</li>
<li>事件委托。</li>
<li>css 放 ，js 脚本放 最底部。</li>
<li>减少 DOM 操作。</li>
<li>按需加载，比如 React 中使用 <code>React.lazy</code> 和 <code>React.Suspense</code> ，通常需要与 webpack 中的 <code>splitChunks</code> 配合。</li>
</ul>
<p>构建方面：</p>
<ul>
<li><strong>压缩代码文件</strong>，在 webpack 中使用 <code>terser-webpack-plugin</code> 压缩 Javascript 代码；使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS 代码；使用 <code>html-webpack-plugin</code> 压缩 html 代码。</li>
<li><strong>开启 gzip 压缩</strong>，webpack 中使用 <code>compression-webpack-plugin</code> ，node 作为服务器也要开启，使用 <code>compression</code>。</li>
<li><strong>常用的第三方库使用 CDN 服务</strong>，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。</li>
</ul>
<p>其它：</p>
<ul>
<li>使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。</li>
<li>使用服务端渲染。</li>
<li>图片压缩。</li>
<li>使用 http 缓存，比如服务端的响应中添加 <code>Cache-Control / Expires</code> 。</li>
</ul>
<h1 id="常见手写"><a href="#常见手写" class="headerlink" title="常见手写"></a>常见手写</h1><p>以下的内容是上面没有提到的手写，比如 <code>new</code> 、<code>Promise.all</code> 这种上面内容中已经提到了如何写。<br>1、防抖<br><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/22">JavaScript 专题之跟着 underscore 学防抖 </a>​<br>function debounce(func, wait, immediate) { let timeout; return function () { let context &#x3D; this; let args &#x3D; arguments; if (timeout) clearTimeout(timeout); if (immediate) { let callNow &#x3D; !timeout; timeout &#x3D; setTimeout(function () { timeout &#x3D; null; }, wait); if (callNow) func.apply(context, args); } else { timeout &#x3D; setTimeout(function () { func.apply(context, args); }, wait); } }; } 复制代码<br>2、节流<br><a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/26">JavaScript 专题之跟着 underscore 学节流</a><br>&#x2F;&#x2F; 使用时间戳 function throttle(func, wait) { let preTime &#x3D; 0; return function () { let nowTime &#x3D; +new Date(); let context &#x3D; this; let args &#x3D; arguments; if (nowTime - preTime &gt; wait) { func.apply(context, args); preTime &#x3D; nowTime; } }; } &#x2F;&#x2F; 定时器实现 function throttle(func, wait) { let timeout; return function () { let context &#x3D; this; let args &#x3D; arguments; if (!timeout) { timeout &#x3D; setTimeout(function () { timeout &#x3D; null; func.apply(context, args); }, wait); } }; } 复制代码<br>3、快速排序<br>这里对快排思想不太明白的同学可以看下这个讲解的很清晰的视频：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1at411T75o?from=search&seid=10065750342799523965&spm_id_from=333.337.0.0">快速排序算法</a>。<br>function sortArray(nums) { quickSort(0, nums.length - 1, nums); return nums; } function quickSort(start, end, arr) { if (start &lt; end) { const mid &#x3D; sort(start, end, arr); quickSort(start, mid - 1, arr); quickSort(mid + 1, end, arr); } } function sort(start, end, arr) { const base &#x3D; arr[start]; let left &#x3D; start; let right &#x3D; end; while (left !&#x3D;&#x3D; right) { while (arr[right] &gt;&#x3D; base &amp;&amp; right &gt; left) { right–; } arr[left] &#x3D; arr[right]; while (arr[left] &lt;&#x3D; base &amp;&amp; right &gt; left) { left++; } arr[right] &#x3D; arr[left]; } arr[left] &#x3D; base; return left; } 复制代码<br>4、instanceof<br>这个手写一定要懂原型及原型链。<br>function myInstanceof(target, origin) { if (typeof target !&#x3D;&#x3D; “object” || target &#x3D;&#x3D;&#x3D; null) return false; if (typeof origin !&#x3D;&#x3D; “function”) throw new TypeError(“origin must be function”); let proto &#x3D; Object.getPrototypeOf(target); &#x2F;&#x2F; 相当于 proto &#x3D; target.<strong>proto</strong>; while (proto) { if (proto &#x3D;&#x3D;&#x3D; origin.prototype) return true; proto &#x3D; Object.getPrototypeOf(proto); } return false; } 复制代码<br>5、数组扁平化<br>重点，不要觉得用不到就不管，这道题就是考察你对 js 语法的熟练程度以及手写代码的基本能力。<br>function flat(arr, depth &#x3D; 1) { if (depth &gt; 0) { &#x2F;&#x2F; 以下代码还可以简化，不过为了可读性，还是…. return arr.reduce((pre, cur) &#x3D;&gt; { return pre.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur); }, []); } return arr.slice(); } 复制代码<br>6、手写 reduce<br>先不考虑第二个参数初始值：<br>Array.prototype.reduce &#x3D; function (cb) { const arr &#x3D; this; &#x2F;&#x2F;this 就是调用 reduce 方法的数组 let total &#x3D; arr[0]; &#x2F;&#x2F; 默认为数组的第一项 for (let i &#x3D; 1; i &lt; arr.length; i++) { total &#x3D; cb(total, arr[i], i, arr); } return total; }; 复制代码<br>考虑上初始值：<br>Array.prototype.reduce &#x3D; function (cb, initialValue) { const arr &#x3D; this; let total &#x3D; initialValue || arr[0]; &#x2F;&#x2F; 有初始值的话从 0 遍历，否则从 1 遍历 for (let i &#x3D; initialValue ? 0 : 1; i &lt; arr.length; i++) { total &#x3D; cb(total, arr[i], i, arr); } return total; }; 复制代码<br>7、带并发的异步调度器 Scheduler<br>JS 实现一个带并发限制的异度调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。<br>class Scheduler { add(promiseMaker) {} } const timeout &#x3D; (time) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; { setTimeout(resolve, time); }); const scheduler &#x3D; new Scheduler(); const addTask &#x3D; (time, order) &#x3D;&gt; { scheduler.add(() &#x3D;&gt; timeout(time).then(() &#x3D;&gt; console.log(order))); }; addTask(1000, “1”); addTask(500, “2”); addTask(300, “3”); addTask(400, “4”); &#x2F;&#x2F; output：2 3 1 4 &#x2F;&#x2F; 一开始，1，2 两个任务进入队列。 &#x2F;&#x2F; 500ms 时，2 完成，输出 2，任务 3 入队。 &#x2F;&#x2F; 800ms 时，3 完成，输出 3，任务 4 入队。 &#x2F;&#x2F; 1000ms 时，1 完成，输出 1。 复制代码<br>根据题目，我们只需要操作 <code>Scheduler</code> 类就行：<br>class Scheduler { constructor() { this.waitTasks &#x3D; []; &#x2F;&#x2F; 待执行的任务队列 this.excutingTasks &#x3D; []; &#x2F;&#x2F; 正在执行的任务队列 this.maxExcutingNum &#x3D; 2; &#x2F;&#x2F; 允许同时运行的任务数量 } add(promiseMaker) { if (this.excutingTasks.length &lt; this.maxExcutingNum) { this.run(promiseMaker); } else { this.waitTasks.push(promiseMaker); } } run(promiseMaker) { const len &#x3D; this.excutingTasks.push(promiseMaker); const index &#x3D; len - 1; promiseMaker().then(() &#x3D;&gt; { this.excutingTasks.splice(index, 1); if (this.waitTasks.length &gt; 0) { this.run(this.waitTasks.shift()); } }); } } 复制代码<br>8、去重</p>
<ul>
<li>利用 ES6 <code>set</code> 关键字：</li>
</ul>
<p>function unique(arr) { return […new Set(arr)]; } 复制代码</p>
<ul>
<li>利用 ES5 <code>filter</code> 方法：</li>
</ul>
<p>function unique(arr) { return arr.filter((item, index, array) &#x3D;&gt; { return array.indexOf(item) &#x3D;&#x3D;&#x3D; index; }); } 复制代码</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ol>
<li>requestAnimationFrame（<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6991297852462858277">一个神奇的前端动画 API requestAnimationFrame</a>）</li>
<li>如何排查内存泄漏问题，面试官可能会问为什么页面越来越卡顿，直至卡死，怎么定位到产生这种现象的源代码（开发环境）？（<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6947841638118998029">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a>）</li>
<li>vite 大火，我复习的时候是去年 9 月份，还没那么火，可能现在的你需要学一学了～</li>
<li>vue3 也一样，如果你是 React 技术栈（就像我之前一样）当我没说。</li>
</ol>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>这部分大家可以点击以下这个仓库，按照仓库中的题目顺序进行刷题，都是我亲自刷过的，排了最适合的顺序：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/vortesnail/leetcode">vortesnail&#x2F;leetcode</a>。<br>然后如果大家想看下大厂的算法高频题可以看这个仓库：<a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://github.com/afatcoder/LeetcodeTop">afatcoder&#x2F;LeetcodeTop</a>。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/lcz/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/lcz/2022/06/07/VUE-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/" rel="prev" title="VUE 自定义组件库搭建">
                  <i class="fa fa-chevron-left"></i> VUE 自定义组件库搭建
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/lcz/2023/04/28/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="2023前端面试题">
                  2023前端面试题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cz-liang</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/lcz/js/comments.js"></script><script src="/lcz/js/utils.js"></script><script src="/lcz/js/motion.js"></script><script src="/lcz/js/next-boot.js"></script>

  





  





</body>
</html>
